// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ripple.proto

#include "ripple.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
extern PROTOBUF_INTERNAL_EXPORT_ripple_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_TMClusterNode_ripple_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_ripple_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_TMEndpoints_TMEndpointv2_ripple_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_ripple_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_TMIndexedObject_ripple_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_ripple_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_TMLedgerNode_ripple_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_ripple_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_TMLink_ripple_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_ripple_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_TMLoadSource_ripple_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_ripple_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_TMManifest_ripple_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_ripple_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_TMPeerShardInfoV2_TMIncomplete_ripple_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_ripple_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_TMPublicKey_ripple_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_ripple_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_TMTransaction_ripple_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_ripple_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_ValidatorBlobInfo_ripple_2eproto;
namespace protocol {
class TMManifestDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TMManifest> _instance;
} _TMManifest_default_instance_;
class TMManifestsDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TMManifests> _instance;
} _TMManifests_default_instance_;
class TMClusterNodeDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TMClusterNode> _instance;
} _TMClusterNode_default_instance_;
class TMLoadSourceDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TMLoadSource> _instance;
} _TMLoadSource_default_instance_;
class TMClusterDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TMCluster> _instance;
} _TMCluster_default_instance_;
class TMLinkDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TMLink> _instance;
} _TMLink_default_instance_;
class TMGetPeerShardInfoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TMGetPeerShardInfo> _instance;
} _TMGetPeerShardInfo_default_instance_;
class TMPeerShardInfoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TMPeerShardInfo> _instance;
} _TMPeerShardInfo_default_instance_;
class TMPublicKeyDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TMPublicKey> _instance;
} _TMPublicKey_default_instance_;
class TMGetPeerShardInfoV2DefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TMGetPeerShardInfoV2> _instance;
} _TMGetPeerShardInfoV2_default_instance_;
class TMPeerShardInfoV2_TMIncompleteDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TMPeerShardInfoV2_TMIncomplete> _instance;
} _TMPeerShardInfoV2_TMIncomplete_default_instance_;
class TMPeerShardInfoV2DefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TMPeerShardInfoV2> _instance;
} _TMPeerShardInfoV2_default_instance_;
class TMTransactionDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TMTransaction> _instance;
} _TMTransaction_default_instance_;
class TMTransactionsDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TMTransactions> _instance;
} _TMTransactions_default_instance_;
class TMStatusChangeDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TMStatusChange> _instance;
} _TMStatusChange_default_instance_;
class TMProposeSetDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TMProposeSet> _instance;
} _TMProposeSet_default_instance_;
class TMHaveTransactionSetDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TMHaveTransactionSet> _instance;
} _TMHaveTransactionSet_default_instance_;
class TMValidatorListDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TMValidatorList> _instance;
} _TMValidatorList_default_instance_;
class ValidatorBlobInfoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<ValidatorBlobInfo> _instance;
} _ValidatorBlobInfo_default_instance_;
class TMValidatorListCollectionDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TMValidatorListCollection> _instance;
} _TMValidatorListCollection_default_instance_;
class TMValidationDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TMValidation> _instance;
} _TMValidation_default_instance_;
class TMEndpoints_TMEndpointv2DefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TMEndpoints_TMEndpointv2> _instance;
} _TMEndpoints_TMEndpointv2_default_instance_;
class TMEndpointsDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TMEndpoints> _instance;
} _TMEndpoints_default_instance_;
class TMIndexedObjectDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TMIndexedObject> _instance;
} _TMIndexedObject_default_instance_;
class TMGetObjectByHashDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TMGetObjectByHash> _instance;
} _TMGetObjectByHash_default_instance_;
class TMLedgerNodeDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TMLedgerNode> _instance;
} _TMLedgerNode_default_instance_;
class TMGetLedgerDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TMGetLedger> _instance;
} _TMGetLedger_default_instance_;
class TMLedgerDataDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TMLedgerData> _instance;
} _TMLedgerData_default_instance_;
class TMPingDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TMPing> _instance;
} _TMPing_default_instance_;
class TMSquelchDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TMSquelch> _instance;
} _TMSquelch_default_instance_;
class TMProofPathRequestDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TMProofPathRequest> _instance;
} _TMProofPathRequest_default_instance_;
class TMProofPathResponseDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TMProofPathResponse> _instance;
} _TMProofPathResponse_default_instance_;
class TMReplayDeltaRequestDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TMReplayDeltaRequest> _instance;
} _TMReplayDeltaRequest_default_instance_;
class TMReplayDeltaResponseDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TMReplayDeltaResponse> _instance;
} _TMReplayDeltaResponse_default_instance_;
class TMHaveTransactionsDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TMHaveTransactions> _instance;
} _TMHaveTransactions_default_instance_;
}  // namespace protocol
static void InitDefaultsscc_info_TMCluster_ripple_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::protocol::_TMCluster_default_instance_;
    new (ptr) ::protocol::TMCluster();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::protocol::TMCluster::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_TMCluster_ripple_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 2, 0, InitDefaultsscc_info_TMCluster_ripple_2eproto}, {
      &scc_info_TMClusterNode_ripple_2eproto.base,
      &scc_info_TMLoadSource_ripple_2eproto.base,}};

static void InitDefaultsscc_info_TMClusterNode_ripple_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::protocol::_TMClusterNode_default_instance_;
    new (ptr) ::protocol::TMClusterNode();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::protocol::TMClusterNode::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_TMClusterNode_ripple_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_TMClusterNode_ripple_2eproto}, {}};

static void InitDefaultsscc_info_TMEndpoints_ripple_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::protocol::_TMEndpoints_default_instance_;
    new (ptr) ::protocol::TMEndpoints();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::protocol::TMEndpoints::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_TMEndpoints_ripple_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_TMEndpoints_ripple_2eproto}, {
      &scc_info_TMEndpoints_TMEndpointv2_ripple_2eproto.base,}};

static void InitDefaultsscc_info_TMEndpoints_TMEndpointv2_ripple_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::protocol::_TMEndpoints_TMEndpointv2_default_instance_;
    new (ptr) ::protocol::TMEndpoints_TMEndpointv2();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::protocol::TMEndpoints_TMEndpointv2::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_TMEndpoints_TMEndpointv2_ripple_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_TMEndpoints_TMEndpointv2_ripple_2eproto}, {}};

static void InitDefaultsscc_info_TMGetLedger_ripple_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::protocol::_TMGetLedger_default_instance_;
    new (ptr) ::protocol::TMGetLedger();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::protocol::TMGetLedger::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_TMGetLedger_ripple_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_TMGetLedger_ripple_2eproto}, {}};

static void InitDefaultsscc_info_TMGetObjectByHash_ripple_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::protocol::_TMGetObjectByHash_default_instance_;
    new (ptr) ::protocol::TMGetObjectByHash();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::protocol::TMGetObjectByHash::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_TMGetObjectByHash_ripple_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_TMGetObjectByHash_ripple_2eproto}, {
      &scc_info_TMIndexedObject_ripple_2eproto.base,}};

static void InitDefaultsscc_info_TMGetPeerShardInfo_ripple_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::protocol::_TMGetPeerShardInfo_default_instance_;
    new (ptr) ::protocol::TMGetPeerShardInfo();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::protocol::TMGetPeerShardInfo::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_TMGetPeerShardInfo_ripple_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_TMGetPeerShardInfo_ripple_2eproto}, {
      &scc_info_TMLink_ripple_2eproto.base,}};

static void InitDefaultsscc_info_TMGetPeerShardInfoV2_ripple_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::protocol::_TMGetPeerShardInfoV2_default_instance_;
    new (ptr) ::protocol::TMGetPeerShardInfoV2();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::protocol::TMGetPeerShardInfoV2::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_TMGetPeerShardInfoV2_ripple_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_TMGetPeerShardInfoV2_ripple_2eproto}, {
      &scc_info_TMPublicKey_ripple_2eproto.base,}};

static void InitDefaultsscc_info_TMHaveTransactionSet_ripple_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::protocol::_TMHaveTransactionSet_default_instance_;
    new (ptr) ::protocol::TMHaveTransactionSet();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::protocol::TMHaveTransactionSet::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_TMHaveTransactionSet_ripple_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_TMHaveTransactionSet_ripple_2eproto}, {}};

static void InitDefaultsscc_info_TMHaveTransactions_ripple_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::protocol::_TMHaveTransactions_default_instance_;
    new (ptr) ::protocol::TMHaveTransactions();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::protocol::TMHaveTransactions::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_TMHaveTransactions_ripple_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_TMHaveTransactions_ripple_2eproto}, {}};

static void InitDefaultsscc_info_TMIndexedObject_ripple_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::protocol::_TMIndexedObject_default_instance_;
    new (ptr) ::protocol::TMIndexedObject();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::protocol::TMIndexedObject::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_TMIndexedObject_ripple_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_TMIndexedObject_ripple_2eproto}, {}};

static void InitDefaultsscc_info_TMLedgerData_ripple_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::protocol::_TMLedgerData_default_instance_;
    new (ptr) ::protocol::TMLedgerData();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::protocol::TMLedgerData::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_TMLedgerData_ripple_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_TMLedgerData_ripple_2eproto}, {
      &scc_info_TMLedgerNode_ripple_2eproto.base,}};

static void InitDefaultsscc_info_TMLedgerNode_ripple_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::protocol::_TMLedgerNode_default_instance_;
    new (ptr) ::protocol::TMLedgerNode();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::protocol::TMLedgerNode::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_TMLedgerNode_ripple_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_TMLedgerNode_ripple_2eproto}, {}};

static void InitDefaultsscc_info_TMLink_ripple_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::protocol::_TMLink_default_instance_;
    new (ptr) ::protocol::TMLink();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::protocol::TMLink::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_TMLink_ripple_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_TMLink_ripple_2eproto}, {}};

static void InitDefaultsscc_info_TMLoadSource_ripple_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::protocol::_TMLoadSource_default_instance_;
    new (ptr) ::protocol::TMLoadSource();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::protocol::TMLoadSource::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_TMLoadSource_ripple_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_TMLoadSource_ripple_2eproto}, {}};

static void InitDefaultsscc_info_TMManifest_ripple_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::protocol::_TMManifest_default_instance_;
    new (ptr) ::protocol::TMManifest();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::protocol::TMManifest::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_TMManifest_ripple_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_TMManifest_ripple_2eproto}, {}};

static void InitDefaultsscc_info_TMManifests_ripple_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::protocol::_TMManifests_default_instance_;
    new (ptr) ::protocol::TMManifests();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::protocol::TMManifests::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_TMManifests_ripple_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_TMManifests_ripple_2eproto}, {
      &scc_info_TMManifest_ripple_2eproto.base,}};

static void InitDefaultsscc_info_TMPeerShardInfo_ripple_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::protocol::_TMPeerShardInfo_default_instance_;
    new (ptr) ::protocol::TMPeerShardInfo();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::protocol::TMPeerShardInfo::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_TMPeerShardInfo_ripple_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_TMPeerShardInfo_ripple_2eproto}, {
      &scc_info_TMLink_ripple_2eproto.base,}};

static void InitDefaultsscc_info_TMPeerShardInfoV2_ripple_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::protocol::_TMPeerShardInfoV2_default_instance_;
    new (ptr) ::protocol::TMPeerShardInfoV2();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::protocol::TMPeerShardInfoV2::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_TMPeerShardInfoV2_ripple_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 2, 0, InitDefaultsscc_info_TMPeerShardInfoV2_ripple_2eproto}, {
      &scc_info_TMPeerShardInfoV2_TMIncomplete_ripple_2eproto.base,
      &scc_info_TMPublicKey_ripple_2eproto.base,}};

static void InitDefaultsscc_info_TMPeerShardInfoV2_TMIncomplete_ripple_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::protocol::_TMPeerShardInfoV2_TMIncomplete_default_instance_;
    new (ptr) ::protocol::TMPeerShardInfoV2_TMIncomplete();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::protocol::TMPeerShardInfoV2_TMIncomplete::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_TMPeerShardInfoV2_TMIncomplete_ripple_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_TMPeerShardInfoV2_TMIncomplete_ripple_2eproto}, {}};

static void InitDefaultsscc_info_TMPing_ripple_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::protocol::_TMPing_default_instance_;
    new (ptr) ::protocol::TMPing();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::protocol::TMPing::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_TMPing_ripple_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_TMPing_ripple_2eproto}, {}};

static void InitDefaultsscc_info_TMProofPathRequest_ripple_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::protocol::_TMProofPathRequest_default_instance_;
    new (ptr) ::protocol::TMProofPathRequest();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::protocol::TMProofPathRequest::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_TMProofPathRequest_ripple_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_TMProofPathRequest_ripple_2eproto}, {}};

static void InitDefaultsscc_info_TMProofPathResponse_ripple_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::protocol::_TMProofPathResponse_default_instance_;
    new (ptr) ::protocol::TMProofPathResponse();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::protocol::TMProofPathResponse::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_TMProofPathResponse_ripple_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_TMProofPathResponse_ripple_2eproto}, {}};

static void InitDefaultsscc_info_TMProposeSet_ripple_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::protocol::_TMProposeSet_default_instance_;
    new (ptr) ::protocol::TMProposeSet();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::protocol::TMProposeSet::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_TMProposeSet_ripple_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_TMProposeSet_ripple_2eproto}, {}};

static void InitDefaultsscc_info_TMPublicKey_ripple_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::protocol::_TMPublicKey_default_instance_;
    new (ptr) ::protocol::TMPublicKey();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::protocol::TMPublicKey::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_TMPublicKey_ripple_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_TMPublicKey_ripple_2eproto}, {}};

static void InitDefaultsscc_info_TMReplayDeltaRequest_ripple_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::protocol::_TMReplayDeltaRequest_default_instance_;
    new (ptr) ::protocol::TMReplayDeltaRequest();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::protocol::TMReplayDeltaRequest::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_TMReplayDeltaRequest_ripple_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_TMReplayDeltaRequest_ripple_2eproto}, {}};

static void InitDefaultsscc_info_TMReplayDeltaResponse_ripple_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::protocol::_TMReplayDeltaResponse_default_instance_;
    new (ptr) ::protocol::TMReplayDeltaResponse();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::protocol::TMReplayDeltaResponse::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_TMReplayDeltaResponse_ripple_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_TMReplayDeltaResponse_ripple_2eproto}, {}};

static void InitDefaultsscc_info_TMSquelch_ripple_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::protocol::_TMSquelch_default_instance_;
    new (ptr) ::protocol::TMSquelch();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::protocol::TMSquelch::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_TMSquelch_ripple_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_TMSquelch_ripple_2eproto}, {}};

static void InitDefaultsscc_info_TMStatusChange_ripple_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::protocol::_TMStatusChange_default_instance_;
    new (ptr) ::protocol::TMStatusChange();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::protocol::TMStatusChange::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_TMStatusChange_ripple_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_TMStatusChange_ripple_2eproto}, {}};

static void InitDefaultsscc_info_TMTransaction_ripple_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::protocol::_TMTransaction_default_instance_;
    new (ptr) ::protocol::TMTransaction();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::protocol::TMTransaction::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_TMTransaction_ripple_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_TMTransaction_ripple_2eproto}, {}};

static void InitDefaultsscc_info_TMTransactions_ripple_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::protocol::_TMTransactions_default_instance_;
    new (ptr) ::protocol::TMTransactions();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::protocol::TMTransactions::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_TMTransactions_ripple_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_TMTransactions_ripple_2eproto}, {
      &scc_info_TMTransaction_ripple_2eproto.base,}};

static void InitDefaultsscc_info_TMValidation_ripple_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::protocol::_TMValidation_default_instance_;
    new (ptr) ::protocol::TMValidation();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::protocol::TMValidation::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_TMValidation_ripple_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_TMValidation_ripple_2eproto}, {}};

static void InitDefaultsscc_info_TMValidatorList_ripple_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::protocol::_TMValidatorList_default_instance_;
    new (ptr) ::protocol::TMValidatorList();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::protocol::TMValidatorList::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_TMValidatorList_ripple_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_TMValidatorList_ripple_2eproto}, {}};

static void InitDefaultsscc_info_TMValidatorListCollection_ripple_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::protocol::_TMValidatorListCollection_default_instance_;
    new (ptr) ::protocol::TMValidatorListCollection();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::protocol::TMValidatorListCollection::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_TMValidatorListCollection_ripple_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_TMValidatorListCollection_ripple_2eproto}, {
      &scc_info_ValidatorBlobInfo_ripple_2eproto.base,}};

static void InitDefaultsscc_info_ValidatorBlobInfo_ripple_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::protocol::_ValidatorBlobInfo_default_instance_;
    new (ptr) ::protocol::ValidatorBlobInfo();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::protocol::ValidatorBlobInfo::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_ValidatorBlobInfo_ripple_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_ValidatorBlobInfo_ripple_2eproto}, {}};

static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_ripple_2eproto[35];
static const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* file_level_enum_descriptors_ripple_2eproto[12];
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_ripple_2eproto = nullptr;

const ::PROTOBUF_NAMESPACE_ID::uint32 TableStruct_ripple_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::protocol::TMManifest, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMManifest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::protocol::TMManifest, stobject_),
  0,
  PROTOBUF_FIELD_OFFSET(::protocol::TMManifests, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMManifests, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::protocol::TMManifests, list_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMManifests, history_),
  ~0u,
  0,
  PROTOBUF_FIELD_OFFSET(::protocol::TMClusterNode, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMClusterNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::protocol::TMClusterNode, publickey_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMClusterNode, reporttime_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMClusterNode, nodeload_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMClusterNode, nodename_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMClusterNode, address_),
  0,
  3,
  4,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::protocol::TMLoadSource, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMLoadSource, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::protocol::TMLoadSource, name_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMLoadSource, cost_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMLoadSource, count_),
  0,
  1,
  2,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::protocol::TMCluster, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::protocol::TMCluster, clusternodes_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMCluster, loadsources_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMLink, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMLink, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::protocol::TMLink, nodepubkey_),
  0,
  PROTOBUF_FIELD_OFFSET(::protocol::TMGetPeerShardInfo, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMGetPeerShardInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::protocol::TMGetPeerShardInfo, hops_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMGetPeerShardInfo, lastlink_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMGetPeerShardInfo, peerchain_),
  0,
  1,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::protocol::TMPeerShardInfo, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMPeerShardInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::protocol::TMPeerShardInfo, shardindexes_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMPeerShardInfo, nodepubkey_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMPeerShardInfo, endpoint_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMPeerShardInfo, lastlink_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMPeerShardInfo, peerchain_),
  0,
  1,
  2,
  3,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::protocol::TMPublicKey, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMPublicKey, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::protocol::TMPublicKey, publickey_),
  0,
  PROTOBUF_FIELD_OFFSET(::protocol::TMGetPeerShardInfoV2, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMGetPeerShardInfoV2, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::protocol::TMGetPeerShardInfoV2, peerchain_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMGetPeerShardInfoV2, relays_),
  ~0u,
  0,
  PROTOBUF_FIELD_OFFSET(::protocol::TMPeerShardInfoV2_TMIncomplete, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMPeerShardInfoV2_TMIncomplete, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::protocol::TMPeerShardInfoV2_TMIncomplete, shardindex_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMPeerShardInfoV2_TMIncomplete, state_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMPeerShardInfoV2_TMIncomplete, progress_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::protocol::TMPeerShardInfoV2, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMPeerShardInfoV2, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::protocol::TMPeerShardInfoV2, timestamp_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMPeerShardInfoV2, incomplete_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMPeerShardInfoV2, finalized_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMPeerShardInfoV2, publickey_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMPeerShardInfoV2, signature_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMPeerShardInfoV2, peerchain_),
  3,
  ~0u,
  0,
  1,
  2,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::protocol::TMTransaction, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMTransaction, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::protocol::TMTransaction, rawtransaction_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMTransaction, status_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMTransaction, receivetimestamp_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMTransaction, deferred_),
  0,
  3,
  1,
  2,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::protocol::TMTransactions, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::protocol::TMTransactions, transactions_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMStatusChange, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMStatusChange, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::protocol::TMStatusChange, newstatus_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMStatusChange, newevent_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMStatusChange, ledgerseq_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMStatusChange, ledgerhash_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMStatusChange, ledgerhashprevious_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMStatusChange, networktime_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMStatusChange, firstseq_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMStatusChange, lastseq_),
  6,
  7,
  2,
  0,
  1,
  4,
  3,
  5,
  PROTOBUF_FIELD_OFFSET(::protocol::TMProposeSet, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMProposeSet, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::protocol::TMProposeSet, proposeseq_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMProposeSet, currenttxhash_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMProposeSet, nodepubkey_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMProposeSet, closetime_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMProposeSet, signature_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMProposeSet, previousledger_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMProposeSet, addedtransactions_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMProposeSet, removedtransactions_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMProposeSet, checkedsignature_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMProposeSet, hops_),
  4,
  0,
  1,
  5,
  2,
  3,
  ~0u,
  ~0u,
  6,
  7,
  PROTOBUF_FIELD_OFFSET(::protocol::TMHaveTransactionSet, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMHaveTransactionSet, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::protocol::TMHaveTransactionSet, status_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMHaveTransactionSet, hash_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::protocol::TMValidatorList, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMValidatorList, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::protocol::TMValidatorList, manifest_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMValidatorList, blob_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMValidatorList, signature_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMValidatorList, version_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::protocol::ValidatorBlobInfo, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::ValidatorBlobInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::protocol::ValidatorBlobInfo, manifest_),
  PROTOBUF_FIELD_OFFSET(::protocol::ValidatorBlobInfo, blob_),
  PROTOBUF_FIELD_OFFSET(::protocol::ValidatorBlobInfo, signature_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::protocol::TMValidatorListCollection, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMValidatorListCollection, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::protocol::TMValidatorListCollection, version_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMValidatorListCollection, manifest_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMValidatorListCollection, blobs_),
  1,
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::protocol::TMValidation, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMValidation, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::protocol::TMValidation, validation_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMValidation, checkedsignature_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMValidation, hops_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::protocol::TMEndpoints_TMEndpointv2, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMEndpoints_TMEndpointv2, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::protocol::TMEndpoints_TMEndpointv2, endpoint_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMEndpoints_TMEndpointv2, hops_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::protocol::TMEndpoints, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMEndpoints, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::protocol::TMEndpoints, version_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMEndpoints, endpoints_v2_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::protocol::TMIndexedObject, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMIndexedObject, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::protocol::TMIndexedObject, hash_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMIndexedObject, nodeid_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMIndexedObject, index_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMIndexedObject, data_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMIndexedObject, ledgerseq_),
  0,
  1,
  2,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::protocol::TMGetObjectByHash, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMGetObjectByHash, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::protocol::TMGetObjectByHash, type_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMGetObjectByHash, query_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMGetObjectByHash, seq_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMGetObjectByHash, ledgerhash_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMGetObjectByHash, fat_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMGetObjectByHash, objects_),
  1,
  3,
  2,
  0,
  4,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::protocol::TMLedgerNode, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMLedgerNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::protocol::TMLedgerNode, nodedata_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMLedgerNode, nodeid_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::protocol::TMGetLedger, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMGetLedger, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::protocol::TMGetLedger, itype_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMGetLedger, ltype_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMGetLedger, ledgerhash_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMGetLedger, ledgerseq_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMGetLedger, nodeids_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMGetLedger, requestcookie_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMGetLedger, querytype_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMGetLedger, querydepth_),
  1,
  2,
  0,
  3,
  ~0u,
  5,
  4,
  6,
  PROTOBUF_FIELD_OFFSET(::protocol::TMLedgerData, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMLedgerData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::protocol::TMLedgerData, ledgerhash_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMLedgerData, ledgerseq_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMLedgerData, type_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMLedgerData, nodes_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMLedgerData, requestcookie_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMLedgerData, error_),
  0,
  1,
  2,
  ~0u,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::protocol::TMPing, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMPing, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::protocol::TMPing, type_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMPing, seq_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMPing, pingtime_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMPing, nettime_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::protocol::TMSquelch, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMSquelch, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::protocol::TMSquelch, squelch_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMSquelch, validatorpubkey_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMSquelch, squelchduration_),
  1,
  0,
  2,
  PROTOBUF_FIELD_OFFSET(::protocol::TMProofPathRequest, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMProofPathRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::protocol::TMProofPathRequest, key_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMProofPathRequest, ledgerhash_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMProofPathRequest, type_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::protocol::TMProofPathResponse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMProofPathResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::protocol::TMProofPathResponse, key_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMProofPathResponse, ledgerhash_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMProofPathResponse, type_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMProofPathResponse, ledgerheader_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMProofPathResponse, path_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMProofPathResponse, error_),
  0,
  1,
  3,
  2,
  ~0u,
  4,
  PROTOBUF_FIELD_OFFSET(::protocol::TMReplayDeltaRequest, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMReplayDeltaRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::protocol::TMReplayDeltaRequest, ledgerhash_),
  0,
  PROTOBUF_FIELD_OFFSET(::protocol::TMReplayDeltaResponse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMReplayDeltaResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::protocol::TMReplayDeltaResponse, ledgerhash_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMReplayDeltaResponse, ledgerheader_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMReplayDeltaResponse, transaction_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMReplayDeltaResponse, error_),
  0,
  1,
  ~0u,
  2,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::protocol::TMHaveTransactions, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::protocol::TMHaveTransactions, hashes_),
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 6, sizeof(::protocol::TMManifest)},
  { 7, 14, sizeof(::protocol::TMManifests)},
  { 16, 26, sizeof(::protocol::TMClusterNode)},
  { 31, 39, sizeof(::protocol::TMLoadSource)},
  { 42, -1, sizeof(::protocol::TMCluster)},
  { 49, 55, sizeof(::protocol::TMLink)},
  { 56, 64, sizeof(::protocol::TMGetPeerShardInfo)},
  { 67, 77, sizeof(::protocol::TMPeerShardInfo)},
  { 82, 88, sizeof(::protocol::TMPublicKey)},
  { 89, 96, sizeof(::protocol::TMGetPeerShardInfoV2)},
  { 98, 106, sizeof(::protocol::TMPeerShardInfoV2_TMIncomplete)},
  { 109, 120, sizeof(::protocol::TMPeerShardInfoV2)},
  { 126, 135, sizeof(::protocol::TMTransaction)},
  { 139, -1, sizeof(::protocol::TMTransactions)},
  { 145, 158, sizeof(::protocol::TMStatusChange)},
  { 166, 181, sizeof(::protocol::TMProposeSet)},
  { 191, 198, sizeof(::protocol::TMHaveTransactionSet)},
  { 200, 209, sizeof(::protocol::TMValidatorList)},
  { 213, 221, sizeof(::protocol::ValidatorBlobInfo)},
  { 224, 232, sizeof(::protocol::TMValidatorListCollection)},
  { 235, 243, sizeof(::protocol::TMValidation)},
  { 246, 253, sizeof(::protocol::TMEndpoints_TMEndpointv2)},
  { 255, 262, sizeof(::protocol::TMEndpoints)},
  { 264, 274, sizeof(::protocol::TMIndexedObject)},
  { 279, 290, sizeof(::protocol::TMGetObjectByHash)},
  { 296, 303, sizeof(::protocol::TMLedgerNode)},
  { 305, 318, sizeof(::protocol::TMGetLedger)},
  { 326, 337, sizeof(::protocol::TMLedgerData)},
  { 343, 352, sizeof(::protocol::TMPing)},
  { 356, 364, sizeof(::protocol::TMSquelch)},
  { 367, 375, sizeof(::protocol::TMProofPathRequest)},
  { 378, 389, sizeof(::protocol::TMProofPathResponse)},
  { 395, 401, sizeof(::protocol::TMReplayDeltaRequest)},
  { 402, 411, sizeof(::protocol::TMReplayDeltaResponse)},
  { 415, -1, sizeof(::protocol::TMHaveTransactions)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::protocol::_TMManifest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::protocol::_TMManifests_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::protocol::_TMClusterNode_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::protocol::_TMLoadSource_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::protocol::_TMCluster_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::protocol::_TMLink_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::protocol::_TMGetPeerShardInfo_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::protocol::_TMPeerShardInfo_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::protocol::_TMPublicKey_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::protocol::_TMGetPeerShardInfoV2_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::protocol::_TMPeerShardInfoV2_TMIncomplete_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::protocol::_TMPeerShardInfoV2_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::protocol::_TMTransaction_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::protocol::_TMTransactions_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::protocol::_TMStatusChange_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::protocol::_TMProposeSet_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::protocol::_TMHaveTransactionSet_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::protocol::_TMValidatorList_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::protocol::_ValidatorBlobInfo_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::protocol::_TMValidatorListCollection_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::protocol::_TMValidation_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::protocol::_TMEndpoints_TMEndpointv2_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::protocol::_TMEndpoints_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::protocol::_TMIndexedObject_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::protocol::_TMGetObjectByHash_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::protocol::_TMLedgerNode_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::protocol::_TMGetLedger_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::protocol::_TMLedgerData_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::protocol::_TMPing_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::protocol::_TMSquelch_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::protocol::_TMProofPathRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::protocol::_TMProofPathResponse_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::protocol::_TMReplayDeltaRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::protocol::_TMReplayDeltaResponse_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::protocol::_TMHaveTransactions_default_instance_),
};

const char descriptor_table_protodef_ripple_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\014ripple.proto\022\010protocol\"\036\n\nTMManifest\022\020"
  "\n\010stobject\030\001 \002(\014\"F\n\013TMManifests\022\"\n\004list\030"
  "\001 \003(\0132\024.protocol.TMManifest\022\023\n\007history\030\002"
  " \001(\010B\002\030\001\"k\n\rTMClusterNode\022\021\n\tpublicKey\030\001"
  " \002(\t\022\022\n\nreportTime\030\002 \002(\r\022\020\n\010nodeLoad\030\003 \002"
  "(\r\022\020\n\010nodeName\030\004 \001(\t\022\017\n\007address\030\005 \001(\t\"9\n"
  "\014TMLoadSource\022\014\n\004name\030\001 \002(\t\022\014\n\004cost\030\002 \002("
  "\r\022\r\n\005count\030\003 \001(\r\"g\n\tTMCluster\022-\n\014cluster"
  "Nodes\030\001 \003(\0132\027.protocol.TMClusterNode\022+\n\013"
  "loadSources\030\002 \003(\0132\026.protocol.TMLoadSourc"
  "e\" \n\006TMLink\022\026\n\nnodePubKey\030\001 \002(\014B\002\030\001\"e\n\022T"
  "MGetPeerShardInfo\022\020\n\004hops\030\001 \002(\rB\002\030\001\022\024\n\010l"
  "astLink\030\002 \001(\010B\002\030\001\022\'\n\tpeerChain\030\003 \003(\0132\020.p"
  "rotocol.TMLinkB\002\030\001\"\230\001\n\017TMPeerShardInfo\022\030"
  "\n\014shardIndexes\030\001 \002(\tB\002\030\001\022\026\n\nnodePubKey\030\002"
  " \001(\014B\002\030\001\022\024\n\010endpoint\030\003 \001(\tB\002\030\001\022\024\n\010lastLi"
  "nk\030\004 \001(\010B\002\030\001\022\'\n\tpeerChain\030\005 \003(\0132\020.protoc"
  "ol.TMLinkB\002\030\001\" \n\013TMPublicKey\022\021\n\tpublicKe"
  "y\030\001 \002(\014\"P\n\024TMGetPeerShardInfoV2\022(\n\tpeerC"
  "hain\030\001 \003(\0132\025.protocol.TMPublicKey\022\016\n\006rel"
  "ays\030\002 \002(\r\"\214\002\n\021TMPeerShardInfoV2\022\021\n\ttimes"
  "tamp\030\001 \002(\r\022<\n\nincomplete\030\002 \003(\0132(.protoco"
  "l.TMPeerShardInfoV2.TMIncomplete\022\021\n\tfina"
  "lized\030\003 \001(\t\022\021\n\tpublicKey\030\004 \002(\014\022\021\n\tsignat"
  "ure\030\005 \002(\014\022(\n\tpeerChain\030\006 \003(\0132\025.protocol."
  "TMPublicKey\032C\n\014TMIncomplete\022\022\n\nshardInde"
  "x\030\001 \002(\r\022\r\n\005state\030\002 \002(\r\022\020\n\010progress\030\003 \001(\r"
  "\"\200\001\n\rTMTransaction\022\026\n\016rawTransaction\030\001 \002"
  "(\014\022+\n\006status\030\002 \002(\0162\033.protocol.Transactio"
  "nStatus\022\030\n\020receiveTimestamp\030\003 \001(\004\022\020\n\010def"
  "erred\030\004 \001(\010\"\?\n\016TMTransactions\022-\n\014transac"
  "tions\030\001 \003(\0132\027.protocol.TMTransaction\"\333\001\n"
  "\016TMStatusChange\022\'\n\tnewStatus\030\001 \001(\0162\024.pro"
  "tocol.NodeStatus\022%\n\010newEvent\030\002 \001(\0162\023.pro"
  "tocol.NodeEvent\022\021\n\tledgerSeq\030\003 \001(\r\022\022\n\nle"
  "dgerHash\030\004 \001(\014\022\032\n\022ledgerHashPrevious\030\005 \001"
  "(\014\022\023\n\013networkTime\030\006 \001(\004\022\020\n\010firstSeq\030\007 \001("
  "\r\022\017\n\007lastSeq\030\010 \001(\r\"\363\001\n\014TMProposeSet\022\022\n\np"
  "roposeSeq\030\001 \002(\r\022\025\n\rcurrentTxHash\030\002 \002(\014\022\022"
  "\n\nnodePubKey\030\003 \002(\014\022\021\n\tcloseTime\030\004 \002(\r\022\021\n"
  "\tsignature\030\005 \002(\014\022\026\n\016previousledger\030\006 \002(\014"
  "\022\031\n\021addedTransactions\030\n \003(\014\022\033\n\023removedTr"
  "ansactions\030\013 \003(\014\022\034\n\020checkedSignature\030\007 \001"
  "(\010B\002\030\001\022\020\n\004hops\030\014 \001(\rB\002\030\001\"K\n\024TMHaveTransa"
  "ctionSet\022%\n\006status\030\001 \002(\0162\025.protocol.TxSe"
  "tStatus\022\014\n\004hash\030\002 \002(\014\"U\n\017TMValidatorList"
  "\022\020\n\010manifest\030\001 \002(\014\022\014\n\004blob\030\002 \002(\014\022\021\n\tsign"
  "ature\030\003 \002(\014\022\017\n\007version\030\004 \002(\r\"F\n\021Validato"
  "rBlobInfo\022\020\n\010manifest\030\001 \001(\014\022\014\n\004blob\030\002 \002("
  "\014\022\021\n\tsignature\030\003 \002(\014\"j\n\031TMValidatorListC"
  "ollection\022\017\n\007version\030\001 \002(\r\022\020\n\010manifest\030\002"
  " \002(\014\022*\n\005blobs\030\003 \003(\0132\033.protocol.Validator"
  "BlobInfo\"R\n\014TMValidation\022\022\n\nvalidation\030\001"
  " \002(\014\022\034\n\020checkedSignature\030\002 \001(\010B\002\030\001\022\020\n\004ho"
  "ps\030\003 \001(\rB\002\030\001\"\216\001\n\013TMEndpoints\022\017\n\007version\030"
  "\001 \002(\r\0228\n\014endpoints_v2\030\003 \003(\0132\".protocol.T"
  "MEndpoints.TMEndpointv2\032.\n\014TMEndpointv2\022"
  "\020\n\010endpoint\030\001 \002(\t\022\014\n\004hops\030\002 \002(\rJ\004\010\002\020\003\"_\n"
  "\017TMIndexedObject\022\014\n\004hash\030\001 \001(\014\022\016\n\006nodeID"
  "\030\002 \001(\014\022\r\n\005index\030\003 \001(\014\022\014\n\004data\030\004 \001(\014\022\021\n\tl"
  "edgerSeq\030\005 \001(\r\"\323\002\n\021TMGetObjectByHash\0224\n\004"
  "type\030\001 \002(\0162&.protocol.TMGetObjectByHash."
  "ObjectType\022\r\n\005query\030\002 \002(\010\022\013\n\003seq\030\003 \001(\r\022\022"
  "\n\nledgerHash\030\004 \001(\014\022\013\n\003fat\030\005 \001(\010\022*\n\007objec"
  "ts\030\006 \003(\0132\031.protocol.TMIndexedObject\"\236\001\n\n"
  "ObjectType\022\r\n\totUNKNOWN\020\000\022\014\n\010otLEDGER\020\001\022"
  "\021\n\rotTRANSACTION\020\002\022\026\n\022otTRANSACTION_NODE"
  "\020\003\022\020\n\014otSTATE_NODE\020\004\022\020\n\014otCAS_OBJECT\020\005\022\020"
  "\n\014otFETCH_PACK\020\006\022\022\n\016otTRANSACTIONS\020\007\"0\n\014"
  "TMLedgerNode\022\020\n\010nodedata\030\001 \002(\014\022\016\n\006nodeid"
  "\030\002 \001(\014\"\354\001\n\013TMGetLedger\022)\n\005itype\030\001 \002(\0162\032."
  "protocol.TMLedgerInfoType\022%\n\005ltype\030\002 \001(\016"
  "2\026.protocol.TMLedgerType\022\022\n\nledgerHash\030\003"
  " \001(\014\022\021\n\tledgerSeq\030\004 \001(\r\022\017\n\007nodeIDs\030\005 \003(\014"
  "\022\025\n\rrequestCookie\030\006 \001(\004\022(\n\tqueryType\030\007 \001"
  "(\0162\025.protocol.TMQueryType\022\022\n\nqueryDepth\030"
  "\010 \001(\r\"\304\001\n\014TMLedgerData\022\022\n\nledgerHash\030\001 \002"
  "(\014\022\021\n\tledgerSeq\030\002 \002(\r\022(\n\004type\030\003 \002(\0162\032.pr"
  "otocol.TMLedgerInfoType\022%\n\005nodes\030\004 \003(\0132\026"
  ".protocol.TMLedgerNode\022\025\n\rrequestCookie\030"
  "\005 \001(\r\022%\n\005error\030\006 \001(\0162\026.protocol.TMReplyE"
  "rror\"\205\001\n\006TMPing\022\'\n\004type\030\001 \002(\0162\031.protocol"
  ".TMPing.pingType\022\013\n\003seq\030\002 \001(\r\022\020\n\010pingTim"
  "e\030\003 \001(\004\022\017\n\007netTime\030\004 \001(\004\"\"\n\010pingType\022\n\n\006"
  "ptPING\020\000\022\n\n\006ptPONG\020\001\"N\n\tTMSquelch\022\017\n\007squ"
  "elch\030\001 \002(\010\022\027\n\017validatorPubKey\030\002 \002(\014\022\027\n\017s"
  "quelchDuration\030\003 \001(\r\"^\n\022TMProofPathReque"
  "st\022\013\n\003key\030\001 \002(\014\022\022\n\nledgerHash\030\002 \002(\014\022\'\n\004t"
  "ype\030\003 \002(\0162\031.protocol.TMLedgerMapType\"\252\001\n"
  "\023TMProofPathResponse\022\013\n\003key\030\001 \002(\014\022\022\n\nled"
  "gerHash\030\002 \002(\014\022\'\n\004type\030\003 \002(\0162\031.protocol.T"
  "MLedgerMapType\022\024\n\014ledgerHeader\030\004 \001(\014\022\014\n\004"
  "path\030\005 \003(\014\022%\n\005error\030\006 \001(\0162\026.protocol.TMR"
  "eplyError\"*\n\024TMReplayDeltaRequest\022\022\n\nled"
  "gerHash\030\001 \002(\014\"}\n\025TMReplayDeltaResponse\022\022"
  "\n\nledgerHash\030\001 \002(\014\022\024\n\014ledgerHeader\030\002 \001(\014"
  "\022\023\n\013transaction\030\003 \003(\014\022%\n\005error\030\004 \001(\0162\026.p"
  "rotocol.TMReplyError\"$\n\022TMHaveTransactio"
  "ns\022\016\n\006hashes\030\001 \003(\014*\312\004\n\013MessageType\022\017\n\013mt"
  "MANIFESTS\020\002\022\n\n\006mtPING\020\003\022\r\n\tmtCLUSTER\020\005\022\017"
  "\n\013mtENDPOINTS\020\017\022\021\n\rmtTRANSACTION\020\036\022\020\n\014mt"
  "GET_LEDGER\020\037\022\021\n\rmtLEDGER_DATA\020 \022\024\n\020mtPRO"
  "POSE_LEDGER\020!\022\023\n\017mtSTATUS_CHANGE\020\"\022\016\n\nmt"
  "HAVE_SET\020#\022\020\n\014mtVALIDATION\020)\022\021\n\rmtGET_OB"
  "JECTS\020*\022\024\n\020mtGET_SHARD_INFO\0202\022\020\n\014mtSHARD"
  "_INFO\0203\022\031\n\025mtGET_PEER_SHARD_INFO\0204\022\025\n\021mt"
  "PEER_SHARD_INFO\0205\022\023\n\017mtVALIDATORLIST\0206\022\r"
  "\n\tmtSQUELCH\0207\022\035\n\031mtVALIDATORLISTCOLLECTI"
  "ON\0208\022\024\n\020mtPROOF_PATH_REQ\0209\022\031\n\025mtPROOF_PA"
  "TH_RESPONSE\020:\022\026\n\022mtREPLAY_DELTA_REQ\020;\022\033\n"
  "\027mtREPLAY_DELTA_RESPONSE\020<\022\034\n\030mtGET_PEER"
  "_SHARD_INFO_V2\020=\022\030\n\024mtPEER_SHARD_INFO_V2"
  "\020>\022\027\n\023mtHAVE_TRANSACTIONS\020\?\022\022\n\016mtTRANSAC"
  "TIONS\020@*\241\001\n\021TransactionStatus\022\t\n\005tsNEW\020\001"
  "\022\r\n\ttsCURRENT\020\002\022\016\n\ntsCOMMITED\020\003\022\025\n\021tsREJ"
  "ECT_CONFLICT\020\004\022\024\n\020tsREJECT_INVALID\020\005\022\022\n\016"
  "tsREJECT_FUNDS\020\006\022\016\n\ntsHELD_SEQ\020\007\022\021\n\rtsHE"
  "LD_LEDGER\020\010*c\n\nNodeStatus\022\020\n\014nsCONNECTIN"
  "G\020\001\022\017\n\013nsCONNECTED\020\002\022\020\n\014nsMONITORING\020\003\022\020"
  "\n\014nsVALIDATING\020\004\022\016\n\nnsSHUTTING\020\005*`\n\tNode"
  "Event\022\024\n\020neCLOSING_LEDGER\020\001\022\025\n\021neACCEPTE"
  "D_LEDGER\020\002\022\025\n\021neSWITCHED_LEDGER\020\003\022\017\n\013neL"
  "OST_SYNC\020\004*4\n\013TxSetStatus\022\n\n\006tsHAVE\020\001\022\r\n"
  "\ttsCAN_GET\020\002\022\n\n\006tsNEED\020\003*P\n\020TMLedgerInfo"
  "Type\022\n\n\006liBASE\020\000\022\r\n\tliTX_NODE\020\001\022\r\n\tliAS_"
  "NODE\020\002\022\022\n\016liTS_CANDIDATE\020\003*;\n\014TMLedgerTy"
  "pe\022\016\n\nltACCEPTED\020\000\022\r\n\tltCURRENT\020\001\022\014\n\010ltC"
  "LOSED\020\002*\035\n\013TMQueryType\022\016\n\nqtINDIRECT\020\000*A"
  "\n\014TMReplyError\022\017\n\013reNO_LEDGER\020\001\022\r\n\treNO_"
  "NODE\020\002\022\021\n\rreBAD_REQUEST\020\003*9\n\017TMLedgerMap"
  "Type\022\021\n\rlmTRANASCTION\020\001\022\023\n\017lmACCOUNT_STA"
  "TE\020\002"
  ;
static const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable*const descriptor_table_ripple_2eproto_deps[1] = {
};
static ::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase*const descriptor_table_ripple_2eproto_sccs[35] = {
  &scc_info_TMCluster_ripple_2eproto.base,
  &scc_info_TMClusterNode_ripple_2eproto.base,
  &scc_info_TMEndpoints_ripple_2eproto.base,
  &scc_info_TMEndpoints_TMEndpointv2_ripple_2eproto.base,
  &scc_info_TMGetLedger_ripple_2eproto.base,
  &scc_info_TMGetObjectByHash_ripple_2eproto.base,
  &scc_info_TMGetPeerShardInfo_ripple_2eproto.base,
  &scc_info_TMGetPeerShardInfoV2_ripple_2eproto.base,
  &scc_info_TMHaveTransactionSet_ripple_2eproto.base,
  &scc_info_TMHaveTransactions_ripple_2eproto.base,
  &scc_info_TMIndexedObject_ripple_2eproto.base,
  &scc_info_TMLedgerData_ripple_2eproto.base,
  &scc_info_TMLedgerNode_ripple_2eproto.base,
  &scc_info_TMLink_ripple_2eproto.base,
  &scc_info_TMLoadSource_ripple_2eproto.base,
  &scc_info_TMManifest_ripple_2eproto.base,
  &scc_info_TMManifests_ripple_2eproto.base,
  &scc_info_TMPeerShardInfo_ripple_2eproto.base,
  &scc_info_TMPeerShardInfoV2_ripple_2eproto.base,
  &scc_info_TMPeerShardInfoV2_TMIncomplete_ripple_2eproto.base,
  &scc_info_TMPing_ripple_2eproto.base,
  &scc_info_TMProofPathRequest_ripple_2eproto.base,
  &scc_info_TMProofPathResponse_ripple_2eproto.base,
  &scc_info_TMProposeSet_ripple_2eproto.base,
  &scc_info_TMPublicKey_ripple_2eproto.base,
  &scc_info_TMReplayDeltaRequest_ripple_2eproto.base,
  &scc_info_TMReplayDeltaResponse_ripple_2eproto.base,
  &scc_info_TMSquelch_ripple_2eproto.base,
  &scc_info_TMStatusChange_ripple_2eproto.base,
  &scc_info_TMTransaction_ripple_2eproto.base,
  &scc_info_TMTransactions_ripple_2eproto.base,
  &scc_info_TMValidation_ripple_2eproto.base,
  &scc_info_TMValidatorList_ripple_2eproto.base,
  &scc_info_TMValidatorListCollection_ripple_2eproto.base,
  &scc_info_ValidatorBlobInfo_ripple_2eproto.base,
};
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_ripple_2eproto_once;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_ripple_2eproto = {
  false, false, descriptor_table_protodef_ripple_2eproto, "ripple.proto", 5244,
  &descriptor_table_ripple_2eproto_once, descriptor_table_ripple_2eproto_sccs, descriptor_table_ripple_2eproto_deps, 35, 0,
  schemas, file_default_instances, TableStruct_ripple_2eproto::offsets,
  file_level_metadata_ripple_2eproto, 35, file_level_enum_descriptors_ripple_2eproto, file_level_service_descriptors_ripple_2eproto,
};

// Force running AddDescriptors() at dynamic initialization time.
static bool dynamic_init_dummy_ripple_2eproto = (static_cast<void>(::PROTOBUF_NAMESPACE_ID::internal::AddDescriptors(&descriptor_table_ripple_2eproto)), true);
namespace protocol {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TMGetObjectByHash_ObjectType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_ripple_2eproto);
  return file_level_enum_descriptors_ripple_2eproto[0];
}
bool TMGetObjectByHash_ObjectType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr TMGetObjectByHash_ObjectType TMGetObjectByHash::otUNKNOWN;
constexpr TMGetObjectByHash_ObjectType TMGetObjectByHash::otLEDGER;
constexpr TMGetObjectByHash_ObjectType TMGetObjectByHash::otTRANSACTION;
constexpr TMGetObjectByHash_ObjectType TMGetObjectByHash::otTRANSACTION_NODE;
constexpr TMGetObjectByHash_ObjectType TMGetObjectByHash::otSTATE_NODE;
constexpr TMGetObjectByHash_ObjectType TMGetObjectByHash::otCAS_OBJECT;
constexpr TMGetObjectByHash_ObjectType TMGetObjectByHash::otFETCH_PACK;
constexpr TMGetObjectByHash_ObjectType TMGetObjectByHash::otTRANSACTIONS;
constexpr TMGetObjectByHash_ObjectType TMGetObjectByHash::ObjectType_MIN;
constexpr TMGetObjectByHash_ObjectType TMGetObjectByHash::ObjectType_MAX;
constexpr int TMGetObjectByHash::ObjectType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TMPing_pingType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_ripple_2eproto);
  return file_level_enum_descriptors_ripple_2eproto[1];
}
bool TMPing_pingType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr TMPing_pingType TMPing::ptPING;
constexpr TMPing_pingType TMPing::ptPONG;
constexpr TMPing_pingType TMPing::pingType_MIN;
constexpr TMPing_pingType TMPing::pingType_MAX;
constexpr int TMPing::pingType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MessageType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_ripple_2eproto);
  return file_level_enum_descriptors_ripple_2eproto[2];
}
bool MessageType_IsValid(int value) {
  switch (value) {
    case 2:
    case 3:
    case 5:
    case 15:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
    case 35:
    case 41:
    case 42:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 56:
    case 57:
    case 58:
    case 59:
    case 60:
    case 61:
    case 62:
    case 63:
    case 64:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TransactionStatus_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_ripple_2eproto);
  return file_level_enum_descriptors_ripple_2eproto[3];
}
bool TransactionStatus_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* NodeStatus_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_ripple_2eproto);
  return file_level_enum_descriptors_ripple_2eproto[4];
}
bool NodeStatus_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* NodeEvent_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_ripple_2eproto);
  return file_level_enum_descriptors_ripple_2eproto[5];
}
bool NodeEvent_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TxSetStatus_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_ripple_2eproto);
  return file_level_enum_descriptors_ripple_2eproto[6];
}
bool TxSetStatus_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TMLedgerInfoType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_ripple_2eproto);
  return file_level_enum_descriptors_ripple_2eproto[7];
}
bool TMLedgerInfoType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TMLedgerType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_ripple_2eproto);
  return file_level_enum_descriptors_ripple_2eproto[8];
}
bool TMLedgerType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TMQueryType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_ripple_2eproto);
  return file_level_enum_descriptors_ripple_2eproto[9];
}
bool TMQueryType_IsValid(int value) {
  switch (value) {
    case 0:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TMReplyError_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_ripple_2eproto);
  return file_level_enum_descriptors_ripple_2eproto[10];
}
bool TMReplyError_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TMLedgerMapType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_ripple_2eproto);
  return file_level_enum_descriptors_ripple_2eproto[11];
}
bool TMLedgerMapType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}


// ===================================================================

void TMManifest::InitAsDefaultInstance() {
}
class TMManifest::_Internal {
 public:
  using HasBits = decltype(std::declval<TMManifest>()._has_bits_);
  static void set_has_stobject(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

TMManifest::TMManifest(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:protocol.TMManifest)
}
TMManifest::TMManifest(const TMManifest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  stobject_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_stobject()) {
    stobject_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_stobject(),
      GetArena());
  }
  // @@protoc_insertion_point(copy_constructor:protocol.TMManifest)
}

void TMManifest::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_TMManifest_ripple_2eproto.base);
  stobject_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

TMManifest::~TMManifest() {
  // @@protoc_insertion_point(destructor:protocol.TMManifest)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void TMManifest::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  stobject_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void TMManifest::ArenaDtor(void* object) {
  TMManifest* _this = reinterpret_cast< TMManifest* >(object);
  (void)_this;
}
void TMManifest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TMManifest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TMManifest& TMManifest::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TMManifest_ripple_2eproto.base);
  return *internal_default_instance();
}


void TMManifest::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMManifest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    stobject_.ClearNonDefaultToEmpty();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TMManifest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required bytes stobject = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_stobject();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* TMManifest::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMManifest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required bytes stobject = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_stobject(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMManifest)
  return target;
}

size_t TMManifest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMManifest)
  size_t total_size = 0;

  // required bytes stobject = 1;
  if (_internal_has_stobject()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_stobject());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TMManifest::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protocol.TMManifest)
  GOOGLE_DCHECK_NE(&from, this);
  const TMManifest* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<TMManifest>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protocol.TMManifest)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protocol.TMManifest)
    MergeFrom(*source);
  }
}

void TMManifest::MergeFrom(const TMManifest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMManifest)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_stobject()) {
    _internal_set_stobject(from._internal_stobject());
  }
}

void TMManifest::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protocol.TMManifest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMManifest::CopyFrom(const TMManifest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMManifest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMManifest::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void TMManifest::InternalSwap(TMManifest* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  stobject_.Swap(&other->stobject_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}

::PROTOBUF_NAMESPACE_ID::Metadata TMManifest::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void TMManifests::InitAsDefaultInstance() {
}
class TMManifests::_Internal {
 public:
  using HasBits = decltype(std::declval<TMManifests>()._has_bits_);
  static void set_has_history(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

TMManifests::TMManifests(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  list_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:protocol.TMManifests)
}
TMManifests::TMManifests(const TMManifests& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      list_(from.list_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  history_ = from.history_;
  // @@protoc_insertion_point(copy_constructor:protocol.TMManifests)
}

void TMManifests::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_TMManifests_ripple_2eproto.base);
  history_ = false;
}

TMManifests::~TMManifests() {
  // @@protoc_insertion_point(destructor:protocol.TMManifests)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void TMManifests::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void TMManifests::ArenaDtor(void* object) {
  TMManifests* _this = reinterpret_cast< TMManifests* >(object);
  (void)_this;
}
void TMManifests::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TMManifests::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TMManifests& TMManifests::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TMManifests_ripple_2eproto.base);
  return *internal_default_instance();
}


void TMManifests::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMManifests)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  list_.Clear();
  history_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TMManifests::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated .protocol.TMManifest list = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_list(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else goto handle_unusual;
        continue;
      // optional bool history = 2 [deprecated = true];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_history(&has_bits);
          history_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* TMManifests::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMManifests)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .protocol.TMManifest list = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_list_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_list(i), target, stream);
  }

  cached_has_bits = _has_bits_[0];
  // optional bool history = 2 [deprecated = true];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->_internal_history(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMManifests)
  return target;
}

size_t TMManifests::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMManifests)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .protocol.TMManifest list = 1;
  total_size += 1UL * this->_internal_list_size();
  for (const auto& msg : this->list_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional bool history = 2 [deprecated = true];
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TMManifests::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protocol.TMManifests)
  GOOGLE_DCHECK_NE(&from, this);
  const TMManifests* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<TMManifests>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protocol.TMManifests)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protocol.TMManifests)
    MergeFrom(*source);
  }
}

void TMManifests::MergeFrom(const TMManifests& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMManifests)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  list_.MergeFrom(from.list_);
  if (from._internal_has_history()) {
    _internal_set_history(from._internal_history());
  }
}

void TMManifests::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protocol.TMManifests)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMManifests::CopyFrom(const TMManifests& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMManifests)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMManifests::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(list_)) return false;
  return true;
}

void TMManifests::InternalSwap(TMManifests* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  list_.InternalSwap(&other->list_);
  swap(history_, other->history_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TMManifests::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void TMClusterNode::InitAsDefaultInstance() {
}
class TMClusterNode::_Internal {
 public:
  using HasBits = decltype(std::declval<TMClusterNode>()._has_bits_);
  static void set_has_publickey(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_reporttime(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_nodeload(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_nodename(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_address(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000019) ^ 0x00000019) != 0;
  }
};

TMClusterNode::TMClusterNode(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:protocol.TMClusterNode)
}
TMClusterNode::TMClusterNode(const TMClusterNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  publickey_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_publickey()) {
    publickey_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_publickey(),
      GetArena());
  }
  nodename_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_nodename()) {
    nodename_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_nodename(),
      GetArena());
  }
  address_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_address()) {
    address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_address(),
      GetArena());
  }
  ::memcpy(&reporttime_, &from.reporttime_,
    static_cast<size_t>(reinterpret_cast<char*>(&nodeload_) -
    reinterpret_cast<char*>(&reporttime_)) + sizeof(nodeload_));
  // @@protoc_insertion_point(copy_constructor:protocol.TMClusterNode)
}

void TMClusterNode::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_TMClusterNode_ripple_2eproto.base);
  publickey_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  nodename_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  address_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&reporttime_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&nodeload_) -
      reinterpret_cast<char*>(&reporttime_)) + sizeof(nodeload_));
}

TMClusterNode::~TMClusterNode() {
  // @@protoc_insertion_point(destructor:protocol.TMClusterNode)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void TMClusterNode::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  publickey_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  nodename_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  address_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void TMClusterNode::ArenaDtor(void* object) {
  TMClusterNode* _this = reinterpret_cast< TMClusterNode* >(object);
  (void)_this;
}
void TMClusterNode::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TMClusterNode::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TMClusterNode& TMClusterNode::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TMClusterNode_ripple_2eproto.base);
  return *internal_default_instance();
}


void TMClusterNode::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMClusterNode)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      publickey_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      nodename_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      address_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x00000018u) {
    ::memset(&reporttime_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&nodeload_) -
        reinterpret_cast<char*>(&reporttime_)) + sizeof(nodeload_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TMClusterNode::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required string publicKey = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_publickey();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "protocol.TMClusterNode.publicKey");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required uint32 reportTime = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_reporttime(&has_bits);
          reporttime_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required uint32 nodeLoad = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_nodeload(&has_bits);
          nodeload_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string nodeName = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          auto str = _internal_mutable_nodename();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "protocol.TMClusterNode.nodeName");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string address = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          auto str = _internal_mutable_address();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "protocol.TMClusterNode.address");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* TMClusterNode::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMClusterNode)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string publicKey = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_publickey().data(), static_cast<int>(this->_internal_publickey().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "protocol.TMClusterNode.publicKey");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_publickey(), target);
  }

  // required uint32 reportTime = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_reporttime(), target);
  }

  // required uint32 nodeLoad = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_nodeload(), target);
  }

  // optional string nodeName = 4;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_nodename().data(), static_cast<int>(this->_internal_nodename().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "protocol.TMClusterNode.nodeName");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_nodename(), target);
  }

  // optional string address = 5;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_address().data(), static_cast<int>(this->_internal_address().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "protocol.TMClusterNode.address");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_address(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMClusterNode)
  return target;
}

size_t TMClusterNode::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:protocol.TMClusterNode)
  size_t total_size = 0;

  if (_internal_has_publickey()) {
    // required string publicKey = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_publickey());
  }

  if (_internal_has_reporttime()) {
    // required uint32 reportTime = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_reporttime());
  }

  if (_internal_has_nodeload()) {
    // required uint32 nodeLoad = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_nodeload());
  }

  return total_size;
}
size_t TMClusterNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMClusterNode)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000019) ^ 0x00000019) == 0) {  // All required fields are present.
    // required string publicKey = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_publickey());

    // required uint32 reportTime = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_reporttime());

    // required uint32 nodeLoad = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_nodeload());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000006u) {
    // optional string nodeName = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_nodename());
    }

    // optional string address = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_address());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TMClusterNode::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protocol.TMClusterNode)
  GOOGLE_DCHECK_NE(&from, this);
  const TMClusterNode* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<TMClusterNode>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protocol.TMClusterNode)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protocol.TMClusterNode)
    MergeFrom(*source);
  }
}

void TMClusterNode::MergeFrom(const TMClusterNode& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMClusterNode)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_publickey(from._internal_publickey());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_nodename(from._internal_nodename());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_address(from._internal_address());
    }
    if (cached_has_bits & 0x00000008u) {
      reporttime_ = from.reporttime_;
    }
    if (cached_has_bits & 0x00000010u) {
      nodeload_ = from.nodeload_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void TMClusterNode::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protocol.TMClusterNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMClusterNode::CopyFrom(const TMClusterNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMClusterNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMClusterNode::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void TMClusterNode::InternalSwap(TMClusterNode* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  publickey_.Swap(&other->publickey_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  nodename_.Swap(&other->nodename_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  address_.Swap(&other->address_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TMClusterNode, nodeload_)
      + sizeof(TMClusterNode::nodeload_)
      - PROTOBUF_FIELD_OFFSET(TMClusterNode, reporttime_)>(
          reinterpret_cast<char*>(&reporttime_),
          reinterpret_cast<char*>(&other->reporttime_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TMClusterNode::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void TMLoadSource::InitAsDefaultInstance() {
}
class TMLoadSource::_Internal {
 public:
  using HasBits = decltype(std::declval<TMLoadSource>()._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_cost(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_count(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

TMLoadSource::TMLoadSource(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:protocol.TMLoadSource)
}
TMLoadSource::TMLoadSource(const TMLoadSource& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_name()) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_name(),
      GetArena());
  }
  ::memcpy(&cost_, &from.cost_,
    static_cast<size_t>(reinterpret_cast<char*>(&count_) -
    reinterpret_cast<char*>(&cost_)) + sizeof(count_));
  // @@protoc_insertion_point(copy_constructor:protocol.TMLoadSource)
}

void TMLoadSource::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_TMLoadSource_ripple_2eproto.base);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&cost_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&count_) -
      reinterpret_cast<char*>(&cost_)) + sizeof(count_));
}

TMLoadSource::~TMLoadSource() {
  // @@protoc_insertion_point(destructor:protocol.TMLoadSource)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void TMLoadSource::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void TMLoadSource::ArenaDtor(void* object) {
  TMLoadSource* _this = reinterpret_cast< TMLoadSource* >(object);
  (void)_this;
}
void TMLoadSource::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TMLoadSource::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TMLoadSource& TMLoadSource::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TMLoadSource_ripple_2eproto.base);
  return *internal_default_instance();
}


void TMLoadSource::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMLoadSource)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    name_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&cost_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&count_) -
        reinterpret_cast<char*>(&cost_)) + sizeof(count_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TMLoadSource::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "protocol.TMLoadSource.name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required uint32 cost = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_cost(&has_bits);
          cost_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 count = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_count(&has_bits);
          count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* TMLoadSource::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMLoadSource)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "protocol.TMLoadSource.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // required uint32 cost = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_cost(), target);
  }

  // optional uint32 count = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_count(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMLoadSource)
  return target;
}

size_t TMLoadSource::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:protocol.TMLoadSource)
  size_t total_size = 0;

  if (_internal_has_name()) {
    // required string name = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  if (_internal_has_cost()) {
    // required uint32 cost = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_cost());
  }

  return total_size;
}
size_t TMLoadSource::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMLoadSource)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required string name = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());

    // required uint32 cost = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_cost());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint32 count = 3;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000004u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_count());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TMLoadSource::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protocol.TMLoadSource)
  GOOGLE_DCHECK_NE(&from, this);
  const TMLoadSource* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<TMLoadSource>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protocol.TMLoadSource)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protocol.TMLoadSource)
    MergeFrom(*source);
  }
}

void TMLoadSource::MergeFrom(const TMLoadSource& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMLoadSource)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      cost_ = from.cost_;
    }
    if (cached_has_bits & 0x00000004u) {
      count_ = from.count_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void TMLoadSource::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protocol.TMLoadSource)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMLoadSource::CopyFrom(const TMLoadSource& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMLoadSource)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMLoadSource::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void TMLoadSource::InternalSwap(TMLoadSource* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  name_.Swap(&other->name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TMLoadSource, count_)
      + sizeof(TMLoadSource::count_)
      - PROTOBUF_FIELD_OFFSET(TMLoadSource, cost_)>(
          reinterpret_cast<char*>(&cost_),
          reinterpret_cast<char*>(&other->cost_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TMLoadSource::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void TMCluster::InitAsDefaultInstance() {
}
class TMCluster::_Internal {
 public:
};

TMCluster::TMCluster(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  clusternodes_(arena),
  loadsources_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:protocol.TMCluster)
}
TMCluster::TMCluster(const TMCluster& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      clusternodes_(from.clusternodes_),
      loadsources_(from.loadsources_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protocol.TMCluster)
}

void TMCluster::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_TMCluster_ripple_2eproto.base);
}

TMCluster::~TMCluster() {
  // @@protoc_insertion_point(destructor:protocol.TMCluster)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void TMCluster::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void TMCluster::ArenaDtor(void* object) {
  TMCluster* _this = reinterpret_cast< TMCluster* >(object);
  (void)_this;
}
void TMCluster::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TMCluster::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TMCluster& TMCluster::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TMCluster_ripple_2eproto.base);
  return *internal_default_instance();
}


void TMCluster::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMCluster)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clusternodes_.Clear();
  loadsources_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TMCluster::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated .protocol.TMClusterNode clusterNodes = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_clusternodes(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else goto handle_unusual;
        continue;
      // repeated .protocol.TMLoadSource loadSources = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_loadsources(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* TMCluster::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMCluster)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .protocol.TMClusterNode clusterNodes = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_clusternodes_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_clusternodes(i), target, stream);
  }

  // repeated .protocol.TMLoadSource loadSources = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_loadsources_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, this->_internal_loadsources(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMCluster)
  return target;
}

size_t TMCluster::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMCluster)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .protocol.TMClusterNode clusterNodes = 1;
  total_size += 1UL * this->_internal_clusternodes_size();
  for (const auto& msg : this->clusternodes_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .protocol.TMLoadSource loadSources = 2;
  total_size += 1UL * this->_internal_loadsources_size();
  for (const auto& msg : this->loadsources_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TMCluster::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protocol.TMCluster)
  GOOGLE_DCHECK_NE(&from, this);
  const TMCluster* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<TMCluster>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protocol.TMCluster)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protocol.TMCluster)
    MergeFrom(*source);
  }
}

void TMCluster::MergeFrom(const TMCluster& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMCluster)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  clusternodes_.MergeFrom(from.clusternodes_);
  loadsources_.MergeFrom(from.loadsources_);
}

void TMCluster::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protocol.TMCluster)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMCluster::CopyFrom(const TMCluster& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMCluster)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMCluster::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(clusternodes_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(loadsources_)) return false;
  return true;
}

void TMCluster::InternalSwap(TMCluster* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  clusternodes_.InternalSwap(&other->clusternodes_);
  loadsources_.InternalSwap(&other->loadsources_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TMCluster::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void TMLink::InitAsDefaultInstance() {
}
class TMLink::_Internal {
 public:
  using HasBits = decltype(std::declval<TMLink>()._has_bits_);
  static void set_has_nodepubkey(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

TMLink::TMLink(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:protocol.TMLink)
}
TMLink::TMLink(const TMLink& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  nodepubkey_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_nodepubkey()) {
    nodepubkey_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_nodepubkey(),
      GetArena());
  }
  // @@protoc_insertion_point(copy_constructor:protocol.TMLink)
}

void TMLink::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_TMLink_ripple_2eproto.base);
  nodepubkey_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

TMLink::~TMLink() {
  // @@protoc_insertion_point(destructor:protocol.TMLink)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void TMLink::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  nodepubkey_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void TMLink::ArenaDtor(void* object) {
  TMLink* _this = reinterpret_cast< TMLink* >(object);
  (void)_this;
}
void TMLink::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TMLink::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TMLink& TMLink::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TMLink_ripple_2eproto.base);
  return *internal_default_instance();
}


void TMLink::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMLink)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    nodepubkey_.ClearNonDefaultToEmpty();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TMLink::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required bytes nodePubKey = 1 [deprecated = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_nodepubkey();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* TMLink::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMLink)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required bytes nodePubKey = 1 [deprecated = true];
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_nodepubkey(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMLink)
  return target;
}

size_t TMLink::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMLink)
  size_t total_size = 0;

  // required bytes nodePubKey = 1 [deprecated = true];
  if (_internal_has_nodepubkey()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_nodepubkey());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TMLink::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protocol.TMLink)
  GOOGLE_DCHECK_NE(&from, this);
  const TMLink* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<TMLink>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protocol.TMLink)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protocol.TMLink)
    MergeFrom(*source);
  }
}

void TMLink::MergeFrom(const TMLink& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMLink)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_nodepubkey()) {
    _internal_set_nodepubkey(from._internal_nodepubkey());
  }
}

void TMLink::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protocol.TMLink)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMLink::CopyFrom(const TMLink& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMLink)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMLink::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void TMLink::InternalSwap(TMLink* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  nodepubkey_.Swap(&other->nodepubkey_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}

::PROTOBUF_NAMESPACE_ID::Metadata TMLink::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void TMGetPeerShardInfo::InitAsDefaultInstance() {
}
class TMGetPeerShardInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<TMGetPeerShardInfo>()._has_bits_);
  static void set_has_hops(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_lastlink(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

TMGetPeerShardInfo::TMGetPeerShardInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  peerchain_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:protocol.TMGetPeerShardInfo)
}
TMGetPeerShardInfo::TMGetPeerShardInfo(const TMGetPeerShardInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      peerchain_(from.peerchain_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&hops_, &from.hops_,
    static_cast<size_t>(reinterpret_cast<char*>(&lastlink_) -
    reinterpret_cast<char*>(&hops_)) + sizeof(lastlink_));
  // @@protoc_insertion_point(copy_constructor:protocol.TMGetPeerShardInfo)
}

void TMGetPeerShardInfo::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_TMGetPeerShardInfo_ripple_2eproto.base);
  ::memset(&hops_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&lastlink_) -
      reinterpret_cast<char*>(&hops_)) + sizeof(lastlink_));
}

TMGetPeerShardInfo::~TMGetPeerShardInfo() {
  // @@protoc_insertion_point(destructor:protocol.TMGetPeerShardInfo)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void TMGetPeerShardInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void TMGetPeerShardInfo::ArenaDtor(void* object) {
  TMGetPeerShardInfo* _this = reinterpret_cast< TMGetPeerShardInfo* >(object);
  (void)_this;
}
void TMGetPeerShardInfo::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TMGetPeerShardInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TMGetPeerShardInfo& TMGetPeerShardInfo::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TMGetPeerShardInfo_ripple_2eproto.base);
  return *internal_default_instance();
}


void TMGetPeerShardInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMGetPeerShardInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  peerchain_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&hops_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&lastlink_) -
        reinterpret_cast<char*>(&hops_)) + sizeof(lastlink_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TMGetPeerShardInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required uint32 hops = 1 [deprecated = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_hops(&has_bits);
          hops_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool lastLink = 2 [deprecated = true];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_lastlink(&has_bits);
          lastlink_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .protocol.TMLink peerChain = 3 [deprecated = true];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_peerchain(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* TMGetPeerShardInfo::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMGetPeerShardInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 hops = 1 [deprecated = true];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_hops(), target);
  }

  // optional bool lastLink = 2 [deprecated = true];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->_internal_lastlink(), target);
  }

  // repeated .protocol.TMLink peerChain = 3 [deprecated = true];
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_peerchain_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, this->_internal_peerchain(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMGetPeerShardInfo)
  return target;
}

size_t TMGetPeerShardInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMGetPeerShardInfo)
  size_t total_size = 0;

  // required uint32 hops = 1 [deprecated = true];
  if (_internal_has_hops()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_hops());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .protocol.TMLink peerChain = 3 [deprecated = true];
  total_size += 1UL * this->_internal_peerchain_size();
  for (const auto& msg : this->peerchain_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional bool lastLink = 2 [deprecated = true];
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000002u) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TMGetPeerShardInfo::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protocol.TMGetPeerShardInfo)
  GOOGLE_DCHECK_NE(&from, this);
  const TMGetPeerShardInfo* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<TMGetPeerShardInfo>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protocol.TMGetPeerShardInfo)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protocol.TMGetPeerShardInfo)
    MergeFrom(*source);
  }
}

void TMGetPeerShardInfo::MergeFrom(const TMGetPeerShardInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMGetPeerShardInfo)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  peerchain_.MergeFrom(from.peerchain_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      hops_ = from.hops_;
    }
    if (cached_has_bits & 0x00000002u) {
      lastlink_ = from.lastlink_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void TMGetPeerShardInfo::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protocol.TMGetPeerShardInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMGetPeerShardInfo::CopyFrom(const TMGetPeerShardInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMGetPeerShardInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMGetPeerShardInfo::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(peerchain_)) return false;
  return true;
}

void TMGetPeerShardInfo::InternalSwap(TMGetPeerShardInfo* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  peerchain_.InternalSwap(&other->peerchain_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TMGetPeerShardInfo, lastlink_)
      + sizeof(TMGetPeerShardInfo::lastlink_)
      - PROTOBUF_FIELD_OFFSET(TMGetPeerShardInfo, hops_)>(
          reinterpret_cast<char*>(&hops_),
          reinterpret_cast<char*>(&other->hops_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TMGetPeerShardInfo::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void TMPeerShardInfo::InitAsDefaultInstance() {
}
class TMPeerShardInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<TMPeerShardInfo>()._has_bits_);
  static void set_has_shardindexes(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_nodepubkey(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_endpoint(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_lastlink(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

TMPeerShardInfo::TMPeerShardInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  peerchain_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:protocol.TMPeerShardInfo)
}
TMPeerShardInfo::TMPeerShardInfo(const TMPeerShardInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      peerchain_(from.peerchain_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  shardindexes_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_shardindexes()) {
    shardindexes_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_shardindexes(),
      GetArena());
  }
  nodepubkey_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_nodepubkey()) {
    nodepubkey_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_nodepubkey(),
      GetArena());
  }
  endpoint_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_endpoint()) {
    endpoint_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_endpoint(),
      GetArena());
  }
  lastlink_ = from.lastlink_;
  // @@protoc_insertion_point(copy_constructor:protocol.TMPeerShardInfo)
}

void TMPeerShardInfo::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_TMPeerShardInfo_ripple_2eproto.base);
  shardindexes_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  nodepubkey_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  endpoint_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  lastlink_ = false;
}

TMPeerShardInfo::~TMPeerShardInfo() {
  // @@protoc_insertion_point(destructor:protocol.TMPeerShardInfo)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void TMPeerShardInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  shardindexes_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  nodepubkey_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  endpoint_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void TMPeerShardInfo::ArenaDtor(void* object) {
  TMPeerShardInfo* _this = reinterpret_cast< TMPeerShardInfo* >(object);
  (void)_this;
}
void TMPeerShardInfo::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TMPeerShardInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TMPeerShardInfo& TMPeerShardInfo::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TMPeerShardInfo_ripple_2eproto.base);
  return *internal_default_instance();
}


void TMPeerShardInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMPeerShardInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  peerchain_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      shardindexes_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      nodepubkey_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      endpoint_.ClearNonDefaultToEmpty();
    }
  }
  lastlink_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TMPeerShardInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required string shardIndexes = 1 [deprecated = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_shardindexes();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "protocol.TMPeerShardInfo.shardIndexes");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bytes nodePubKey = 2 [deprecated = true];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_nodepubkey();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string endpoint = 3 [deprecated = true];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          auto str = _internal_mutable_endpoint();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "protocol.TMPeerShardInfo.endpoint");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool lastLink = 4 [deprecated = true];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_lastlink(&has_bits);
          lastlink_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .protocol.TMLink peerChain = 5 [deprecated = true];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_peerchain(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* TMPeerShardInfo::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMPeerShardInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string shardIndexes = 1 [deprecated = true];
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_shardindexes().data(), static_cast<int>(this->_internal_shardindexes().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "protocol.TMPeerShardInfo.shardIndexes");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_shardindexes(), target);
  }

  // optional bytes nodePubKey = 2 [deprecated = true];
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_nodepubkey(), target);
  }

  // optional string endpoint = 3 [deprecated = true];
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_endpoint().data(), static_cast<int>(this->_internal_endpoint().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "protocol.TMPeerShardInfo.endpoint");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_endpoint(), target);
  }

  // optional bool lastLink = 4 [deprecated = true];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(4, this->_internal_lastlink(), target);
  }

  // repeated .protocol.TMLink peerChain = 5 [deprecated = true];
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_peerchain_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, this->_internal_peerchain(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMPeerShardInfo)
  return target;
}

size_t TMPeerShardInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMPeerShardInfo)
  size_t total_size = 0;

  // required string shardIndexes = 1 [deprecated = true];
  if (_internal_has_shardindexes()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_shardindexes());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .protocol.TMLink peerChain = 5 [deprecated = true];
  total_size += 1UL * this->_internal_peerchain_size();
  for (const auto& msg : this->peerchain_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000eu) {
    // optional bytes nodePubKey = 2 [deprecated = true];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_nodepubkey());
    }

    // optional string endpoint = 3 [deprecated = true];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_endpoint());
    }

    // optional bool lastLink = 4 [deprecated = true];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TMPeerShardInfo::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protocol.TMPeerShardInfo)
  GOOGLE_DCHECK_NE(&from, this);
  const TMPeerShardInfo* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<TMPeerShardInfo>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protocol.TMPeerShardInfo)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protocol.TMPeerShardInfo)
    MergeFrom(*source);
  }
}

void TMPeerShardInfo::MergeFrom(const TMPeerShardInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMPeerShardInfo)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  peerchain_.MergeFrom(from.peerchain_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_shardindexes(from._internal_shardindexes());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_nodepubkey(from._internal_nodepubkey());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_endpoint(from._internal_endpoint());
    }
    if (cached_has_bits & 0x00000008u) {
      lastlink_ = from.lastlink_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void TMPeerShardInfo::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protocol.TMPeerShardInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMPeerShardInfo::CopyFrom(const TMPeerShardInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMPeerShardInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMPeerShardInfo::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(peerchain_)) return false;
  return true;
}

void TMPeerShardInfo::InternalSwap(TMPeerShardInfo* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  peerchain_.InternalSwap(&other->peerchain_);
  shardindexes_.Swap(&other->shardindexes_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  nodepubkey_.Swap(&other->nodepubkey_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  endpoint_.Swap(&other->endpoint_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  swap(lastlink_, other->lastlink_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TMPeerShardInfo::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void TMPublicKey::InitAsDefaultInstance() {
}
class TMPublicKey::_Internal {
 public:
  using HasBits = decltype(std::declval<TMPublicKey>()._has_bits_);
  static void set_has_publickey(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

TMPublicKey::TMPublicKey(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:protocol.TMPublicKey)
}
TMPublicKey::TMPublicKey(const TMPublicKey& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  publickey_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_publickey()) {
    publickey_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_publickey(),
      GetArena());
  }
  // @@protoc_insertion_point(copy_constructor:protocol.TMPublicKey)
}

void TMPublicKey::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_TMPublicKey_ripple_2eproto.base);
  publickey_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

TMPublicKey::~TMPublicKey() {
  // @@protoc_insertion_point(destructor:protocol.TMPublicKey)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void TMPublicKey::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  publickey_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void TMPublicKey::ArenaDtor(void* object) {
  TMPublicKey* _this = reinterpret_cast< TMPublicKey* >(object);
  (void)_this;
}
void TMPublicKey::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TMPublicKey::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TMPublicKey& TMPublicKey::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TMPublicKey_ripple_2eproto.base);
  return *internal_default_instance();
}


void TMPublicKey::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMPublicKey)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    publickey_.ClearNonDefaultToEmpty();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TMPublicKey::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required bytes publicKey = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_publickey();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* TMPublicKey::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMPublicKey)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required bytes publicKey = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_publickey(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMPublicKey)
  return target;
}

size_t TMPublicKey::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMPublicKey)
  size_t total_size = 0;

  // required bytes publicKey = 1;
  if (_internal_has_publickey()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_publickey());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TMPublicKey::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protocol.TMPublicKey)
  GOOGLE_DCHECK_NE(&from, this);
  const TMPublicKey* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<TMPublicKey>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protocol.TMPublicKey)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protocol.TMPublicKey)
    MergeFrom(*source);
  }
}

void TMPublicKey::MergeFrom(const TMPublicKey& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMPublicKey)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_publickey()) {
    _internal_set_publickey(from._internal_publickey());
  }
}

void TMPublicKey::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protocol.TMPublicKey)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMPublicKey::CopyFrom(const TMPublicKey& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMPublicKey)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMPublicKey::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void TMPublicKey::InternalSwap(TMPublicKey* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  publickey_.Swap(&other->publickey_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}

::PROTOBUF_NAMESPACE_ID::Metadata TMPublicKey::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void TMGetPeerShardInfoV2::InitAsDefaultInstance() {
}
class TMGetPeerShardInfoV2::_Internal {
 public:
  using HasBits = decltype(std::declval<TMGetPeerShardInfoV2>()._has_bits_);
  static void set_has_relays(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

TMGetPeerShardInfoV2::TMGetPeerShardInfoV2(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  peerchain_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:protocol.TMGetPeerShardInfoV2)
}
TMGetPeerShardInfoV2::TMGetPeerShardInfoV2(const TMGetPeerShardInfoV2& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      peerchain_(from.peerchain_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  relays_ = from.relays_;
  // @@protoc_insertion_point(copy_constructor:protocol.TMGetPeerShardInfoV2)
}

void TMGetPeerShardInfoV2::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_TMGetPeerShardInfoV2_ripple_2eproto.base);
  relays_ = 0u;
}

TMGetPeerShardInfoV2::~TMGetPeerShardInfoV2() {
  // @@protoc_insertion_point(destructor:protocol.TMGetPeerShardInfoV2)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void TMGetPeerShardInfoV2::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void TMGetPeerShardInfoV2::ArenaDtor(void* object) {
  TMGetPeerShardInfoV2* _this = reinterpret_cast< TMGetPeerShardInfoV2* >(object);
  (void)_this;
}
void TMGetPeerShardInfoV2::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TMGetPeerShardInfoV2::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TMGetPeerShardInfoV2& TMGetPeerShardInfoV2::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TMGetPeerShardInfoV2_ripple_2eproto.base);
  return *internal_default_instance();
}


void TMGetPeerShardInfoV2::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMGetPeerShardInfoV2)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  peerchain_.Clear();
  relays_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TMGetPeerShardInfoV2::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated .protocol.TMPublicKey peerChain = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_peerchain(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else goto handle_unusual;
        continue;
      // required uint32 relays = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_relays(&has_bits);
          relays_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* TMGetPeerShardInfoV2::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMGetPeerShardInfoV2)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .protocol.TMPublicKey peerChain = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_peerchain_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_peerchain(i), target, stream);
  }

  cached_has_bits = _has_bits_[0];
  // required uint32 relays = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_relays(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMGetPeerShardInfoV2)
  return target;
}

size_t TMGetPeerShardInfoV2::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMGetPeerShardInfoV2)
  size_t total_size = 0;

  // required uint32 relays = 2;
  if (_internal_has_relays()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_relays());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .protocol.TMPublicKey peerChain = 1;
  total_size += 1UL * this->_internal_peerchain_size();
  for (const auto& msg : this->peerchain_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TMGetPeerShardInfoV2::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protocol.TMGetPeerShardInfoV2)
  GOOGLE_DCHECK_NE(&from, this);
  const TMGetPeerShardInfoV2* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<TMGetPeerShardInfoV2>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protocol.TMGetPeerShardInfoV2)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protocol.TMGetPeerShardInfoV2)
    MergeFrom(*source);
  }
}

void TMGetPeerShardInfoV2::MergeFrom(const TMGetPeerShardInfoV2& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMGetPeerShardInfoV2)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  peerchain_.MergeFrom(from.peerchain_);
  if (from._internal_has_relays()) {
    _internal_set_relays(from._internal_relays());
  }
}

void TMGetPeerShardInfoV2::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protocol.TMGetPeerShardInfoV2)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMGetPeerShardInfoV2::CopyFrom(const TMGetPeerShardInfoV2& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMGetPeerShardInfoV2)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMGetPeerShardInfoV2::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(peerchain_)) return false;
  return true;
}

void TMGetPeerShardInfoV2::InternalSwap(TMGetPeerShardInfoV2* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  peerchain_.InternalSwap(&other->peerchain_);
  swap(relays_, other->relays_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TMGetPeerShardInfoV2::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void TMPeerShardInfoV2_TMIncomplete::InitAsDefaultInstance() {
}
class TMPeerShardInfoV2_TMIncomplete::_Internal {
 public:
  using HasBits = decltype(std::declval<TMPeerShardInfoV2_TMIncomplete>()._has_bits_);
  static void set_has_shardindex(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_state(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_progress(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

TMPeerShardInfoV2_TMIncomplete::TMPeerShardInfoV2_TMIncomplete(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:protocol.TMPeerShardInfoV2.TMIncomplete)
}
TMPeerShardInfoV2_TMIncomplete::TMPeerShardInfoV2_TMIncomplete(const TMPeerShardInfoV2_TMIncomplete& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&shardindex_, &from.shardindex_,
    static_cast<size_t>(reinterpret_cast<char*>(&progress_) -
    reinterpret_cast<char*>(&shardindex_)) + sizeof(progress_));
  // @@protoc_insertion_point(copy_constructor:protocol.TMPeerShardInfoV2.TMIncomplete)
}

void TMPeerShardInfoV2_TMIncomplete::SharedCtor() {
  ::memset(&shardindex_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&progress_) -
      reinterpret_cast<char*>(&shardindex_)) + sizeof(progress_));
}

TMPeerShardInfoV2_TMIncomplete::~TMPeerShardInfoV2_TMIncomplete() {
  // @@protoc_insertion_point(destructor:protocol.TMPeerShardInfoV2.TMIncomplete)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void TMPeerShardInfoV2_TMIncomplete::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void TMPeerShardInfoV2_TMIncomplete::ArenaDtor(void* object) {
  TMPeerShardInfoV2_TMIncomplete* _this = reinterpret_cast< TMPeerShardInfoV2_TMIncomplete* >(object);
  (void)_this;
}
void TMPeerShardInfoV2_TMIncomplete::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TMPeerShardInfoV2_TMIncomplete::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TMPeerShardInfoV2_TMIncomplete& TMPeerShardInfoV2_TMIncomplete::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TMPeerShardInfoV2_TMIncomplete_ripple_2eproto.base);
  return *internal_default_instance();
}


void TMPeerShardInfoV2_TMIncomplete::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMPeerShardInfoV2.TMIncomplete)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&shardindex_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&progress_) -
        reinterpret_cast<char*>(&shardindex_)) + sizeof(progress_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TMPeerShardInfoV2_TMIncomplete::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required uint32 shardIndex = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_shardindex(&has_bits);
          shardindex_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required uint32 state = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_state(&has_bits);
          state_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 progress = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_progress(&has_bits);
          progress_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* TMPeerShardInfoV2_TMIncomplete::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMPeerShardInfoV2.TMIncomplete)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 shardIndex = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_shardindex(), target);
  }

  // required uint32 state = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_state(), target);
  }

  // optional uint32 progress = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_progress(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMPeerShardInfoV2.TMIncomplete)
  return target;
}

size_t TMPeerShardInfoV2_TMIncomplete::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:protocol.TMPeerShardInfoV2.TMIncomplete)
  size_t total_size = 0;

  if (_internal_has_shardindex()) {
    // required uint32 shardIndex = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_shardindex());
  }

  if (_internal_has_state()) {
    // required uint32 state = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_state());
  }

  return total_size;
}
size_t TMPeerShardInfoV2_TMIncomplete::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMPeerShardInfoV2.TMIncomplete)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required uint32 shardIndex = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_shardindex());

    // required uint32 state = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_state());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint32 progress = 3;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000004u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_progress());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TMPeerShardInfoV2_TMIncomplete::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protocol.TMPeerShardInfoV2.TMIncomplete)
  GOOGLE_DCHECK_NE(&from, this);
  const TMPeerShardInfoV2_TMIncomplete* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<TMPeerShardInfoV2_TMIncomplete>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protocol.TMPeerShardInfoV2.TMIncomplete)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protocol.TMPeerShardInfoV2.TMIncomplete)
    MergeFrom(*source);
  }
}

void TMPeerShardInfoV2_TMIncomplete::MergeFrom(const TMPeerShardInfoV2_TMIncomplete& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMPeerShardInfoV2.TMIncomplete)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      shardindex_ = from.shardindex_;
    }
    if (cached_has_bits & 0x00000002u) {
      state_ = from.state_;
    }
    if (cached_has_bits & 0x00000004u) {
      progress_ = from.progress_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void TMPeerShardInfoV2_TMIncomplete::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protocol.TMPeerShardInfoV2.TMIncomplete)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMPeerShardInfoV2_TMIncomplete::CopyFrom(const TMPeerShardInfoV2_TMIncomplete& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMPeerShardInfoV2.TMIncomplete)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMPeerShardInfoV2_TMIncomplete::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void TMPeerShardInfoV2_TMIncomplete::InternalSwap(TMPeerShardInfoV2_TMIncomplete* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TMPeerShardInfoV2_TMIncomplete, progress_)
      + sizeof(TMPeerShardInfoV2_TMIncomplete::progress_)
      - PROTOBUF_FIELD_OFFSET(TMPeerShardInfoV2_TMIncomplete, shardindex_)>(
          reinterpret_cast<char*>(&shardindex_),
          reinterpret_cast<char*>(&other->shardindex_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TMPeerShardInfoV2_TMIncomplete::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void TMPeerShardInfoV2::InitAsDefaultInstance() {
}
class TMPeerShardInfoV2::_Internal {
 public:
  using HasBits = decltype(std::declval<TMPeerShardInfoV2>()._has_bits_);
  static void set_has_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_finalized(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_publickey(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_signature(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000e) ^ 0x0000000e) != 0;
  }
};

TMPeerShardInfoV2::TMPeerShardInfoV2(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  incomplete_(arena),
  peerchain_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:protocol.TMPeerShardInfoV2)
}
TMPeerShardInfoV2::TMPeerShardInfoV2(const TMPeerShardInfoV2& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      incomplete_(from.incomplete_),
      peerchain_(from.peerchain_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  finalized_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_finalized()) {
    finalized_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_finalized(),
      GetArena());
  }
  publickey_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_publickey()) {
    publickey_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_publickey(),
      GetArena());
  }
  signature_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_signature()) {
    signature_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_signature(),
      GetArena());
  }
  timestamp_ = from.timestamp_;
  // @@protoc_insertion_point(copy_constructor:protocol.TMPeerShardInfoV2)
}

void TMPeerShardInfoV2::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_TMPeerShardInfoV2_ripple_2eproto.base);
  finalized_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  publickey_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  signature_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  timestamp_ = 0u;
}

TMPeerShardInfoV2::~TMPeerShardInfoV2() {
  // @@protoc_insertion_point(destructor:protocol.TMPeerShardInfoV2)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void TMPeerShardInfoV2::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  finalized_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  publickey_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  signature_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void TMPeerShardInfoV2::ArenaDtor(void* object) {
  TMPeerShardInfoV2* _this = reinterpret_cast< TMPeerShardInfoV2* >(object);
  (void)_this;
}
void TMPeerShardInfoV2::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TMPeerShardInfoV2::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TMPeerShardInfoV2& TMPeerShardInfoV2::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TMPeerShardInfoV2_ripple_2eproto.base);
  return *internal_default_instance();
}


void TMPeerShardInfoV2::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMPeerShardInfoV2)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  incomplete_.Clear();
  peerchain_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      finalized_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      publickey_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      signature_.ClearNonDefaultToEmpty();
    }
  }
  timestamp_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TMPeerShardInfoV2::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required uint32 timestamp = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_timestamp(&has_bits);
          timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .protocol.TMPeerShardInfoV2.TMIncomplete incomplete = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_incomplete(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else goto handle_unusual;
        continue;
      // optional string finalized = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          auto str = _internal_mutable_finalized();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "protocol.TMPeerShardInfoV2.finalized");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required bytes publicKey = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          auto str = _internal_mutable_publickey();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required bytes signature = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          auto str = _internal_mutable_signature();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .protocol.TMPublicKey peerChain = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_peerchain(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* TMPeerShardInfoV2::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMPeerShardInfoV2)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 timestamp = 1;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_timestamp(), target);
  }

  // repeated .protocol.TMPeerShardInfoV2.TMIncomplete incomplete = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_incomplete_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, this->_internal_incomplete(i), target, stream);
  }

  // optional string finalized = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_finalized().data(), static_cast<int>(this->_internal_finalized().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "protocol.TMPeerShardInfoV2.finalized");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_finalized(), target);
  }

  // required bytes publicKey = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_publickey(), target);
  }

  // required bytes signature = 5;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        5, this->_internal_signature(), target);
  }

  // repeated .protocol.TMPublicKey peerChain = 6;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_peerchain_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, this->_internal_peerchain(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMPeerShardInfoV2)
  return target;
}

size_t TMPeerShardInfoV2::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:protocol.TMPeerShardInfoV2)
  size_t total_size = 0;

  if (_internal_has_publickey()) {
    // required bytes publicKey = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_publickey());
  }

  if (_internal_has_signature()) {
    // required bytes signature = 5;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_signature());
  }

  if (_internal_has_timestamp()) {
    // required uint32 timestamp = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_timestamp());
  }

  return total_size;
}
size_t TMPeerShardInfoV2::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMPeerShardInfoV2)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x0000000e) ^ 0x0000000e) == 0) {  // All required fields are present.
    // required bytes publicKey = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_publickey());

    // required bytes signature = 5;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_signature());

    // required uint32 timestamp = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_timestamp());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .protocol.TMPeerShardInfoV2.TMIncomplete incomplete = 2;
  total_size += 1UL * this->_internal_incomplete_size();
  for (const auto& msg : this->incomplete_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .protocol.TMPublicKey peerChain = 6;
  total_size += 1UL * this->_internal_peerchain_size();
  for (const auto& msg : this->peerchain_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional string finalized = 3;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_finalized());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TMPeerShardInfoV2::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protocol.TMPeerShardInfoV2)
  GOOGLE_DCHECK_NE(&from, this);
  const TMPeerShardInfoV2* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<TMPeerShardInfoV2>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protocol.TMPeerShardInfoV2)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protocol.TMPeerShardInfoV2)
    MergeFrom(*source);
  }
}

void TMPeerShardInfoV2::MergeFrom(const TMPeerShardInfoV2& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMPeerShardInfoV2)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  incomplete_.MergeFrom(from.incomplete_);
  peerchain_.MergeFrom(from.peerchain_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_finalized(from._internal_finalized());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_publickey(from._internal_publickey());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_signature(from._internal_signature());
    }
    if (cached_has_bits & 0x00000008u) {
      timestamp_ = from.timestamp_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void TMPeerShardInfoV2::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protocol.TMPeerShardInfoV2)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMPeerShardInfoV2::CopyFrom(const TMPeerShardInfoV2& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMPeerShardInfoV2)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMPeerShardInfoV2::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(incomplete_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(peerchain_)) return false;
  return true;
}

void TMPeerShardInfoV2::InternalSwap(TMPeerShardInfoV2* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  incomplete_.InternalSwap(&other->incomplete_);
  peerchain_.InternalSwap(&other->peerchain_);
  finalized_.Swap(&other->finalized_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  publickey_.Swap(&other->publickey_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  signature_.Swap(&other->signature_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  swap(timestamp_, other->timestamp_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TMPeerShardInfoV2::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void TMTransaction::InitAsDefaultInstance() {
}
class TMTransaction::_Internal {
 public:
  using HasBits = decltype(std::declval<TMTransaction>()._has_bits_);
  static void set_has_rawtransaction(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_receivetimestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_deferred(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000009) ^ 0x00000009) != 0;
  }
};

TMTransaction::TMTransaction(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:protocol.TMTransaction)
}
TMTransaction::TMTransaction(const TMTransaction& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  rawtransaction_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_rawtransaction()) {
    rawtransaction_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_rawtransaction(),
      GetArena());
  }
  ::memcpy(&receivetimestamp_, &from.receivetimestamp_,
    static_cast<size_t>(reinterpret_cast<char*>(&status_) -
    reinterpret_cast<char*>(&receivetimestamp_)) + sizeof(status_));
  // @@protoc_insertion_point(copy_constructor:protocol.TMTransaction)
}

void TMTransaction::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_TMTransaction_ripple_2eproto.base);
  rawtransaction_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&receivetimestamp_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&deferred_) -
      reinterpret_cast<char*>(&receivetimestamp_)) + sizeof(deferred_));
  status_ = 1;
}

TMTransaction::~TMTransaction() {
  // @@protoc_insertion_point(destructor:protocol.TMTransaction)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void TMTransaction::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  rawtransaction_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void TMTransaction::ArenaDtor(void* object) {
  TMTransaction* _this = reinterpret_cast< TMTransaction* >(object);
  (void)_this;
}
void TMTransaction::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TMTransaction::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TMTransaction& TMTransaction::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TMTransaction_ripple_2eproto.base);
  return *internal_default_instance();
}


void TMTransaction::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMTransaction)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    rawtransaction_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&receivetimestamp_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&deferred_) -
        reinterpret_cast<char*>(&receivetimestamp_)) + sizeof(deferred_));
    status_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TMTransaction::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required bytes rawTransaction = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_rawtransaction();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required .protocol.TransactionStatus status = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::protocol::TransactionStatus_IsValid(val))) {
            _internal_set_status(static_cast<::protocol::TransactionStatus>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional uint64 receiveTimestamp = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_receivetimestamp(&has_bits);
          receivetimestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool deferred = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_deferred(&has_bits);
          deferred_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* TMTransaction::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMTransaction)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required bytes rawTransaction = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_rawtransaction(), target);
  }

  // required .protocol.TransactionStatus status = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_status(), target);
  }

  // optional uint64 receiveTimestamp = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(3, this->_internal_receivetimestamp(), target);
  }

  // optional bool deferred = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(4, this->_internal_deferred(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMTransaction)
  return target;
}

size_t TMTransaction::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:protocol.TMTransaction)
  size_t total_size = 0;

  if (_internal_has_rawtransaction()) {
    // required bytes rawTransaction = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_rawtransaction());
  }

  if (_internal_has_status()) {
    // required .protocol.TransactionStatus status = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_status());
  }

  return total_size;
}
size_t TMTransaction::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMTransaction)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000009) ^ 0x00000009) == 0) {  // All required fields are present.
    // required bytes rawTransaction = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_rawtransaction());

    // required .protocol.TransactionStatus status = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_status());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000006u) {
    // optional uint64 receiveTimestamp = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_receivetimestamp());
    }

    // optional bool deferred = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TMTransaction::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protocol.TMTransaction)
  GOOGLE_DCHECK_NE(&from, this);
  const TMTransaction* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<TMTransaction>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protocol.TMTransaction)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protocol.TMTransaction)
    MergeFrom(*source);
  }
}

void TMTransaction::MergeFrom(const TMTransaction& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMTransaction)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_rawtransaction(from._internal_rawtransaction());
    }
    if (cached_has_bits & 0x00000002u) {
      receivetimestamp_ = from.receivetimestamp_;
    }
    if (cached_has_bits & 0x00000004u) {
      deferred_ = from.deferred_;
    }
    if (cached_has_bits & 0x00000008u) {
      status_ = from.status_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void TMTransaction::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protocol.TMTransaction)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMTransaction::CopyFrom(const TMTransaction& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMTransaction)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMTransaction::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void TMTransaction::InternalSwap(TMTransaction* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  rawtransaction_.Swap(&other->rawtransaction_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TMTransaction, deferred_)
      + sizeof(TMTransaction::deferred_)
      - PROTOBUF_FIELD_OFFSET(TMTransaction, receivetimestamp_)>(
          reinterpret_cast<char*>(&receivetimestamp_),
          reinterpret_cast<char*>(&other->receivetimestamp_));
  swap(status_, other->status_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TMTransaction::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void TMTransactions::InitAsDefaultInstance() {
}
class TMTransactions::_Internal {
 public:
};

TMTransactions::TMTransactions(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  transactions_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:protocol.TMTransactions)
}
TMTransactions::TMTransactions(const TMTransactions& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      transactions_(from.transactions_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protocol.TMTransactions)
}

void TMTransactions::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_TMTransactions_ripple_2eproto.base);
}

TMTransactions::~TMTransactions() {
  // @@protoc_insertion_point(destructor:protocol.TMTransactions)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void TMTransactions::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void TMTransactions::ArenaDtor(void* object) {
  TMTransactions* _this = reinterpret_cast< TMTransactions* >(object);
  (void)_this;
}
void TMTransactions::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TMTransactions::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TMTransactions& TMTransactions::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TMTransactions_ripple_2eproto.base);
  return *internal_default_instance();
}


void TMTransactions::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMTransactions)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  transactions_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TMTransactions::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated .protocol.TMTransaction transactions = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_transactions(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* TMTransactions::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMTransactions)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .protocol.TMTransaction transactions = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_transactions_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_transactions(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMTransactions)
  return target;
}

size_t TMTransactions::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMTransactions)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .protocol.TMTransaction transactions = 1;
  total_size += 1UL * this->_internal_transactions_size();
  for (const auto& msg : this->transactions_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TMTransactions::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protocol.TMTransactions)
  GOOGLE_DCHECK_NE(&from, this);
  const TMTransactions* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<TMTransactions>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protocol.TMTransactions)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protocol.TMTransactions)
    MergeFrom(*source);
  }
}

void TMTransactions::MergeFrom(const TMTransactions& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMTransactions)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  transactions_.MergeFrom(from.transactions_);
}

void TMTransactions::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protocol.TMTransactions)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMTransactions::CopyFrom(const TMTransactions& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMTransactions)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMTransactions::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(transactions_)) return false;
  return true;
}

void TMTransactions::InternalSwap(TMTransactions* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  transactions_.InternalSwap(&other->transactions_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TMTransactions::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void TMStatusChange::InitAsDefaultInstance() {
}
class TMStatusChange::_Internal {
 public:
  using HasBits = decltype(std::declval<TMStatusChange>()._has_bits_);
  static void set_has_newstatus(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_newevent(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_ledgerseq(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_ledgerhash(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ledgerhashprevious(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_networktime(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_firstseq(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_lastseq(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

TMStatusChange::TMStatusChange(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:protocol.TMStatusChange)
}
TMStatusChange::TMStatusChange(const TMStatusChange& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ledgerhash_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_ledgerhash()) {
    ledgerhash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_ledgerhash(),
      GetArena());
  }
  ledgerhashprevious_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_ledgerhashprevious()) {
    ledgerhashprevious_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_ledgerhashprevious(),
      GetArena());
  }
  ::memcpy(&ledgerseq_, &from.ledgerseq_,
    static_cast<size_t>(reinterpret_cast<char*>(&newevent_) -
    reinterpret_cast<char*>(&ledgerseq_)) + sizeof(newevent_));
  // @@protoc_insertion_point(copy_constructor:protocol.TMStatusChange)
}

void TMStatusChange::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_TMStatusChange_ripple_2eproto.base);
  ledgerhash_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ledgerhashprevious_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&ledgerseq_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&lastseq_) -
      reinterpret_cast<char*>(&ledgerseq_)) + sizeof(lastseq_));
  newstatus_ = 1;
  newevent_ = 1;
}

TMStatusChange::~TMStatusChange() {
  // @@protoc_insertion_point(destructor:protocol.TMStatusChange)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void TMStatusChange::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  ledgerhash_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ledgerhashprevious_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void TMStatusChange::ArenaDtor(void* object) {
  TMStatusChange* _this = reinterpret_cast< TMStatusChange* >(object);
  (void)_this;
}
void TMStatusChange::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TMStatusChange::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TMStatusChange& TMStatusChange::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TMStatusChange_ripple_2eproto.base);
  return *internal_default_instance();
}


void TMStatusChange::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMStatusChange)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ledgerhash_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      ledgerhashprevious_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000fcu) {
    ::memset(&ledgerseq_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&lastseq_) -
        reinterpret_cast<char*>(&ledgerseq_)) + sizeof(lastseq_));
    newstatus_ = 1;
    newevent_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TMStatusChange::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .protocol.NodeStatus newStatus = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::protocol::NodeStatus_IsValid(val))) {
            _internal_set_newstatus(static_cast<::protocol::NodeStatus>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional .protocol.NodeEvent newEvent = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::protocol::NodeEvent_IsValid(val))) {
            _internal_set_newevent(static_cast<::protocol::NodeEvent>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional uint32 ledgerSeq = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_ledgerseq(&has_bits);
          ledgerseq_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bytes ledgerHash = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          auto str = _internal_mutable_ledgerhash();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bytes ledgerHashPrevious = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          auto str = _internal_mutable_ledgerhashprevious();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 networkTime = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_networktime(&has_bits);
          networktime_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 firstSeq = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          _Internal::set_has_firstseq(&has_bits);
          firstseq_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 lastSeq = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          _Internal::set_has_lastseq(&has_bits);
          lastseq_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* TMStatusChange::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMStatusChange)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .protocol.NodeStatus newStatus = 1;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_newstatus(), target);
  }

  // optional .protocol.NodeEvent newEvent = 2;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_newevent(), target);
  }

  // optional uint32 ledgerSeq = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_ledgerseq(), target);
  }

  // optional bytes ledgerHash = 4;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_ledgerhash(), target);
  }

  // optional bytes ledgerHashPrevious = 5;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        5, this->_internal_ledgerhashprevious(), target);
  }

  // optional uint64 networkTime = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(6, this->_internal_networktime(), target);
  }

  // optional uint32 firstSeq = 7;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(7, this->_internal_firstseq(), target);
  }

  // optional uint32 lastSeq = 8;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(8, this->_internal_lastseq(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMStatusChange)
  return target;
}

size_t TMStatusChange::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMStatusChange)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional bytes ledgerHash = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_ledgerhash());
    }

    // optional bytes ledgerHashPrevious = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_ledgerhashprevious());
    }

    // optional uint32 ledgerSeq = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_ledgerseq());
    }

    // optional uint32 firstSeq = 7;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_firstseq());
    }

    // optional uint64 networkTime = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_networktime());
    }

    // optional uint32 lastSeq = 8;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_lastseq());
    }

    // optional .protocol.NodeStatus newStatus = 1;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_newstatus());
    }

    // optional .protocol.NodeEvent newEvent = 2;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_newevent());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TMStatusChange::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protocol.TMStatusChange)
  GOOGLE_DCHECK_NE(&from, this);
  const TMStatusChange* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<TMStatusChange>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protocol.TMStatusChange)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protocol.TMStatusChange)
    MergeFrom(*source);
  }
}

void TMStatusChange::MergeFrom(const TMStatusChange& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMStatusChange)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_ledgerhash(from._internal_ledgerhash());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_ledgerhashprevious(from._internal_ledgerhashprevious());
    }
    if (cached_has_bits & 0x00000004u) {
      ledgerseq_ = from.ledgerseq_;
    }
    if (cached_has_bits & 0x00000008u) {
      firstseq_ = from.firstseq_;
    }
    if (cached_has_bits & 0x00000010u) {
      networktime_ = from.networktime_;
    }
    if (cached_has_bits & 0x00000020u) {
      lastseq_ = from.lastseq_;
    }
    if (cached_has_bits & 0x00000040u) {
      newstatus_ = from.newstatus_;
    }
    if (cached_has_bits & 0x00000080u) {
      newevent_ = from.newevent_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void TMStatusChange::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protocol.TMStatusChange)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMStatusChange::CopyFrom(const TMStatusChange& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMStatusChange)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMStatusChange::IsInitialized() const {
  return true;
}

void TMStatusChange::InternalSwap(TMStatusChange* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ledgerhash_.Swap(&other->ledgerhash_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  ledgerhashprevious_.Swap(&other->ledgerhashprevious_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TMStatusChange, lastseq_)
      + sizeof(TMStatusChange::lastseq_)
      - PROTOBUF_FIELD_OFFSET(TMStatusChange, ledgerseq_)>(
          reinterpret_cast<char*>(&ledgerseq_),
          reinterpret_cast<char*>(&other->ledgerseq_));
  swap(newstatus_, other->newstatus_);
  swap(newevent_, other->newevent_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TMStatusChange::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void TMProposeSet::InitAsDefaultInstance() {
}
class TMProposeSet::_Internal {
 public:
  using HasBits = decltype(std::declval<TMProposeSet>()._has_bits_);
  static void set_has_proposeseq(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_currenttxhash(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_nodepubkey(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_closetime(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_signature(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_previousledger(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_checkedsignature(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_hops(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000003f) ^ 0x0000003f) != 0;
  }
};

TMProposeSet::TMProposeSet(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  addedtransactions_(arena),
  removedtransactions_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:protocol.TMProposeSet)
}
TMProposeSet::TMProposeSet(const TMProposeSet& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      addedtransactions_(from.addedtransactions_),
      removedtransactions_(from.removedtransactions_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  currenttxhash_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_currenttxhash()) {
    currenttxhash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_currenttxhash(),
      GetArena());
  }
  nodepubkey_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_nodepubkey()) {
    nodepubkey_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_nodepubkey(),
      GetArena());
  }
  signature_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_signature()) {
    signature_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_signature(),
      GetArena());
  }
  previousledger_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_previousledger()) {
    previousledger_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_previousledger(),
      GetArena());
  }
  ::memcpy(&proposeseq_, &from.proposeseq_,
    static_cast<size_t>(reinterpret_cast<char*>(&hops_) -
    reinterpret_cast<char*>(&proposeseq_)) + sizeof(hops_));
  // @@protoc_insertion_point(copy_constructor:protocol.TMProposeSet)
}

void TMProposeSet::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_TMProposeSet_ripple_2eproto.base);
  currenttxhash_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  nodepubkey_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  signature_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  previousledger_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&proposeseq_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&hops_) -
      reinterpret_cast<char*>(&proposeseq_)) + sizeof(hops_));
}

TMProposeSet::~TMProposeSet() {
  // @@protoc_insertion_point(destructor:protocol.TMProposeSet)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void TMProposeSet::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  currenttxhash_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  nodepubkey_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  signature_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  previousledger_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void TMProposeSet::ArenaDtor(void* object) {
  TMProposeSet* _this = reinterpret_cast< TMProposeSet* >(object);
  (void)_this;
}
void TMProposeSet::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TMProposeSet::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TMProposeSet& TMProposeSet::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TMProposeSet_ripple_2eproto.base);
  return *internal_default_instance();
}


void TMProposeSet::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMProposeSet)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  addedtransactions_.Clear();
  removedtransactions_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      currenttxhash_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      nodepubkey_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      signature_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      previousledger_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000f0u) {
    ::memset(&proposeseq_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&hops_) -
        reinterpret_cast<char*>(&proposeseq_)) + sizeof(hops_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TMProposeSet::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required uint32 proposeSeq = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_proposeseq(&has_bits);
          proposeseq_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required bytes currentTxHash = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_currenttxhash();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required bytes nodePubKey = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          auto str = _internal_mutable_nodepubkey();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required uint32 closeTime = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_closetime(&has_bits);
          closetime_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required bytes signature = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          auto str = _internal_mutable_signature();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required bytes previousledger = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          auto str = _internal_mutable_previousledger();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool checkedSignature = 7 [deprecated = true];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          _Internal::set_has_checkedsignature(&has_bits);
          checkedsignature_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated bytes addedTransactions = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 82)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_addedtransactions();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<82>(ptr));
        } else goto handle_unusual;
        continue;
      // repeated bytes removedTransactions = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 90)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_removedtransactions();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<90>(ptr));
        } else goto handle_unusual;
        continue;
      // optional uint32 hops = 12 [deprecated = true];
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 96)) {
          _Internal::set_has_hops(&has_bits);
          hops_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* TMProposeSet::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMProposeSet)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 proposeSeq = 1;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_proposeseq(), target);
  }

  // required bytes currentTxHash = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_currenttxhash(), target);
  }

  // required bytes nodePubKey = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_nodepubkey(), target);
  }

  // required uint32 closeTime = 4;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(4, this->_internal_closetime(), target);
  }

  // required bytes signature = 5;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        5, this->_internal_signature(), target);
  }

  // required bytes previousledger = 6;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteBytesMaybeAliased(
        6, this->_internal_previousledger(), target);
  }

  // optional bool checkedSignature = 7 [deprecated = true];
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(7, this->_internal_checkedsignature(), target);
  }

  // repeated bytes addedTransactions = 10;
  for (int i = 0, n = this->_internal_addedtransactions_size(); i < n; i++) {
    const auto& s = this->_internal_addedtransactions(i);
    target = stream->WriteBytes(10, s, target);
  }

  // repeated bytes removedTransactions = 11;
  for (int i = 0, n = this->_internal_removedtransactions_size(); i < n; i++) {
    const auto& s = this->_internal_removedtransactions(i);
    target = stream->WriteBytes(11, s, target);
  }

  // optional uint32 hops = 12 [deprecated = true];
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(12, this->_internal_hops(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMProposeSet)
  return target;
}

size_t TMProposeSet::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:protocol.TMProposeSet)
  size_t total_size = 0;

  if (_internal_has_currenttxhash()) {
    // required bytes currentTxHash = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_currenttxhash());
  }

  if (_internal_has_nodepubkey()) {
    // required bytes nodePubKey = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_nodepubkey());
  }

  if (_internal_has_signature()) {
    // required bytes signature = 5;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_signature());
  }

  if (_internal_has_previousledger()) {
    // required bytes previousledger = 6;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_previousledger());
  }

  if (_internal_has_proposeseq()) {
    // required uint32 proposeSeq = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_proposeseq());
  }

  if (_internal_has_closetime()) {
    // required uint32 closeTime = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_closetime());
  }

  return total_size;
}
size_t TMProposeSet::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMProposeSet)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x0000003f) ^ 0x0000003f) == 0) {  // All required fields are present.
    // required bytes currentTxHash = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_currenttxhash());

    // required bytes nodePubKey = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_nodepubkey());

    // required bytes signature = 5;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_signature());

    // required bytes previousledger = 6;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_previousledger());

    // required uint32 proposeSeq = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_proposeseq());

    // required uint32 closeTime = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_closetime());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated bytes addedTransactions = 10;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(addedtransactions_.size());
  for (int i = 0, n = addedtransactions_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
      addedtransactions_.Get(i));
  }

  // repeated bytes removedTransactions = 11;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(removedtransactions_.size());
  for (int i = 0, n = removedtransactions_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
      removedtransactions_.Get(i));
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000c0u) {
    // optional bool checkedSignature = 7 [deprecated = true];
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

    // optional uint32 hops = 12 [deprecated = true];
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_hops());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TMProposeSet::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protocol.TMProposeSet)
  GOOGLE_DCHECK_NE(&from, this);
  const TMProposeSet* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<TMProposeSet>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protocol.TMProposeSet)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protocol.TMProposeSet)
    MergeFrom(*source);
  }
}

void TMProposeSet::MergeFrom(const TMProposeSet& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMProposeSet)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  addedtransactions_.MergeFrom(from.addedtransactions_);
  removedtransactions_.MergeFrom(from.removedtransactions_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_currenttxhash(from._internal_currenttxhash());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_nodepubkey(from._internal_nodepubkey());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_signature(from._internal_signature());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_previousledger(from._internal_previousledger());
    }
    if (cached_has_bits & 0x00000010u) {
      proposeseq_ = from.proposeseq_;
    }
    if (cached_has_bits & 0x00000020u) {
      closetime_ = from.closetime_;
    }
    if (cached_has_bits & 0x00000040u) {
      checkedsignature_ = from.checkedsignature_;
    }
    if (cached_has_bits & 0x00000080u) {
      hops_ = from.hops_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void TMProposeSet::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protocol.TMProposeSet)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMProposeSet::CopyFrom(const TMProposeSet& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMProposeSet)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMProposeSet::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void TMProposeSet::InternalSwap(TMProposeSet* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  addedtransactions_.InternalSwap(&other->addedtransactions_);
  removedtransactions_.InternalSwap(&other->removedtransactions_);
  currenttxhash_.Swap(&other->currenttxhash_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  nodepubkey_.Swap(&other->nodepubkey_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  signature_.Swap(&other->signature_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  previousledger_.Swap(&other->previousledger_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TMProposeSet, hops_)
      + sizeof(TMProposeSet::hops_)
      - PROTOBUF_FIELD_OFFSET(TMProposeSet, proposeseq_)>(
          reinterpret_cast<char*>(&proposeseq_),
          reinterpret_cast<char*>(&other->proposeseq_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TMProposeSet::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void TMHaveTransactionSet::InitAsDefaultInstance() {
}
class TMHaveTransactionSet::_Internal {
 public:
  using HasBits = decltype(std::declval<TMHaveTransactionSet>()._has_bits_);
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_hash(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

TMHaveTransactionSet::TMHaveTransactionSet(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:protocol.TMHaveTransactionSet)
}
TMHaveTransactionSet::TMHaveTransactionSet(const TMHaveTransactionSet& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  hash_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_hash()) {
    hash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_hash(),
      GetArena());
  }
  status_ = from.status_;
  // @@protoc_insertion_point(copy_constructor:protocol.TMHaveTransactionSet)
}

void TMHaveTransactionSet::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_TMHaveTransactionSet_ripple_2eproto.base);
  hash_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  status_ = 1;
}

TMHaveTransactionSet::~TMHaveTransactionSet() {
  // @@protoc_insertion_point(destructor:protocol.TMHaveTransactionSet)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void TMHaveTransactionSet::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  hash_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void TMHaveTransactionSet::ArenaDtor(void* object) {
  TMHaveTransactionSet* _this = reinterpret_cast< TMHaveTransactionSet* >(object);
  (void)_this;
}
void TMHaveTransactionSet::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TMHaveTransactionSet::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TMHaveTransactionSet& TMHaveTransactionSet::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TMHaveTransactionSet_ripple_2eproto.base);
  return *internal_default_instance();
}


void TMHaveTransactionSet::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMHaveTransactionSet)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      hash_.ClearNonDefaultToEmpty();
    }
    status_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TMHaveTransactionSet::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required .protocol.TxSetStatus status = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::protocol::TxSetStatus_IsValid(val))) {
            _internal_set_status(static_cast<::protocol::TxSetStatus>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // required bytes hash = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_hash();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* TMHaveTransactionSet::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMHaveTransactionSet)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .protocol.TxSetStatus status = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_status(), target);
  }

  // required bytes hash = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_hash(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMHaveTransactionSet)
  return target;
}

size_t TMHaveTransactionSet::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:protocol.TMHaveTransactionSet)
  size_t total_size = 0;

  if (_internal_has_hash()) {
    // required bytes hash = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_hash());
  }

  if (_internal_has_status()) {
    // required .protocol.TxSetStatus status = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_status());
  }

  return total_size;
}
size_t TMHaveTransactionSet::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMHaveTransactionSet)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required bytes hash = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_hash());

    // required .protocol.TxSetStatus status = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_status());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TMHaveTransactionSet::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protocol.TMHaveTransactionSet)
  GOOGLE_DCHECK_NE(&from, this);
  const TMHaveTransactionSet* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<TMHaveTransactionSet>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protocol.TMHaveTransactionSet)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protocol.TMHaveTransactionSet)
    MergeFrom(*source);
  }
}

void TMHaveTransactionSet::MergeFrom(const TMHaveTransactionSet& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMHaveTransactionSet)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_hash(from._internal_hash());
    }
    if (cached_has_bits & 0x00000002u) {
      status_ = from.status_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void TMHaveTransactionSet::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protocol.TMHaveTransactionSet)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMHaveTransactionSet::CopyFrom(const TMHaveTransactionSet& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMHaveTransactionSet)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMHaveTransactionSet::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void TMHaveTransactionSet::InternalSwap(TMHaveTransactionSet* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  hash_.Swap(&other->hash_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  swap(status_, other->status_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TMHaveTransactionSet::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void TMValidatorList::InitAsDefaultInstance() {
}
class TMValidatorList::_Internal {
 public:
  using HasBits = decltype(std::declval<TMValidatorList>()._has_bits_);
  static void set_has_manifest(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_blob(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_signature(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000f) ^ 0x0000000f) != 0;
  }
};

TMValidatorList::TMValidatorList(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:protocol.TMValidatorList)
}
TMValidatorList::TMValidatorList(const TMValidatorList& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  manifest_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_manifest()) {
    manifest_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_manifest(),
      GetArena());
  }
  blob_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_blob()) {
    blob_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_blob(),
      GetArena());
  }
  signature_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_signature()) {
    signature_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_signature(),
      GetArena());
  }
  version_ = from.version_;
  // @@protoc_insertion_point(copy_constructor:protocol.TMValidatorList)
}

void TMValidatorList::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_TMValidatorList_ripple_2eproto.base);
  manifest_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  blob_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  signature_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  version_ = 0u;
}

TMValidatorList::~TMValidatorList() {
  // @@protoc_insertion_point(destructor:protocol.TMValidatorList)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void TMValidatorList::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  manifest_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  blob_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  signature_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void TMValidatorList::ArenaDtor(void* object) {
  TMValidatorList* _this = reinterpret_cast< TMValidatorList* >(object);
  (void)_this;
}
void TMValidatorList::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TMValidatorList::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TMValidatorList& TMValidatorList::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TMValidatorList_ripple_2eproto.base);
  return *internal_default_instance();
}


void TMValidatorList::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMValidatorList)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      manifest_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      blob_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      signature_.ClearNonDefaultToEmpty();
    }
  }
  version_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TMValidatorList::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required bytes manifest = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_manifest();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required bytes blob = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_blob();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required bytes signature = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          auto str = _internal_mutable_signature();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required uint32 version = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_version(&has_bits);
          version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* TMValidatorList::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMValidatorList)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required bytes manifest = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_manifest(), target);
  }

  // required bytes blob = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_blob(), target);
  }

  // required bytes signature = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_signature(), target);
  }

  // required uint32 version = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(4, this->_internal_version(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMValidatorList)
  return target;
}

size_t TMValidatorList::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:protocol.TMValidatorList)
  size_t total_size = 0;

  if (_internal_has_manifest()) {
    // required bytes manifest = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_manifest());
  }

  if (_internal_has_blob()) {
    // required bytes blob = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_blob());
  }

  if (_internal_has_signature()) {
    // required bytes signature = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_signature());
  }

  if (_internal_has_version()) {
    // required uint32 version = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_version());
  }

  return total_size;
}
size_t TMValidatorList::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMValidatorList)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x0000000f) ^ 0x0000000f) == 0) {  // All required fields are present.
    // required bytes manifest = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_manifest());

    // required bytes blob = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_blob());

    // required bytes signature = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_signature());

    // required uint32 version = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_version());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TMValidatorList::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protocol.TMValidatorList)
  GOOGLE_DCHECK_NE(&from, this);
  const TMValidatorList* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<TMValidatorList>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protocol.TMValidatorList)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protocol.TMValidatorList)
    MergeFrom(*source);
  }
}

void TMValidatorList::MergeFrom(const TMValidatorList& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMValidatorList)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_manifest(from._internal_manifest());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_blob(from._internal_blob());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_signature(from._internal_signature());
    }
    if (cached_has_bits & 0x00000008u) {
      version_ = from.version_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void TMValidatorList::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protocol.TMValidatorList)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMValidatorList::CopyFrom(const TMValidatorList& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMValidatorList)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMValidatorList::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void TMValidatorList::InternalSwap(TMValidatorList* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  manifest_.Swap(&other->manifest_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  blob_.Swap(&other->blob_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  signature_.Swap(&other->signature_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  swap(version_, other->version_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TMValidatorList::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void ValidatorBlobInfo::InitAsDefaultInstance() {
}
class ValidatorBlobInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<ValidatorBlobInfo>()._has_bits_);
  static void set_has_manifest(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_blob(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_signature(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000006) ^ 0x00000006) != 0;
  }
};

ValidatorBlobInfo::ValidatorBlobInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:protocol.ValidatorBlobInfo)
}
ValidatorBlobInfo::ValidatorBlobInfo(const ValidatorBlobInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  manifest_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_manifest()) {
    manifest_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_manifest(),
      GetArena());
  }
  blob_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_blob()) {
    blob_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_blob(),
      GetArena());
  }
  signature_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_signature()) {
    signature_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_signature(),
      GetArena());
  }
  // @@protoc_insertion_point(copy_constructor:protocol.ValidatorBlobInfo)
}

void ValidatorBlobInfo::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_ValidatorBlobInfo_ripple_2eproto.base);
  manifest_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  blob_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  signature_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

ValidatorBlobInfo::~ValidatorBlobInfo() {
  // @@protoc_insertion_point(destructor:protocol.ValidatorBlobInfo)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void ValidatorBlobInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  manifest_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  blob_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  signature_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void ValidatorBlobInfo::ArenaDtor(void* object) {
  ValidatorBlobInfo* _this = reinterpret_cast< ValidatorBlobInfo* >(object);
  (void)_this;
}
void ValidatorBlobInfo::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ValidatorBlobInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ValidatorBlobInfo& ValidatorBlobInfo::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_ValidatorBlobInfo_ripple_2eproto.base);
  return *internal_default_instance();
}


void ValidatorBlobInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.ValidatorBlobInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      manifest_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      blob_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      signature_.ClearNonDefaultToEmpty();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ValidatorBlobInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional bytes manifest = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_manifest();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required bytes blob = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_blob();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required bytes signature = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          auto str = _internal_mutable_signature();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* ValidatorBlobInfo::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.ValidatorBlobInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes manifest = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_manifest(), target);
  }

  // required bytes blob = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_blob(), target);
  }

  // required bytes signature = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_signature(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.ValidatorBlobInfo)
  return target;
}

size_t ValidatorBlobInfo::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:protocol.ValidatorBlobInfo)
  size_t total_size = 0;

  if (_internal_has_blob()) {
    // required bytes blob = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_blob());
  }

  if (_internal_has_signature()) {
    // required bytes signature = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_signature());
  }

  return total_size;
}
size_t ValidatorBlobInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.ValidatorBlobInfo)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000006) ^ 0x00000006) == 0) {  // All required fields are present.
    // required bytes blob = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_blob());

    // required bytes signature = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_signature());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bytes manifest = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_manifest());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ValidatorBlobInfo::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protocol.ValidatorBlobInfo)
  GOOGLE_DCHECK_NE(&from, this);
  const ValidatorBlobInfo* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<ValidatorBlobInfo>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protocol.ValidatorBlobInfo)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protocol.ValidatorBlobInfo)
    MergeFrom(*source);
  }
}

void ValidatorBlobInfo::MergeFrom(const ValidatorBlobInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protocol.ValidatorBlobInfo)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_manifest(from._internal_manifest());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_blob(from._internal_blob());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_signature(from._internal_signature());
    }
  }
}

void ValidatorBlobInfo::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protocol.ValidatorBlobInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ValidatorBlobInfo::CopyFrom(const ValidatorBlobInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.ValidatorBlobInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ValidatorBlobInfo::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void ValidatorBlobInfo::InternalSwap(ValidatorBlobInfo* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  manifest_.Swap(&other->manifest_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  blob_.Swap(&other->blob_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  signature_.Swap(&other->signature_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}

::PROTOBUF_NAMESPACE_ID::Metadata ValidatorBlobInfo::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void TMValidatorListCollection::InitAsDefaultInstance() {
}
class TMValidatorListCollection::_Internal {
 public:
  using HasBits = decltype(std::declval<TMValidatorListCollection>()._has_bits_);
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_manifest(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

TMValidatorListCollection::TMValidatorListCollection(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  blobs_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:protocol.TMValidatorListCollection)
}
TMValidatorListCollection::TMValidatorListCollection(const TMValidatorListCollection& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      blobs_(from.blobs_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  manifest_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_manifest()) {
    manifest_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_manifest(),
      GetArena());
  }
  version_ = from.version_;
  // @@protoc_insertion_point(copy_constructor:protocol.TMValidatorListCollection)
}

void TMValidatorListCollection::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_TMValidatorListCollection_ripple_2eproto.base);
  manifest_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  version_ = 0u;
}

TMValidatorListCollection::~TMValidatorListCollection() {
  // @@protoc_insertion_point(destructor:protocol.TMValidatorListCollection)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void TMValidatorListCollection::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  manifest_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void TMValidatorListCollection::ArenaDtor(void* object) {
  TMValidatorListCollection* _this = reinterpret_cast< TMValidatorListCollection* >(object);
  (void)_this;
}
void TMValidatorListCollection::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TMValidatorListCollection::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TMValidatorListCollection& TMValidatorListCollection::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TMValidatorListCollection_ripple_2eproto.base);
  return *internal_default_instance();
}


void TMValidatorListCollection::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMValidatorListCollection)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  blobs_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    manifest_.ClearNonDefaultToEmpty();
  }
  version_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TMValidatorListCollection::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required uint32 version = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_version(&has_bits);
          version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required bytes manifest = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_manifest();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .protocol.ValidatorBlobInfo blobs = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_blobs(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* TMValidatorListCollection::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMValidatorListCollection)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 version = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_version(), target);
  }

  // required bytes manifest = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_manifest(), target);
  }

  // repeated .protocol.ValidatorBlobInfo blobs = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_blobs_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, this->_internal_blobs(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMValidatorListCollection)
  return target;
}

size_t TMValidatorListCollection::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:protocol.TMValidatorListCollection)
  size_t total_size = 0;

  if (_internal_has_manifest()) {
    // required bytes manifest = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_manifest());
  }

  if (_internal_has_version()) {
    // required uint32 version = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_version());
  }

  return total_size;
}
size_t TMValidatorListCollection::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMValidatorListCollection)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required bytes manifest = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_manifest());

    // required uint32 version = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_version());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .protocol.ValidatorBlobInfo blobs = 3;
  total_size += 1UL * this->_internal_blobs_size();
  for (const auto& msg : this->blobs_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TMValidatorListCollection::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protocol.TMValidatorListCollection)
  GOOGLE_DCHECK_NE(&from, this);
  const TMValidatorListCollection* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<TMValidatorListCollection>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protocol.TMValidatorListCollection)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protocol.TMValidatorListCollection)
    MergeFrom(*source);
  }
}

void TMValidatorListCollection::MergeFrom(const TMValidatorListCollection& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMValidatorListCollection)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  blobs_.MergeFrom(from.blobs_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_manifest(from._internal_manifest());
    }
    if (cached_has_bits & 0x00000002u) {
      version_ = from.version_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void TMValidatorListCollection::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protocol.TMValidatorListCollection)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMValidatorListCollection::CopyFrom(const TMValidatorListCollection& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMValidatorListCollection)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMValidatorListCollection::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(blobs_)) return false;
  return true;
}

void TMValidatorListCollection::InternalSwap(TMValidatorListCollection* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  blobs_.InternalSwap(&other->blobs_);
  manifest_.Swap(&other->manifest_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  swap(version_, other->version_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TMValidatorListCollection::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void TMValidation::InitAsDefaultInstance() {
}
class TMValidation::_Internal {
 public:
  using HasBits = decltype(std::declval<TMValidation>()._has_bits_);
  static void set_has_validation(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_checkedsignature(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_hops(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

TMValidation::TMValidation(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:protocol.TMValidation)
}
TMValidation::TMValidation(const TMValidation& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  validation_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_validation()) {
    validation_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_validation(),
      GetArena());
  }
  ::memcpy(&checkedsignature_, &from.checkedsignature_,
    static_cast<size_t>(reinterpret_cast<char*>(&hops_) -
    reinterpret_cast<char*>(&checkedsignature_)) + sizeof(hops_));
  // @@protoc_insertion_point(copy_constructor:protocol.TMValidation)
}

void TMValidation::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_TMValidation_ripple_2eproto.base);
  validation_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&checkedsignature_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&hops_) -
      reinterpret_cast<char*>(&checkedsignature_)) + sizeof(hops_));
}

TMValidation::~TMValidation() {
  // @@protoc_insertion_point(destructor:protocol.TMValidation)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void TMValidation::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  validation_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void TMValidation::ArenaDtor(void* object) {
  TMValidation* _this = reinterpret_cast< TMValidation* >(object);
  (void)_this;
}
void TMValidation::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TMValidation::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TMValidation& TMValidation::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TMValidation_ripple_2eproto.base);
  return *internal_default_instance();
}


void TMValidation::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMValidation)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    validation_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&checkedsignature_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&hops_) -
        reinterpret_cast<char*>(&checkedsignature_)) + sizeof(hops_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TMValidation::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required bytes validation = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_validation();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool checkedSignature = 2 [deprecated = true];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_checkedsignature(&has_bits);
          checkedsignature_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 hops = 3 [deprecated = true];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_hops(&has_bits);
          hops_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* TMValidation::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMValidation)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required bytes validation = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_validation(), target);
  }

  // optional bool checkedSignature = 2 [deprecated = true];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->_internal_checkedsignature(), target);
  }

  // optional uint32 hops = 3 [deprecated = true];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_hops(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMValidation)
  return target;
}

size_t TMValidation::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMValidation)
  size_t total_size = 0;

  // required bytes validation = 1;
  if (_internal_has_validation()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_validation());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000006u) {
    // optional bool checkedSignature = 2 [deprecated = true];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

    // optional uint32 hops = 3 [deprecated = true];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_hops());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TMValidation::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protocol.TMValidation)
  GOOGLE_DCHECK_NE(&from, this);
  const TMValidation* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<TMValidation>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protocol.TMValidation)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protocol.TMValidation)
    MergeFrom(*source);
  }
}

void TMValidation::MergeFrom(const TMValidation& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMValidation)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_validation(from._internal_validation());
    }
    if (cached_has_bits & 0x00000002u) {
      checkedsignature_ = from.checkedsignature_;
    }
    if (cached_has_bits & 0x00000004u) {
      hops_ = from.hops_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void TMValidation::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protocol.TMValidation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMValidation::CopyFrom(const TMValidation& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMValidation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMValidation::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void TMValidation::InternalSwap(TMValidation* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  validation_.Swap(&other->validation_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TMValidation, hops_)
      + sizeof(TMValidation::hops_)
      - PROTOBUF_FIELD_OFFSET(TMValidation, checkedsignature_)>(
          reinterpret_cast<char*>(&checkedsignature_),
          reinterpret_cast<char*>(&other->checkedsignature_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TMValidation::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void TMEndpoints_TMEndpointv2::InitAsDefaultInstance() {
}
class TMEndpoints_TMEndpointv2::_Internal {
 public:
  using HasBits = decltype(std::declval<TMEndpoints_TMEndpointv2>()._has_bits_);
  static void set_has_endpoint(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_hops(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

TMEndpoints_TMEndpointv2::TMEndpoints_TMEndpointv2(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:protocol.TMEndpoints.TMEndpointv2)
}
TMEndpoints_TMEndpointv2::TMEndpoints_TMEndpointv2(const TMEndpoints_TMEndpointv2& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  endpoint_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_endpoint()) {
    endpoint_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_endpoint(),
      GetArena());
  }
  hops_ = from.hops_;
  // @@protoc_insertion_point(copy_constructor:protocol.TMEndpoints.TMEndpointv2)
}

void TMEndpoints_TMEndpointv2::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_TMEndpoints_TMEndpointv2_ripple_2eproto.base);
  endpoint_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  hops_ = 0u;
}

TMEndpoints_TMEndpointv2::~TMEndpoints_TMEndpointv2() {
  // @@protoc_insertion_point(destructor:protocol.TMEndpoints.TMEndpointv2)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void TMEndpoints_TMEndpointv2::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  endpoint_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void TMEndpoints_TMEndpointv2::ArenaDtor(void* object) {
  TMEndpoints_TMEndpointv2* _this = reinterpret_cast< TMEndpoints_TMEndpointv2* >(object);
  (void)_this;
}
void TMEndpoints_TMEndpointv2::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TMEndpoints_TMEndpointv2::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TMEndpoints_TMEndpointv2& TMEndpoints_TMEndpointv2::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TMEndpoints_TMEndpointv2_ripple_2eproto.base);
  return *internal_default_instance();
}


void TMEndpoints_TMEndpointv2::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMEndpoints.TMEndpointv2)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    endpoint_.ClearNonDefaultToEmpty();
  }
  hops_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TMEndpoints_TMEndpointv2::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required string endpoint = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_endpoint();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "protocol.TMEndpoints.TMEndpointv2.endpoint");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required uint32 hops = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_hops(&has_bits);
          hops_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* TMEndpoints_TMEndpointv2::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMEndpoints.TMEndpointv2)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string endpoint = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_endpoint().data(), static_cast<int>(this->_internal_endpoint().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "protocol.TMEndpoints.TMEndpointv2.endpoint");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_endpoint(), target);
  }

  // required uint32 hops = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_hops(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMEndpoints.TMEndpointv2)
  return target;
}

size_t TMEndpoints_TMEndpointv2::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:protocol.TMEndpoints.TMEndpointv2)
  size_t total_size = 0;

  if (_internal_has_endpoint()) {
    // required string endpoint = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_endpoint());
  }

  if (_internal_has_hops()) {
    // required uint32 hops = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_hops());
  }

  return total_size;
}
size_t TMEndpoints_TMEndpointv2::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMEndpoints.TMEndpointv2)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required string endpoint = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_endpoint());

    // required uint32 hops = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_hops());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TMEndpoints_TMEndpointv2::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protocol.TMEndpoints.TMEndpointv2)
  GOOGLE_DCHECK_NE(&from, this);
  const TMEndpoints_TMEndpointv2* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<TMEndpoints_TMEndpointv2>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protocol.TMEndpoints.TMEndpointv2)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protocol.TMEndpoints.TMEndpointv2)
    MergeFrom(*source);
  }
}

void TMEndpoints_TMEndpointv2::MergeFrom(const TMEndpoints_TMEndpointv2& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMEndpoints.TMEndpointv2)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_endpoint(from._internal_endpoint());
    }
    if (cached_has_bits & 0x00000002u) {
      hops_ = from.hops_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void TMEndpoints_TMEndpointv2::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protocol.TMEndpoints.TMEndpointv2)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMEndpoints_TMEndpointv2::CopyFrom(const TMEndpoints_TMEndpointv2& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMEndpoints.TMEndpointv2)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMEndpoints_TMEndpointv2::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void TMEndpoints_TMEndpointv2::InternalSwap(TMEndpoints_TMEndpointv2* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  endpoint_.Swap(&other->endpoint_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  swap(hops_, other->hops_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TMEndpoints_TMEndpointv2::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void TMEndpoints::InitAsDefaultInstance() {
}
class TMEndpoints::_Internal {
 public:
  using HasBits = decltype(std::declval<TMEndpoints>()._has_bits_);
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

TMEndpoints::TMEndpoints(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  endpoints_v2_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:protocol.TMEndpoints)
}
TMEndpoints::TMEndpoints(const TMEndpoints& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      endpoints_v2_(from.endpoints_v2_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  version_ = from.version_;
  // @@protoc_insertion_point(copy_constructor:protocol.TMEndpoints)
}

void TMEndpoints::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_TMEndpoints_ripple_2eproto.base);
  version_ = 0u;
}

TMEndpoints::~TMEndpoints() {
  // @@protoc_insertion_point(destructor:protocol.TMEndpoints)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void TMEndpoints::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void TMEndpoints::ArenaDtor(void* object) {
  TMEndpoints* _this = reinterpret_cast< TMEndpoints* >(object);
  (void)_this;
}
void TMEndpoints::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TMEndpoints::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TMEndpoints& TMEndpoints::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TMEndpoints_ripple_2eproto.base);
  return *internal_default_instance();
}


void TMEndpoints::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMEndpoints)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  endpoints_v2_.Clear();
  version_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TMEndpoints::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required uint32 version = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_version(&has_bits);
          version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .protocol.TMEndpoints.TMEndpointv2 endpoints_v2 = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_endpoints_v2(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* TMEndpoints::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMEndpoints)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 version = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_version(), target);
  }

  // repeated .protocol.TMEndpoints.TMEndpointv2 endpoints_v2 = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_endpoints_v2_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, this->_internal_endpoints_v2(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMEndpoints)
  return target;
}

size_t TMEndpoints::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMEndpoints)
  size_t total_size = 0;

  // required uint32 version = 1;
  if (_internal_has_version()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_version());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .protocol.TMEndpoints.TMEndpointv2 endpoints_v2 = 3;
  total_size += 1UL * this->_internal_endpoints_v2_size();
  for (const auto& msg : this->endpoints_v2_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TMEndpoints::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protocol.TMEndpoints)
  GOOGLE_DCHECK_NE(&from, this);
  const TMEndpoints* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<TMEndpoints>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protocol.TMEndpoints)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protocol.TMEndpoints)
    MergeFrom(*source);
  }
}

void TMEndpoints::MergeFrom(const TMEndpoints& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMEndpoints)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  endpoints_v2_.MergeFrom(from.endpoints_v2_);
  if (from._internal_has_version()) {
    _internal_set_version(from._internal_version());
  }
}

void TMEndpoints::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protocol.TMEndpoints)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMEndpoints::CopyFrom(const TMEndpoints& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMEndpoints)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMEndpoints::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(endpoints_v2_)) return false;
  return true;
}

void TMEndpoints::InternalSwap(TMEndpoints* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  endpoints_v2_.InternalSwap(&other->endpoints_v2_);
  swap(version_, other->version_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TMEndpoints::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void TMIndexedObject::InitAsDefaultInstance() {
}
class TMIndexedObject::_Internal {
 public:
  using HasBits = decltype(std::declval<TMIndexedObject>()._has_bits_);
  static void set_has_hash(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_nodeid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_index(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_data(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_ledgerseq(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

TMIndexedObject::TMIndexedObject(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:protocol.TMIndexedObject)
}
TMIndexedObject::TMIndexedObject(const TMIndexedObject& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  hash_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_hash()) {
    hash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_hash(),
      GetArena());
  }
  nodeid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_nodeid()) {
    nodeid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_nodeid(),
      GetArena());
  }
  index_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_index()) {
    index_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_index(),
      GetArena());
  }
  data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_data()) {
    data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_data(),
      GetArena());
  }
  ledgerseq_ = from.ledgerseq_;
  // @@protoc_insertion_point(copy_constructor:protocol.TMIndexedObject)
}

void TMIndexedObject::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_TMIndexedObject_ripple_2eproto.base);
  hash_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  nodeid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  index_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ledgerseq_ = 0u;
}

TMIndexedObject::~TMIndexedObject() {
  // @@protoc_insertion_point(destructor:protocol.TMIndexedObject)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void TMIndexedObject::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  hash_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  nodeid_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  index_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  data_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void TMIndexedObject::ArenaDtor(void* object) {
  TMIndexedObject* _this = reinterpret_cast< TMIndexedObject* >(object);
  (void)_this;
}
void TMIndexedObject::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TMIndexedObject::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TMIndexedObject& TMIndexedObject::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TMIndexedObject_ripple_2eproto.base);
  return *internal_default_instance();
}


void TMIndexedObject::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMIndexedObject)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      hash_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      nodeid_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      index_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      data_.ClearNonDefaultToEmpty();
    }
  }
  ledgerseq_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TMIndexedObject::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional bytes hash = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_hash();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bytes nodeID = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_nodeid();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bytes index = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          auto str = _internal_mutable_index();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bytes data = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          auto str = _internal_mutable_data();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 ledgerSeq = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_ledgerseq(&has_bits);
          ledgerseq_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* TMIndexedObject::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMIndexedObject)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes hash = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_hash(), target);
  }

  // optional bytes nodeID = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_nodeid(), target);
  }

  // optional bytes index = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_index(), target);
  }

  // optional bytes data = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_data(), target);
  }

  // optional uint32 ledgerSeq = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(5, this->_internal_ledgerseq(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMIndexedObject)
  return target;
}

size_t TMIndexedObject::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMIndexedObject)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional bytes hash = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_hash());
    }

    // optional bytes nodeID = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_nodeid());
    }

    // optional bytes index = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_index());
    }

    // optional bytes data = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_data());
    }

    // optional uint32 ledgerSeq = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_ledgerseq());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TMIndexedObject::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protocol.TMIndexedObject)
  GOOGLE_DCHECK_NE(&from, this);
  const TMIndexedObject* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<TMIndexedObject>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protocol.TMIndexedObject)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protocol.TMIndexedObject)
    MergeFrom(*source);
  }
}

void TMIndexedObject::MergeFrom(const TMIndexedObject& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMIndexedObject)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_hash(from._internal_hash());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_nodeid(from._internal_nodeid());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_index(from._internal_index());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_data(from._internal_data());
    }
    if (cached_has_bits & 0x00000010u) {
      ledgerseq_ = from.ledgerseq_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void TMIndexedObject::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protocol.TMIndexedObject)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMIndexedObject::CopyFrom(const TMIndexedObject& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMIndexedObject)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMIndexedObject::IsInitialized() const {
  return true;
}

void TMIndexedObject::InternalSwap(TMIndexedObject* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  hash_.Swap(&other->hash_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  nodeid_.Swap(&other->nodeid_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  index_.Swap(&other->index_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  data_.Swap(&other->data_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  swap(ledgerseq_, other->ledgerseq_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TMIndexedObject::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void TMGetObjectByHash::InitAsDefaultInstance() {
}
class TMGetObjectByHash::_Internal {
 public:
  using HasBits = decltype(std::declval<TMGetObjectByHash>()._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_query(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_seq(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_ledgerhash(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_fat(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000a) ^ 0x0000000a) != 0;
  }
};

TMGetObjectByHash::TMGetObjectByHash(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  objects_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:protocol.TMGetObjectByHash)
}
TMGetObjectByHash::TMGetObjectByHash(const TMGetObjectByHash& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      objects_(from.objects_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ledgerhash_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_ledgerhash()) {
    ledgerhash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_ledgerhash(),
      GetArena());
  }
  ::memcpy(&type_, &from.type_,
    static_cast<size_t>(reinterpret_cast<char*>(&fat_) -
    reinterpret_cast<char*>(&type_)) + sizeof(fat_));
  // @@protoc_insertion_point(copy_constructor:protocol.TMGetObjectByHash)
}

void TMGetObjectByHash::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_TMGetObjectByHash_ripple_2eproto.base);
  ledgerhash_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&type_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&fat_) -
      reinterpret_cast<char*>(&type_)) + sizeof(fat_));
}

TMGetObjectByHash::~TMGetObjectByHash() {
  // @@protoc_insertion_point(destructor:protocol.TMGetObjectByHash)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void TMGetObjectByHash::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  ledgerhash_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void TMGetObjectByHash::ArenaDtor(void* object) {
  TMGetObjectByHash* _this = reinterpret_cast< TMGetObjectByHash* >(object);
  (void)_this;
}
void TMGetObjectByHash::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TMGetObjectByHash::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TMGetObjectByHash& TMGetObjectByHash::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TMGetObjectByHash_ripple_2eproto.base);
  return *internal_default_instance();
}


void TMGetObjectByHash::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMGetObjectByHash)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  objects_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ledgerhash_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000001eu) {
    ::memset(&type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&fat_) -
        reinterpret_cast<char*>(&type_)) + sizeof(fat_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TMGetObjectByHash::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required .protocol.TMGetObjectByHash.ObjectType type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::protocol::TMGetObjectByHash_ObjectType_IsValid(val))) {
            _internal_set_type(static_cast<::protocol::TMGetObjectByHash_ObjectType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // required bool query = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_query(&has_bits);
          query_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 seq = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_seq(&has_bits);
          seq_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bytes ledgerHash = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          auto str = _internal_mutable_ledgerhash();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool fat = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_fat(&has_bits);
          fat_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .protocol.TMIndexedObject objects = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_objects(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* TMGetObjectByHash::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMGetObjectByHash)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .protocol.TMGetObjectByHash.ObjectType type = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  // required bool query = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->_internal_query(), target);
  }

  // optional uint32 seq = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_seq(), target);
  }

  // optional bytes ledgerHash = 4;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_ledgerhash(), target);
  }

  // optional bool fat = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(5, this->_internal_fat(), target);
  }

  // repeated .protocol.TMIndexedObject objects = 6;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_objects_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, this->_internal_objects(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMGetObjectByHash)
  return target;
}

size_t TMGetObjectByHash::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:protocol.TMGetObjectByHash)
  size_t total_size = 0;

  if (_internal_has_type()) {
    // required .protocol.TMGetObjectByHash.ObjectType type = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_type());
  }

  if (_internal_has_query()) {
    // required bool query = 2;
    total_size += 1 + 1;
  }

  return total_size;
}
size_t TMGetObjectByHash::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMGetObjectByHash)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x0000000a) ^ 0x0000000a) == 0) {  // All required fields are present.
    // required .protocol.TMGetObjectByHash.ObjectType type = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_type());

    // required bool query = 2;
    total_size += 1 + 1;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .protocol.TMIndexedObject objects = 6;
  total_size += 1UL * this->_internal_objects_size();
  for (const auto& msg : this->objects_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional bytes ledgerHash = 4;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_ledgerhash());
  }

  // optional uint32 seq = 3;
  if (cached_has_bits & 0x00000004u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_seq());
  }

  // optional bool fat = 5;
  if (cached_has_bits & 0x00000010u) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TMGetObjectByHash::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protocol.TMGetObjectByHash)
  GOOGLE_DCHECK_NE(&from, this);
  const TMGetObjectByHash* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<TMGetObjectByHash>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protocol.TMGetObjectByHash)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protocol.TMGetObjectByHash)
    MergeFrom(*source);
  }
}

void TMGetObjectByHash::MergeFrom(const TMGetObjectByHash& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMGetObjectByHash)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  objects_.MergeFrom(from.objects_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_ledgerhash(from._internal_ledgerhash());
    }
    if (cached_has_bits & 0x00000002u) {
      type_ = from.type_;
    }
    if (cached_has_bits & 0x00000004u) {
      seq_ = from.seq_;
    }
    if (cached_has_bits & 0x00000008u) {
      query_ = from.query_;
    }
    if (cached_has_bits & 0x00000010u) {
      fat_ = from.fat_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void TMGetObjectByHash::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protocol.TMGetObjectByHash)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMGetObjectByHash::CopyFrom(const TMGetObjectByHash& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMGetObjectByHash)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMGetObjectByHash::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void TMGetObjectByHash::InternalSwap(TMGetObjectByHash* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  objects_.InternalSwap(&other->objects_);
  ledgerhash_.Swap(&other->ledgerhash_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TMGetObjectByHash, fat_)
      + sizeof(TMGetObjectByHash::fat_)
      - PROTOBUF_FIELD_OFFSET(TMGetObjectByHash, type_)>(
          reinterpret_cast<char*>(&type_),
          reinterpret_cast<char*>(&other->type_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TMGetObjectByHash::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void TMLedgerNode::InitAsDefaultInstance() {
}
class TMLedgerNode::_Internal {
 public:
  using HasBits = decltype(std::declval<TMLedgerNode>()._has_bits_);
  static void set_has_nodedata(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_nodeid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

TMLedgerNode::TMLedgerNode(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:protocol.TMLedgerNode)
}
TMLedgerNode::TMLedgerNode(const TMLedgerNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  nodedata_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_nodedata()) {
    nodedata_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_nodedata(),
      GetArena());
  }
  nodeid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_nodeid()) {
    nodeid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_nodeid(),
      GetArena());
  }
  // @@protoc_insertion_point(copy_constructor:protocol.TMLedgerNode)
}

void TMLedgerNode::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_TMLedgerNode_ripple_2eproto.base);
  nodedata_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  nodeid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

TMLedgerNode::~TMLedgerNode() {
  // @@protoc_insertion_point(destructor:protocol.TMLedgerNode)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void TMLedgerNode::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  nodedata_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  nodeid_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void TMLedgerNode::ArenaDtor(void* object) {
  TMLedgerNode* _this = reinterpret_cast< TMLedgerNode* >(object);
  (void)_this;
}
void TMLedgerNode::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TMLedgerNode::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TMLedgerNode& TMLedgerNode::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TMLedgerNode_ripple_2eproto.base);
  return *internal_default_instance();
}


void TMLedgerNode::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMLedgerNode)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      nodedata_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      nodeid_.ClearNonDefaultToEmpty();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TMLedgerNode::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required bytes nodedata = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_nodedata();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bytes nodeid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_nodeid();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* TMLedgerNode::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMLedgerNode)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required bytes nodedata = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_nodedata(), target);
  }

  // optional bytes nodeid = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_nodeid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMLedgerNode)
  return target;
}

size_t TMLedgerNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMLedgerNode)
  size_t total_size = 0;

  // required bytes nodedata = 1;
  if (_internal_has_nodedata()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_nodedata());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bytes nodeid = 2;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000002u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_nodeid());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TMLedgerNode::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protocol.TMLedgerNode)
  GOOGLE_DCHECK_NE(&from, this);
  const TMLedgerNode* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<TMLedgerNode>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protocol.TMLedgerNode)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protocol.TMLedgerNode)
    MergeFrom(*source);
  }
}

void TMLedgerNode::MergeFrom(const TMLedgerNode& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMLedgerNode)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_nodedata(from._internal_nodedata());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_nodeid(from._internal_nodeid());
    }
  }
}

void TMLedgerNode::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protocol.TMLedgerNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMLedgerNode::CopyFrom(const TMLedgerNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMLedgerNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMLedgerNode::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void TMLedgerNode::InternalSwap(TMLedgerNode* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  nodedata_.Swap(&other->nodedata_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  nodeid_.Swap(&other->nodeid_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}

::PROTOBUF_NAMESPACE_ID::Metadata TMLedgerNode::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void TMGetLedger::InitAsDefaultInstance() {
}
class TMGetLedger::_Internal {
 public:
  using HasBits = decltype(std::declval<TMGetLedger>()._has_bits_);
  static void set_has_itype(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_ltype(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_ledgerhash(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ledgerseq(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_requestcookie(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_querytype(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_querydepth(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000002) ^ 0x00000002) != 0;
  }
};

TMGetLedger::TMGetLedger(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  nodeids_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:protocol.TMGetLedger)
}
TMGetLedger::TMGetLedger(const TMGetLedger& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      nodeids_(from.nodeids_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ledgerhash_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_ledgerhash()) {
    ledgerhash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_ledgerhash(),
      GetArena());
  }
  ::memcpy(&itype_, &from.itype_,
    static_cast<size_t>(reinterpret_cast<char*>(&querydepth_) -
    reinterpret_cast<char*>(&itype_)) + sizeof(querydepth_));
  // @@protoc_insertion_point(copy_constructor:protocol.TMGetLedger)
}

void TMGetLedger::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_TMGetLedger_ripple_2eproto.base);
  ledgerhash_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&itype_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&querydepth_) -
      reinterpret_cast<char*>(&itype_)) + sizeof(querydepth_));
}

TMGetLedger::~TMGetLedger() {
  // @@protoc_insertion_point(destructor:protocol.TMGetLedger)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void TMGetLedger::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  ledgerhash_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void TMGetLedger::ArenaDtor(void* object) {
  TMGetLedger* _this = reinterpret_cast< TMGetLedger* >(object);
  (void)_this;
}
void TMGetLedger::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TMGetLedger::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TMGetLedger& TMGetLedger::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TMGetLedger_ripple_2eproto.base);
  return *internal_default_instance();
}


void TMGetLedger::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMGetLedger)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  nodeids_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ledgerhash_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000007eu) {
    ::memset(&itype_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&querydepth_) -
        reinterpret_cast<char*>(&itype_)) + sizeof(querydepth_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TMGetLedger::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required .protocol.TMLedgerInfoType itype = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::protocol::TMLedgerInfoType_IsValid(val))) {
            _internal_set_itype(static_cast<::protocol::TMLedgerInfoType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional .protocol.TMLedgerType ltype = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::protocol::TMLedgerType_IsValid(val))) {
            _internal_set_ltype(static_cast<::protocol::TMLedgerType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional bytes ledgerHash = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          auto str = _internal_mutable_ledgerhash();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 ledgerSeq = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_ledgerseq(&has_bits);
          ledgerseq_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated bytes nodeIDs = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_nodeids();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else goto handle_unusual;
        continue;
      // optional uint64 requestCookie = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_requestcookie(&has_bits);
          requestcookie_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .protocol.TMQueryType queryType = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::protocol::TMQueryType_IsValid(val))) {
            _internal_set_querytype(static_cast<::protocol::TMQueryType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(7, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional uint32 queryDepth = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          _Internal::set_has_querydepth(&has_bits);
          querydepth_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* TMGetLedger::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMGetLedger)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .protocol.TMLedgerInfoType itype = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_itype(), target);
  }

  // optional .protocol.TMLedgerType ltype = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_ltype(), target);
  }

  // optional bytes ledgerHash = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_ledgerhash(), target);
  }

  // optional uint32 ledgerSeq = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(4, this->_internal_ledgerseq(), target);
  }

  // repeated bytes nodeIDs = 5;
  for (int i = 0, n = this->_internal_nodeids_size(); i < n; i++) {
    const auto& s = this->_internal_nodeids(i);
    target = stream->WriteBytes(5, s, target);
  }

  // optional uint64 requestCookie = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(6, this->_internal_requestcookie(), target);
  }

  // optional .protocol.TMQueryType queryType = 7;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      7, this->_internal_querytype(), target);
  }

  // optional uint32 queryDepth = 8;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(8, this->_internal_querydepth(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMGetLedger)
  return target;
}

size_t TMGetLedger::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMGetLedger)
  size_t total_size = 0;

  // required .protocol.TMLedgerInfoType itype = 1;
  if (_internal_has_itype()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_itype());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated bytes nodeIDs = 5;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(nodeids_.size());
  for (int i = 0, n = nodeids_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
      nodeids_.Get(i));
  }

  // optional bytes ledgerHash = 3;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_ledgerhash());
  }

  if (cached_has_bits & 0x0000007cu) {
    // optional .protocol.TMLedgerType ltype = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_ltype());
    }

    // optional uint32 ledgerSeq = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_ledgerseq());
    }

    // optional .protocol.TMQueryType queryType = 7;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_querytype());
    }

    // optional uint64 requestCookie = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_requestcookie());
    }

    // optional uint32 queryDepth = 8;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_querydepth());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TMGetLedger::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protocol.TMGetLedger)
  GOOGLE_DCHECK_NE(&from, this);
  const TMGetLedger* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<TMGetLedger>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protocol.TMGetLedger)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protocol.TMGetLedger)
    MergeFrom(*source);
  }
}

void TMGetLedger::MergeFrom(const TMGetLedger& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMGetLedger)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  nodeids_.MergeFrom(from.nodeids_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_ledgerhash(from._internal_ledgerhash());
    }
    if (cached_has_bits & 0x00000002u) {
      itype_ = from.itype_;
    }
    if (cached_has_bits & 0x00000004u) {
      ltype_ = from.ltype_;
    }
    if (cached_has_bits & 0x00000008u) {
      ledgerseq_ = from.ledgerseq_;
    }
    if (cached_has_bits & 0x00000010u) {
      querytype_ = from.querytype_;
    }
    if (cached_has_bits & 0x00000020u) {
      requestcookie_ = from.requestcookie_;
    }
    if (cached_has_bits & 0x00000040u) {
      querydepth_ = from.querydepth_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void TMGetLedger::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protocol.TMGetLedger)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMGetLedger::CopyFrom(const TMGetLedger& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMGetLedger)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMGetLedger::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void TMGetLedger::InternalSwap(TMGetLedger* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  nodeids_.InternalSwap(&other->nodeids_);
  ledgerhash_.Swap(&other->ledgerhash_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TMGetLedger, querydepth_)
      + sizeof(TMGetLedger::querydepth_)
      - PROTOBUF_FIELD_OFFSET(TMGetLedger, itype_)>(
          reinterpret_cast<char*>(&itype_),
          reinterpret_cast<char*>(&other->itype_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TMGetLedger::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void TMLedgerData::InitAsDefaultInstance() {
}
class TMLedgerData::_Internal {
 public:
  using HasBits = decltype(std::declval<TMLedgerData>()._has_bits_);
  static void set_has_ledgerhash(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ledgerseq(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_requestcookie(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_error(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

TMLedgerData::TMLedgerData(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  nodes_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:protocol.TMLedgerData)
}
TMLedgerData::TMLedgerData(const TMLedgerData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      nodes_(from.nodes_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ledgerhash_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_ledgerhash()) {
    ledgerhash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_ledgerhash(),
      GetArena());
  }
  ::memcpy(&ledgerseq_, &from.ledgerseq_,
    static_cast<size_t>(reinterpret_cast<char*>(&error_) -
    reinterpret_cast<char*>(&ledgerseq_)) + sizeof(error_));
  // @@protoc_insertion_point(copy_constructor:protocol.TMLedgerData)
}

void TMLedgerData::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_TMLedgerData_ripple_2eproto.base);
  ledgerhash_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&ledgerseq_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&requestcookie_) -
      reinterpret_cast<char*>(&ledgerseq_)) + sizeof(requestcookie_));
  error_ = 1;
}

TMLedgerData::~TMLedgerData() {
  // @@protoc_insertion_point(destructor:protocol.TMLedgerData)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void TMLedgerData::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  ledgerhash_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void TMLedgerData::ArenaDtor(void* object) {
  TMLedgerData* _this = reinterpret_cast< TMLedgerData* >(object);
  (void)_this;
}
void TMLedgerData::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TMLedgerData::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TMLedgerData& TMLedgerData::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TMLedgerData_ripple_2eproto.base);
  return *internal_default_instance();
}


void TMLedgerData::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMLedgerData)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  nodes_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ledgerhash_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000001eu) {
    ::memset(&ledgerseq_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&requestcookie_) -
        reinterpret_cast<char*>(&ledgerseq_)) + sizeof(requestcookie_));
    error_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TMLedgerData::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required bytes ledgerHash = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_ledgerhash();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required uint32 ledgerSeq = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_ledgerseq(&has_bits);
          ledgerseq_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required .protocol.TMLedgerInfoType type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::protocol::TMLedgerInfoType_IsValid(val))) {
            _internal_set_type(static_cast<::protocol::TMLedgerInfoType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // repeated .protocol.TMLedgerNode nodes = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_nodes(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else goto handle_unusual;
        continue;
      // optional uint32 requestCookie = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_requestcookie(&has_bits);
          requestcookie_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .protocol.TMReplyError error = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::protocol::TMReplyError_IsValid(val))) {
            _internal_set_error(static_cast<::protocol::TMReplyError>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(6, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* TMLedgerData::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMLedgerData)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required bytes ledgerHash = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_ledgerhash(), target);
  }

  // required uint32 ledgerSeq = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_ledgerseq(), target);
  }

  // required .protocol.TMLedgerInfoType type = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      3, this->_internal_type(), target);
  }

  // repeated .protocol.TMLedgerNode nodes = 4;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_nodes_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, this->_internal_nodes(i), target, stream);
  }

  // optional uint32 requestCookie = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(5, this->_internal_requestcookie(), target);
  }

  // optional .protocol.TMReplyError error = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      6, this->_internal_error(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMLedgerData)
  return target;
}

size_t TMLedgerData::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:protocol.TMLedgerData)
  size_t total_size = 0;

  if (_internal_has_ledgerhash()) {
    // required bytes ledgerHash = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_ledgerhash());
  }

  if (_internal_has_ledgerseq()) {
    // required uint32 ledgerSeq = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_ledgerseq());
  }

  if (_internal_has_type()) {
    // required .protocol.TMLedgerInfoType type = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_type());
  }

  return total_size;
}
size_t TMLedgerData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMLedgerData)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required bytes ledgerHash = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_ledgerhash());

    // required uint32 ledgerSeq = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_ledgerseq());

    // required .protocol.TMLedgerInfoType type = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .protocol.TMLedgerNode nodes = 4;
  total_size += 1UL * this->_internal_nodes_size();
  for (const auto& msg : this->nodes_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000018u) {
    // optional uint32 requestCookie = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_requestcookie());
    }

    // optional .protocol.TMReplyError error = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_error());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TMLedgerData::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protocol.TMLedgerData)
  GOOGLE_DCHECK_NE(&from, this);
  const TMLedgerData* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<TMLedgerData>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protocol.TMLedgerData)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protocol.TMLedgerData)
    MergeFrom(*source);
  }
}

void TMLedgerData::MergeFrom(const TMLedgerData& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMLedgerData)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  nodes_.MergeFrom(from.nodes_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_ledgerhash(from._internal_ledgerhash());
    }
    if (cached_has_bits & 0x00000002u) {
      ledgerseq_ = from.ledgerseq_;
    }
    if (cached_has_bits & 0x00000004u) {
      type_ = from.type_;
    }
    if (cached_has_bits & 0x00000008u) {
      requestcookie_ = from.requestcookie_;
    }
    if (cached_has_bits & 0x00000010u) {
      error_ = from.error_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void TMLedgerData::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protocol.TMLedgerData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMLedgerData::CopyFrom(const TMLedgerData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMLedgerData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMLedgerData::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(nodes_)) return false;
  return true;
}

void TMLedgerData::InternalSwap(TMLedgerData* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  nodes_.InternalSwap(&other->nodes_);
  ledgerhash_.Swap(&other->ledgerhash_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TMLedgerData, requestcookie_)
      + sizeof(TMLedgerData::requestcookie_)
      - PROTOBUF_FIELD_OFFSET(TMLedgerData, ledgerseq_)>(
          reinterpret_cast<char*>(&ledgerseq_),
          reinterpret_cast<char*>(&other->ledgerseq_));
  swap(error_, other->error_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TMLedgerData::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void TMPing::InitAsDefaultInstance() {
}
class TMPing::_Internal {
 public:
  using HasBits = decltype(std::declval<TMPing>()._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_seq(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_pingtime(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_nettime(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

TMPing::TMPing(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:protocol.TMPing)
}
TMPing::TMPing(const TMPing& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&type_, &from.type_,
    static_cast<size_t>(reinterpret_cast<char*>(&nettime_) -
    reinterpret_cast<char*>(&type_)) + sizeof(nettime_));
  // @@protoc_insertion_point(copy_constructor:protocol.TMPing)
}

void TMPing::SharedCtor() {
  ::memset(&type_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&nettime_) -
      reinterpret_cast<char*>(&type_)) + sizeof(nettime_));
}

TMPing::~TMPing() {
  // @@protoc_insertion_point(destructor:protocol.TMPing)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void TMPing::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void TMPing::ArenaDtor(void* object) {
  TMPing* _this = reinterpret_cast< TMPing* >(object);
  (void)_this;
}
void TMPing::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TMPing::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TMPing& TMPing::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TMPing_ripple_2eproto.base);
  return *internal_default_instance();
}


void TMPing::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMPing)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&nettime_) -
        reinterpret_cast<char*>(&type_)) + sizeof(nettime_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TMPing::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required .protocol.TMPing.pingType type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::protocol::TMPing_pingType_IsValid(val))) {
            _internal_set_type(static_cast<::protocol::TMPing_pingType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional uint32 seq = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_seq(&has_bits);
          seq_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 pingTime = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_pingtime(&has_bits);
          pingtime_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 netTime = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_nettime(&has_bits);
          nettime_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* TMPing::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMPing)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .protocol.TMPing.pingType type = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  // optional uint32 seq = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_seq(), target);
  }

  // optional uint64 pingTime = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(3, this->_internal_pingtime(), target);
  }

  // optional uint64 netTime = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(4, this->_internal_nettime(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMPing)
  return target;
}

size_t TMPing::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMPing)
  size_t total_size = 0;

  // required .protocol.TMPing.pingType type = 1;
  if (_internal_has_type()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_type());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000eu) {
    // optional uint32 seq = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_seq());
    }

    // optional uint64 pingTime = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_pingtime());
    }

    // optional uint64 netTime = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_nettime());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TMPing::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protocol.TMPing)
  GOOGLE_DCHECK_NE(&from, this);
  const TMPing* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<TMPing>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protocol.TMPing)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protocol.TMPing)
    MergeFrom(*source);
  }
}

void TMPing::MergeFrom(const TMPing& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMPing)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      type_ = from.type_;
    }
    if (cached_has_bits & 0x00000002u) {
      seq_ = from.seq_;
    }
    if (cached_has_bits & 0x00000004u) {
      pingtime_ = from.pingtime_;
    }
    if (cached_has_bits & 0x00000008u) {
      nettime_ = from.nettime_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void TMPing::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protocol.TMPing)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMPing::CopyFrom(const TMPing& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMPing)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMPing::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void TMPing::InternalSwap(TMPing* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TMPing, nettime_)
      + sizeof(TMPing::nettime_)
      - PROTOBUF_FIELD_OFFSET(TMPing, type_)>(
          reinterpret_cast<char*>(&type_),
          reinterpret_cast<char*>(&other->type_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TMPing::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void TMSquelch::InitAsDefaultInstance() {
}
class TMSquelch::_Internal {
 public:
  using HasBits = decltype(std::declval<TMSquelch>()._has_bits_);
  static void set_has_squelch(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_validatorpubkey(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_squelchduration(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

TMSquelch::TMSquelch(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:protocol.TMSquelch)
}
TMSquelch::TMSquelch(const TMSquelch& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  validatorpubkey_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_validatorpubkey()) {
    validatorpubkey_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_validatorpubkey(),
      GetArena());
  }
  ::memcpy(&squelch_, &from.squelch_,
    static_cast<size_t>(reinterpret_cast<char*>(&squelchduration_) -
    reinterpret_cast<char*>(&squelch_)) + sizeof(squelchduration_));
  // @@protoc_insertion_point(copy_constructor:protocol.TMSquelch)
}

void TMSquelch::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_TMSquelch_ripple_2eproto.base);
  validatorpubkey_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&squelch_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&squelchduration_) -
      reinterpret_cast<char*>(&squelch_)) + sizeof(squelchduration_));
}

TMSquelch::~TMSquelch() {
  // @@protoc_insertion_point(destructor:protocol.TMSquelch)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void TMSquelch::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  validatorpubkey_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void TMSquelch::ArenaDtor(void* object) {
  TMSquelch* _this = reinterpret_cast< TMSquelch* >(object);
  (void)_this;
}
void TMSquelch::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TMSquelch::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TMSquelch& TMSquelch::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TMSquelch_ripple_2eproto.base);
  return *internal_default_instance();
}


void TMSquelch::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMSquelch)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    validatorpubkey_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&squelch_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&squelchduration_) -
        reinterpret_cast<char*>(&squelch_)) + sizeof(squelchduration_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TMSquelch::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required bool squelch = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_squelch(&has_bits);
          squelch_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required bytes validatorPubKey = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_validatorpubkey();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 squelchDuration = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_squelchduration(&has_bits);
          squelchduration_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* TMSquelch::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMSquelch)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required bool squelch = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->_internal_squelch(), target);
  }

  // required bytes validatorPubKey = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_validatorpubkey(), target);
  }

  // optional uint32 squelchDuration = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_squelchduration(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMSquelch)
  return target;
}

size_t TMSquelch::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:protocol.TMSquelch)
  size_t total_size = 0;

  if (_internal_has_validatorpubkey()) {
    // required bytes validatorPubKey = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_validatorpubkey());
  }

  if (_internal_has_squelch()) {
    // required bool squelch = 1;
    total_size += 1 + 1;
  }

  return total_size;
}
size_t TMSquelch::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMSquelch)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required bytes validatorPubKey = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_validatorpubkey());

    // required bool squelch = 1;
    total_size += 1 + 1;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint32 squelchDuration = 3;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000004u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_squelchduration());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TMSquelch::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protocol.TMSquelch)
  GOOGLE_DCHECK_NE(&from, this);
  const TMSquelch* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<TMSquelch>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protocol.TMSquelch)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protocol.TMSquelch)
    MergeFrom(*source);
  }
}

void TMSquelch::MergeFrom(const TMSquelch& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMSquelch)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_validatorpubkey(from._internal_validatorpubkey());
    }
    if (cached_has_bits & 0x00000002u) {
      squelch_ = from.squelch_;
    }
    if (cached_has_bits & 0x00000004u) {
      squelchduration_ = from.squelchduration_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void TMSquelch::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protocol.TMSquelch)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMSquelch::CopyFrom(const TMSquelch& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMSquelch)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMSquelch::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void TMSquelch::InternalSwap(TMSquelch* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  validatorpubkey_.Swap(&other->validatorpubkey_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TMSquelch, squelchduration_)
      + sizeof(TMSquelch::squelchduration_)
      - PROTOBUF_FIELD_OFFSET(TMSquelch, squelch_)>(
          reinterpret_cast<char*>(&squelch_),
          reinterpret_cast<char*>(&other->squelch_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TMSquelch::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void TMProofPathRequest::InitAsDefaultInstance() {
}
class TMProofPathRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<TMProofPathRequest>()._has_bits_);
  static void set_has_key(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ledgerhash(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

TMProofPathRequest::TMProofPathRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:protocol.TMProofPathRequest)
}
TMProofPathRequest::TMProofPathRequest(const TMProofPathRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  key_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_key()) {
    key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_key(),
      GetArena());
  }
  ledgerhash_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_ledgerhash()) {
    ledgerhash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_ledgerhash(),
      GetArena());
  }
  type_ = from.type_;
  // @@protoc_insertion_point(copy_constructor:protocol.TMProofPathRequest)
}

void TMProofPathRequest::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_TMProofPathRequest_ripple_2eproto.base);
  key_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ledgerhash_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  type_ = 1;
}

TMProofPathRequest::~TMProofPathRequest() {
  // @@protoc_insertion_point(destructor:protocol.TMProofPathRequest)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void TMProofPathRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  key_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ledgerhash_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void TMProofPathRequest::ArenaDtor(void* object) {
  TMProofPathRequest* _this = reinterpret_cast< TMProofPathRequest* >(object);
  (void)_this;
}
void TMProofPathRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TMProofPathRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TMProofPathRequest& TMProofPathRequest::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TMProofPathRequest_ripple_2eproto.base);
  return *internal_default_instance();
}


void TMProofPathRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMProofPathRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      key_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      ledgerhash_.ClearNonDefaultToEmpty();
    }
    type_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TMProofPathRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required bytes key = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_key();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required bytes ledgerHash = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_ledgerhash();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required .protocol.TMLedgerMapType type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::protocol::TMLedgerMapType_IsValid(val))) {
            _internal_set_type(static_cast<::protocol::TMLedgerMapType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* TMProofPathRequest::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMProofPathRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required bytes key = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_key(), target);
  }

  // required bytes ledgerHash = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_ledgerhash(), target);
  }

  // required .protocol.TMLedgerMapType type = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      3, this->_internal_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMProofPathRequest)
  return target;
}

size_t TMProofPathRequest::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:protocol.TMProofPathRequest)
  size_t total_size = 0;

  if (_internal_has_key()) {
    // required bytes key = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_key());
  }

  if (_internal_has_ledgerhash()) {
    // required bytes ledgerHash = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_ledgerhash());
  }

  if (_internal_has_type()) {
    // required .protocol.TMLedgerMapType type = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_type());
  }

  return total_size;
}
size_t TMProofPathRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMProofPathRequest)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required bytes key = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_key());

    // required bytes ledgerHash = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_ledgerhash());

    // required .protocol.TMLedgerMapType type = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TMProofPathRequest::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protocol.TMProofPathRequest)
  GOOGLE_DCHECK_NE(&from, this);
  const TMProofPathRequest* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<TMProofPathRequest>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protocol.TMProofPathRequest)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protocol.TMProofPathRequest)
    MergeFrom(*source);
  }
}

void TMProofPathRequest::MergeFrom(const TMProofPathRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMProofPathRequest)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_key(from._internal_key());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_ledgerhash(from._internal_ledgerhash());
    }
    if (cached_has_bits & 0x00000004u) {
      type_ = from.type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void TMProofPathRequest::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protocol.TMProofPathRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMProofPathRequest::CopyFrom(const TMProofPathRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMProofPathRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMProofPathRequest::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void TMProofPathRequest::InternalSwap(TMProofPathRequest* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  key_.Swap(&other->key_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  ledgerhash_.Swap(&other->ledgerhash_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  swap(type_, other->type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TMProofPathRequest::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void TMProofPathResponse::InitAsDefaultInstance() {
}
class TMProofPathResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<TMProofPathResponse>()._has_bits_);
  static void set_has_key(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ledgerhash(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_ledgerheader(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_error(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000b) ^ 0x0000000b) != 0;
  }
};

TMProofPathResponse::TMProofPathResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  path_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:protocol.TMProofPathResponse)
}
TMProofPathResponse::TMProofPathResponse(const TMProofPathResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      path_(from.path_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  key_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_key()) {
    key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_key(),
      GetArena());
  }
  ledgerhash_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_ledgerhash()) {
    ledgerhash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_ledgerhash(),
      GetArena());
  }
  ledgerheader_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_ledgerheader()) {
    ledgerheader_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_ledgerheader(),
      GetArena());
  }
  ::memcpy(&type_, &from.type_,
    static_cast<size_t>(reinterpret_cast<char*>(&error_) -
    reinterpret_cast<char*>(&type_)) + sizeof(error_));
  // @@protoc_insertion_point(copy_constructor:protocol.TMProofPathResponse)
}

void TMProofPathResponse::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_TMProofPathResponse_ripple_2eproto.base);
  key_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ledgerhash_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ledgerheader_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  type_ = 1;
  error_ = 1;
}

TMProofPathResponse::~TMProofPathResponse() {
  // @@protoc_insertion_point(destructor:protocol.TMProofPathResponse)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void TMProofPathResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  key_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ledgerhash_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ledgerheader_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void TMProofPathResponse::ArenaDtor(void* object) {
  TMProofPathResponse* _this = reinterpret_cast< TMProofPathResponse* >(object);
  (void)_this;
}
void TMProofPathResponse::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TMProofPathResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TMProofPathResponse& TMProofPathResponse::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TMProofPathResponse_ripple_2eproto.base);
  return *internal_default_instance();
}


void TMProofPathResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMProofPathResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  path_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      key_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      ledgerhash_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      ledgerheader_.ClearNonDefaultToEmpty();
    }
    type_ = 1;
    error_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TMProofPathResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required bytes key = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_key();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required bytes ledgerHash = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_ledgerhash();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required .protocol.TMLedgerMapType type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::protocol::TMLedgerMapType_IsValid(val))) {
            _internal_set_type(static_cast<::protocol::TMLedgerMapType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional bytes ledgerHeader = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          auto str = _internal_mutable_ledgerheader();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated bytes path = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_path();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else goto handle_unusual;
        continue;
      // optional .protocol.TMReplyError error = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::protocol::TMReplyError_IsValid(val))) {
            _internal_set_error(static_cast<::protocol::TMReplyError>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(6, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* TMProofPathResponse::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMProofPathResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required bytes key = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_key(), target);
  }

  // required bytes ledgerHash = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_ledgerhash(), target);
  }

  // required .protocol.TMLedgerMapType type = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      3, this->_internal_type(), target);
  }

  // optional bytes ledgerHeader = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_ledgerheader(), target);
  }

  // repeated bytes path = 5;
  for (int i = 0, n = this->_internal_path_size(); i < n; i++) {
    const auto& s = this->_internal_path(i);
    target = stream->WriteBytes(5, s, target);
  }

  // optional .protocol.TMReplyError error = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      6, this->_internal_error(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMProofPathResponse)
  return target;
}

size_t TMProofPathResponse::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:protocol.TMProofPathResponse)
  size_t total_size = 0;

  if (_internal_has_key()) {
    // required bytes key = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_key());
  }

  if (_internal_has_ledgerhash()) {
    // required bytes ledgerHash = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_ledgerhash());
  }

  if (_internal_has_type()) {
    // required .protocol.TMLedgerMapType type = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_type());
  }

  return total_size;
}
size_t TMProofPathResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMProofPathResponse)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x0000000b) ^ 0x0000000b) == 0) {  // All required fields are present.
    // required bytes key = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_key());

    // required bytes ledgerHash = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_ledgerhash());

    // required .protocol.TMLedgerMapType type = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated bytes path = 5;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(path_.size());
  for (int i = 0, n = path_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
      path_.Get(i));
  }

  // optional bytes ledgerHeader = 4;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000004u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_ledgerheader());
  }

  // optional .protocol.TMReplyError error = 6;
  if (cached_has_bits & 0x00000010u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_error());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TMProofPathResponse::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protocol.TMProofPathResponse)
  GOOGLE_DCHECK_NE(&from, this);
  const TMProofPathResponse* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<TMProofPathResponse>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protocol.TMProofPathResponse)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protocol.TMProofPathResponse)
    MergeFrom(*source);
  }
}

void TMProofPathResponse::MergeFrom(const TMProofPathResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMProofPathResponse)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  path_.MergeFrom(from.path_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_key(from._internal_key());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_ledgerhash(from._internal_ledgerhash());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_ledgerheader(from._internal_ledgerheader());
    }
    if (cached_has_bits & 0x00000008u) {
      type_ = from.type_;
    }
    if (cached_has_bits & 0x00000010u) {
      error_ = from.error_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void TMProofPathResponse::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protocol.TMProofPathResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMProofPathResponse::CopyFrom(const TMProofPathResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMProofPathResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMProofPathResponse::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void TMProofPathResponse::InternalSwap(TMProofPathResponse* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  path_.InternalSwap(&other->path_);
  key_.Swap(&other->key_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  ledgerhash_.Swap(&other->ledgerhash_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  ledgerheader_.Swap(&other->ledgerheader_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  swap(type_, other->type_);
  swap(error_, other->error_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TMProofPathResponse::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void TMReplayDeltaRequest::InitAsDefaultInstance() {
}
class TMReplayDeltaRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<TMReplayDeltaRequest>()._has_bits_);
  static void set_has_ledgerhash(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

TMReplayDeltaRequest::TMReplayDeltaRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:protocol.TMReplayDeltaRequest)
}
TMReplayDeltaRequest::TMReplayDeltaRequest(const TMReplayDeltaRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ledgerhash_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_ledgerhash()) {
    ledgerhash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_ledgerhash(),
      GetArena());
  }
  // @@protoc_insertion_point(copy_constructor:protocol.TMReplayDeltaRequest)
}

void TMReplayDeltaRequest::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_TMReplayDeltaRequest_ripple_2eproto.base);
  ledgerhash_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

TMReplayDeltaRequest::~TMReplayDeltaRequest() {
  // @@protoc_insertion_point(destructor:protocol.TMReplayDeltaRequest)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void TMReplayDeltaRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  ledgerhash_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void TMReplayDeltaRequest::ArenaDtor(void* object) {
  TMReplayDeltaRequest* _this = reinterpret_cast< TMReplayDeltaRequest* >(object);
  (void)_this;
}
void TMReplayDeltaRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TMReplayDeltaRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TMReplayDeltaRequest& TMReplayDeltaRequest::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TMReplayDeltaRequest_ripple_2eproto.base);
  return *internal_default_instance();
}


void TMReplayDeltaRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMReplayDeltaRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ledgerhash_.ClearNonDefaultToEmpty();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TMReplayDeltaRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required bytes ledgerHash = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_ledgerhash();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* TMReplayDeltaRequest::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMReplayDeltaRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required bytes ledgerHash = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_ledgerhash(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMReplayDeltaRequest)
  return target;
}

size_t TMReplayDeltaRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMReplayDeltaRequest)
  size_t total_size = 0;

  // required bytes ledgerHash = 1;
  if (_internal_has_ledgerhash()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_ledgerhash());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TMReplayDeltaRequest::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protocol.TMReplayDeltaRequest)
  GOOGLE_DCHECK_NE(&from, this);
  const TMReplayDeltaRequest* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<TMReplayDeltaRequest>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protocol.TMReplayDeltaRequest)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protocol.TMReplayDeltaRequest)
    MergeFrom(*source);
  }
}

void TMReplayDeltaRequest::MergeFrom(const TMReplayDeltaRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMReplayDeltaRequest)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_ledgerhash()) {
    _internal_set_ledgerhash(from._internal_ledgerhash());
  }
}

void TMReplayDeltaRequest::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protocol.TMReplayDeltaRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMReplayDeltaRequest::CopyFrom(const TMReplayDeltaRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMReplayDeltaRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMReplayDeltaRequest::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void TMReplayDeltaRequest::InternalSwap(TMReplayDeltaRequest* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ledgerhash_.Swap(&other->ledgerhash_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}

::PROTOBUF_NAMESPACE_ID::Metadata TMReplayDeltaRequest::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void TMReplayDeltaResponse::InitAsDefaultInstance() {
}
class TMReplayDeltaResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<TMReplayDeltaResponse>()._has_bits_);
  static void set_has_ledgerhash(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ledgerheader(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_error(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

TMReplayDeltaResponse::TMReplayDeltaResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  transaction_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:protocol.TMReplayDeltaResponse)
}
TMReplayDeltaResponse::TMReplayDeltaResponse(const TMReplayDeltaResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      transaction_(from.transaction_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ledgerhash_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_ledgerhash()) {
    ledgerhash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_ledgerhash(),
      GetArena());
  }
  ledgerheader_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_ledgerheader()) {
    ledgerheader_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_ledgerheader(),
      GetArena());
  }
  error_ = from.error_;
  // @@protoc_insertion_point(copy_constructor:protocol.TMReplayDeltaResponse)
}

void TMReplayDeltaResponse::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_TMReplayDeltaResponse_ripple_2eproto.base);
  ledgerhash_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ledgerheader_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  error_ = 1;
}

TMReplayDeltaResponse::~TMReplayDeltaResponse() {
  // @@protoc_insertion_point(destructor:protocol.TMReplayDeltaResponse)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void TMReplayDeltaResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  ledgerhash_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ledgerheader_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void TMReplayDeltaResponse::ArenaDtor(void* object) {
  TMReplayDeltaResponse* _this = reinterpret_cast< TMReplayDeltaResponse* >(object);
  (void)_this;
}
void TMReplayDeltaResponse::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TMReplayDeltaResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TMReplayDeltaResponse& TMReplayDeltaResponse::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TMReplayDeltaResponse_ripple_2eproto.base);
  return *internal_default_instance();
}


void TMReplayDeltaResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMReplayDeltaResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  transaction_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      ledgerhash_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      ledgerheader_.ClearNonDefaultToEmpty();
    }
    error_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TMReplayDeltaResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required bytes ledgerHash = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_ledgerhash();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bytes ledgerHeader = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_ledgerheader();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated bytes transaction = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_transaction();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else goto handle_unusual;
        continue;
      // optional .protocol.TMReplyError error = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::protocol::TMReplyError_IsValid(val))) {
            _internal_set_error(static_cast<::protocol::TMReplyError>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* TMReplayDeltaResponse::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMReplayDeltaResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required bytes ledgerHash = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_ledgerhash(), target);
  }

  // optional bytes ledgerHeader = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_ledgerheader(), target);
  }

  // repeated bytes transaction = 3;
  for (int i = 0, n = this->_internal_transaction_size(); i < n; i++) {
    const auto& s = this->_internal_transaction(i);
    target = stream->WriteBytes(3, s, target);
  }

  // optional .protocol.TMReplyError error = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      4, this->_internal_error(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMReplayDeltaResponse)
  return target;
}

size_t TMReplayDeltaResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMReplayDeltaResponse)
  size_t total_size = 0;

  // required bytes ledgerHash = 1;
  if (_internal_has_ledgerhash()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_ledgerhash());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated bytes transaction = 3;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(transaction_.size());
  for (int i = 0, n = transaction_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
      transaction_.Get(i));
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000006u) {
    // optional bytes ledgerHeader = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_ledgerheader());
    }

    // optional .protocol.TMReplyError error = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_error());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TMReplayDeltaResponse::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protocol.TMReplayDeltaResponse)
  GOOGLE_DCHECK_NE(&from, this);
  const TMReplayDeltaResponse* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<TMReplayDeltaResponse>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protocol.TMReplayDeltaResponse)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protocol.TMReplayDeltaResponse)
    MergeFrom(*source);
  }
}

void TMReplayDeltaResponse::MergeFrom(const TMReplayDeltaResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMReplayDeltaResponse)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  transaction_.MergeFrom(from.transaction_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_ledgerhash(from._internal_ledgerhash());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_ledgerheader(from._internal_ledgerheader());
    }
    if (cached_has_bits & 0x00000004u) {
      error_ = from.error_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void TMReplayDeltaResponse::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protocol.TMReplayDeltaResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMReplayDeltaResponse::CopyFrom(const TMReplayDeltaResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMReplayDeltaResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMReplayDeltaResponse::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void TMReplayDeltaResponse::InternalSwap(TMReplayDeltaResponse* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  transaction_.InternalSwap(&other->transaction_);
  ledgerhash_.Swap(&other->ledgerhash_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  ledgerheader_.Swap(&other->ledgerheader_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  swap(error_, other->error_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TMReplayDeltaResponse::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void TMHaveTransactions::InitAsDefaultInstance() {
}
class TMHaveTransactions::_Internal {
 public:
};

TMHaveTransactions::TMHaveTransactions(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  hashes_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:protocol.TMHaveTransactions)
}
TMHaveTransactions::TMHaveTransactions(const TMHaveTransactions& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      hashes_(from.hashes_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protocol.TMHaveTransactions)
}

void TMHaveTransactions::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_TMHaveTransactions_ripple_2eproto.base);
}

TMHaveTransactions::~TMHaveTransactions() {
  // @@protoc_insertion_point(destructor:protocol.TMHaveTransactions)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void TMHaveTransactions::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void TMHaveTransactions::ArenaDtor(void* object) {
  TMHaveTransactions* _this = reinterpret_cast< TMHaveTransactions* >(object);
  (void)_this;
}
void TMHaveTransactions::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TMHaveTransactions::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TMHaveTransactions& TMHaveTransactions::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TMHaveTransactions_ripple_2eproto.base);
  return *internal_default_instance();
}


void TMHaveTransactions::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMHaveTransactions)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  hashes_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TMHaveTransactions::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated bytes hashes = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_hashes();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* TMHaveTransactions::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMHaveTransactions)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated bytes hashes = 1;
  for (int i = 0, n = this->_internal_hashes_size(); i < n; i++) {
    const auto& s = this->_internal_hashes(i);
    target = stream->WriteBytes(1, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMHaveTransactions)
  return target;
}

size_t TMHaveTransactions::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMHaveTransactions)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated bytes hashes = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(hashes_.size());
  for (int i = 0, n = hashes_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
      hashes_.Get(i));
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TMHaveTransactions::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protocol.TMHaveTransactions)
  GOOGLE_DCHECK_NE(&from, this);
  const TMHaveTransactions* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<TMHaveTransactions>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protocol.TMHaveTransactions)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protocol.TMHaveTransactions)
    MergeFrom(*source);
  }
}

void TMHaveTransactions::MergeFrom(const TMHaveTransactions& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMHaveTransactions)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  hashes_.MergeFrom(from.hashes_);
}

void TMHaveTransactions::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protocol.TMHaveTransactions)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMHaveTransactions::CopyFrom(const TMHaveTransactions& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMHaveTransactions)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMHaveTransactions::IsInitialized() const {
  return true;
}

void TMHaveTransactions::InternalSwap(TMHaveTransactions* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  hashes_.InternalSwap(&other->hashes_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TMHaveTransactions::GetMetadata() const {
  return GetMetadataStatic();
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace protocol
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::protocol::TMManifest* Arena::CreateMaybeMessage< ::protocol::TMManifest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::TMManifest >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMManifests* Arena::CreateMaybeMessage< ::protocol::TMManifests >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::TMManifests >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMClusterNode* Arena::CreateMaybeMessage< ::protocol::TMClusterNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::TMClusterNode >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMLoadSource* Arena::CreateMaybeMessage< ::protocol::TMLoadSource >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::TMLoadSource >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMCluster* Arena::CreateMaybeMessage< ::protocol::TMCluster >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::TMCluster >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMLink* Arena::CreateMaybeMessage< ::protocol::TMLink >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::TMLink >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMGetPeerShardInfo* Arena::CreateMaybeMessage< ::protocol::TMGetPeerShardInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::TMGetPeerShardInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMPeerShardInfo* Arena::CreateMaybeMessage< ::protocol::TMPeerShardInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::TMPeerShardInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMPublicKey* Arena::CreateMaybeMessage< ::protocol::TMPublicKey >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::TMPublicKey >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMGetPeerShardInfoV2* Arena::CreateMaybeMessage< ::protocol::TMGetPeerShardInfoV2 >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::TMGetPeerShardInfoV2 >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMPeerShardInfoV2_TMIncomplete* Arena::CreateMaybeMessage< ::protocol::TMPeerShardInfoV2_TMIncomplete >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::TMPeerShardInfoV2_TMIncomplete >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMPeerShardInfoV2* Arena::CreateMaybeMessage< ::protocol::TMPeerShardInfoV2 >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::TMPeerShardInfoV2 >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMTransaction* Arena::CreateMaybeMessage< ::protocol::TMTransaction >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::TMTransaction >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMTransactions* Arena::CreateMaybeMessage< ::protocol::TMTransactions >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::TMTransactions >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMStatusChange* Arena::CreateMaybeMessage< ::protocol::TMStatusChange >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::TMStatusChange >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMProposeSet* Arena::CreateMaybeMessage< ::protocol::TMProposeSet >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::TMProposeSet >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMHaveTransactionSet* Arena::CreateMaybeMessage< ::protocol::TMHaveTransactionSet >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::TMHaveTransactionSet >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMValidatorList* Arena::CreateMaybeMessage< ::protocol::TMValidatorList >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::TMValidatorList >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::ValidatorBlobInfo* Arena::CreateMaybeMessage< ::protocol::ValidatorBlobInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::ValidatorBlobInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMValidatorListCollection* Arena::CreateMaybeMessage< ::protocol::TMValidatorListCollection >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::TMValidatorListCollection >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMValidation* Arena::CreateMaybeMessage< ::protocol::TMValidation >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::TMValidation >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMEndpoints_TMEndpointv2* Arena::CreateMaybeMessage< ::protocol::TMEndpoints_TMEndpointv2 >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::TMEndpoints_TMEndpointv2 >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMEndpoints* Arena::CreateMaybeMessage< ::protocol::TMEndpoints >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::TMEndpoints >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMIndexedObject* Arena::CreateMaybeMessage< ::protocol::TMIndexedObject >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::TMIndexedObject >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMGetObjectByHash* Arena::CreateMaybeMessage< ::protocol::TMGetObjectByHash >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::TMGetObjectByHash >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMLedgerNode* Arena::CreateMaybeMessage< ::protocol::TMLedgerNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::TMLedgerNode >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMGetLedger* Arena::CreateMaybeMessage< ::protocol::TMGetLedger >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::TMGetLedger >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMLedgerData* Arena::CreateMaybeMessage< ::protocol::TMLedgerData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::TMLedgerData >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMPing* Arena::CreateMaybeMessage< ::protocol::TMPing >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::TMPing >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMSquelch* Arena::CreateMaybeMessage< ::protocol::TMSquelch >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::TMSquelch >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMProofPathRequest* Arena::CreateMaybeMessage< ::protocol::TMProofPathRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::TMProofPathRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMProofPathResponse* Arena::CreateMaybeMessage< ::protocol::TMProofPathResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::TMProofPathResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMReplayDeltaRequest* Arena::CreateMaybeMessage< ::protocol::TMReplayDeltaRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::TMReplayDeltaRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMReplayDeltaResponse* Arena::CreateMaybeMessage< ::protocol::TMReplayDeltaResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::TMReplayDeltaResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMHaveTransactions* Arena::CreateMaybeMessage< ::protocol::TMHaveTransactions >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::TMHaveTransactions >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
