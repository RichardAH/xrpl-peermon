// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ripple.proto

#include "ripple.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
extern PROTOBUF_INTERNAL_EXPORT_ripple_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_TMClusterNode_ripple_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_ripple_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_TMEndpoint_ripple_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_ripple_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_TMEndpoints_TMEndpointv2_ripple_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_ripple_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_TMIPv4Endpoint_ripple_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_ripple_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_TMIndexedObject_ripple_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_ripple_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_TMLedgerNode_ripple_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_ripple_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_TMLink_ripple_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_ripple_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_TMLoadSource_ripple_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_ripple_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_TMManifest_ripple_2eproto;
namespace protocol {
class TMManifestDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TMManifest> _instance;
} _TMManifest_default_instance_;
class TMManifestsDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TMManifests> _instance;
} _TMManifests_default_instance_;
class TMClusterNodeDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TMClusterNode> _instance;
} _TMClusterNode_default_instance_;
class TMLoadSourceDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TMLoadSource> _instance;
} _TMLoadSource_default_instance_;
class TMClusterDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TMCluster> _instance;
} _TMCluster_default_instance_;
class TMGetShardInfoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TMGetShardInfo> _instance;
} _TMGetShardInfo_default_instance_;
class TMShardInfoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TMShardInfo> _instance;
} _TMShardInfo_default_instance_;
class TMLinkDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TMLink> _instance;
} _TMLink_default_instance_;
class TMGetPeerShardInfoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TMGetPeerShardInfo> _instance;
} _TMGetPeerShardInfo_default_instance_;
class TMPeerShardInfoDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TMPeerShardInfo> _instance;
} _TMPeerShardInfo_default_instance_;
class TMTransactionDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TMTransaction> _instance;
} _TMTransaction_default_instance_;
class TMStatusChangeDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TMStatusChange> _instance;
} _TMStatusChange_default_instance_;
class TMProposeSetDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TMProposeSet> _instance;
} _TMProposeSet_default_instance_;
class TMHaveTransactionSetDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TMHaveTransactionSet> _instance;
} _TMHaveTransactionSet_default_instance_;
class TMValidatorListDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TMValidatorList> _instance;
} _TMValidatorList_default_instance_;
class TMValidationDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TMValidation> _instance;
} _TMValidation_default_instance_;
class TMIPv4EndpointDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TMIPv4Endpoint> _instance;
} _TMIPv4Endpoint_default_instance_;
class TMEndpointDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TMEndpoint> _instance;
} _TMEndpoint_default_instance_;
class TMEndpoints_TMEndpointv2DefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TMEndpoints_TMEndpointv2> _instance;
} _TMEndpoints_TMEndpointv2_default_instance_;
class TMEndpointsDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TMEndpoints> _instance;
} _TMEndpoints_default_instance_;
class TMIndexedObjectDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TMIndexedObject> _instance;
} _TMIndexedObject_default_instance_;
class TMGetObjectByHashDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TMGetObjectByHash> _instance;
} _TMGetObjectByHash_default_instance_;
class TMLedgerNodeDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TMLedgerNode> _instance;
} _TMLedgerNode_default_instance_;
class TMGetLedgerDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TMGetLedger> _instance;
} _TMGetLedger_default_instance_;
class TMLedgerDataDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TMLedgerData> _instance;
} _TMLedgerData_default_instance_;
class TMPingDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TMPing> _instance;
} _TMPing_default_instance_;
}  // namespace protocol
static void InitDefaultsscc_info_TMCluster_ripple_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::protocol::_TMCluster_default_instance_;
    new (ptr) ::protocol::TMCluster();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::protocol::TMCluster::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_TMCluster_ripple_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 2, 0, InitDefaultsscc_info_TMCluster_ripple_2eproto}, {
      &scc_info_TMClusterNode_ripple_2eproto.base,
      &scc_info_TMLoadSource_ripple_2eproto.base,}};

static void InitDefaultsscc_info_TMClusterNode_ripple_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::protocol::_TMClusterNode_default_instance_;
    new (ptr) ::protocol::TMClusterNode();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::protocol::TMClusterNode::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_TMClusterNode_ripple_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_TMClusterNode_ripple_2eproto}, {}};

static void InitDefaultsscc_info_TMEndpoint_ripple_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::protocol::_TMEndpoint_default_instance_;
    new (ptr) ::protocol::TMEndpoint();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::protocol::TMEndpoint::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_TMEndpoint_ripple_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_TMEndpoint_ripple_2eproto}, {
      &scc_info_TMIPv4Endpoint_ripple_2eproto.base,}};

static void InitDefaultsscc_info_TMEndpoints_ripple_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::protocol::_TMEndpoints_default_instance_;
    new (ptr) ::protocol::TMEndpoints();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::protocol::TMEndpoints::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_TMEndpoints_ripple_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 2, 0, InitDefaultsscc_info_TMEndpoints_ripple_2eproto}, {
      &scc_info_TMEndpoint_ripple_2eproto.base,
      &scc_info_TMEndpoints_TMEndpointv2_ripple_2eproto.base,}};

static void InitDefaultsscc_info_TMEndpoints_TMEndpointv2_ripple_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::protocol::_TMEndpoints_TMEndpointv2_default_instance_;
    new (ptr) ::protocol::TMEndpoints_TMEndpointv2();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::protocol::TMEndpoints_TMEndpointv2::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_TMEndpoints_TMEndpointv2_ripple_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_TMEndpoints_TMEndpointv2_ripple_2eproto}, {}};

static void InitDefaultsscc_info_TMGetLedger_ripple_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::protocol::_TMGetLedger_default_instance_;
    new (ptr) ::protocol::TMGetLedger();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::protocol::TMGetLedger::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_TMGetLedger_ripple_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_TMGetLedger_ripple_2eproto}, {}};

static void InitDefaultsscc_info_TMGetObjectByHash_ripple_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::protocol::_TMGetObjectByHash_default_instance_;
    new (ptr) ::protocol::TMGetObjectByHash();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::protocol::TMGetObjectByHash::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_TMGetObjectByHash_ripple_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_TMGetObjectByHash_ripple_2eproto}, {
      &scc_info_TMIndexedObject_ripple_2eproto.base,}};

static void InitDefaultsscc_info_TMGetPeerShardInfo_ripple_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::protocol::_TMGetPeerShardInfo_default_instance_;
    new (ptr) ::protocol::TMGetPeerShardInfo();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::protocol::TMGetPeerShardInfo::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_TMGetPeerShardInfo_ripple_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_TMGetPeerShardInfo_ripple_2eproto}, {
      &scc_info_TMLink_ripple_2eproto.base,}};

static void InitDefaultsscc_info_TMGetShardInfo_ripple_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::protocol::_TMGetShardInfo_default_instance_;
    new (ptr) ::protocol::TMGetShardInfo();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::protocol::TMGetShardInfo::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_TMGetShardInfo_ripple_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_TMGetShardInfo_ripple_2eproto}, {}};

static void InitDefaultsscc_info_TMHaveTransactionSet_ripple_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::protocol::_TMHaveTransactionSet_default_instance_;
    new (ptr) ::protocol::TMHaveTransactionSet();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::protocol::TMHaveTransactionSet::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_TMHaveTransactionSet_ripple_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_TMHaveTransactionSet_ripple_2eproto}, {}};

static void InitDefaultsscc_info_TMIPv4Endpoint_ripple_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::protocol::_TMIPv4Endpoint_default_instance_;
    new (ptr) ::protocol::TMIPv4Endpoint();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::protocol::TMIPv4Endpoint::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_TMIPv4Endpoint_ripple_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_TMIPv4Endpoint_ripple_2eproto}, {}};

static void InitDefaultsscc_info_TMIndexedObject_ripple_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::protocol::_TMIndexedObject_default_instance_;
    new (ptr) ::protocol::TMIndexedObject();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::protocol::TMIndexedObject::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_TMIndexedObject_ripple_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_TMIndexedObject_ripple_2eproto}, {}};

static void InitDefaultsscc_info_TMLedgerData_ripple_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::protocol::_TMLedgerData_default_instance_;
    new (ptr) ::protocol::TMLedgerData();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::protocol::TMLedgerData::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_TMLedgerData_ripple_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_TMLedgerData_ripple_2eproto}, {
      &scc_info_TMLedgerNode_ripple_2eproto.base,}};

static void InitDefaultsscc_info_TMLedgerNode_ripple_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::protocol::_TMLedgerNode_default_instance_;
    new (ptr) ::protocol::TMLedgerNode();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::protocol::TMLedgerNode::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_TMLedgerNode_ripple_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_TMLedgerNode_ripple_2eproto}, {}};

static void InitDefaultsscc_info_TMLink_ripple_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::protocol::_TMLink_default_instance_;
    new (ptr) ::protocol::TMLink();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::protocol::TMLink::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_TMLink_ripple_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_TMLink_ripple_2eproto}, {}};

static void InitDefaultsscc_info_TMLoadSource_ripple_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::protocol::_TMLoadSource_default_instance_;
    new (ptr) ::protocol::TMLoadSource();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::protocol::TMLoadSource::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_TMLoadSource_ripple_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_TMLoadSource_ripple_2eproto}, {}};

static void InitDefaultsscc_info_TMManifest_ripple_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::protocol::_TMManifest_default_instance_;
    new (ptr) ::protocol::TMManifest();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::protocol::TMManifest::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_TMManifest_ripple_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_TMManifest_ripple_2eproto}, {}};

static void InitDefaultsscc_info_TMManifests_ripple_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::protocol::_TMManifests_default_instance_;
    new (ptr) ::protocol::TMManifests();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::protocol::TMManifests::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_TMManifests_ripple_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_TMManifests_ripple_2eproto}, {
      &scc_info_TMManifest_ripple_2eproto.base,}};

static void InitDefaultsscc_info_TMPeerShardInfo_ripple_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::protocol::_TMPeerShardInfo_default_instance_;
    new (ptr) ::protocol::TMPeerShardInfo();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::protocol::TMPeerShardInfo::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_TMPeerShardInfo_ripple_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_TMPeerShardInfo_ripple_2eproto}, {
      &scc_info_TMLink_ripple_2eproto.base,}};

static void InitDefaultsscc_info_TMPing_ripple_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::protocol::_TMPing_default_instance_;
    new (ptr) ::protocol::TMPing();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::protocol::TMPing::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_TMPing_ripple_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_TMPing_ripple_2eproto}, {}};

static void InitDefaultsscc_info_TMProposeSet_ripple_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::protocol::_TMProposeSet_default_instance_;
    new (ptr) ::protocol::TMProposeSet();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::protocol::TMProposeSet::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_TMProposeSet_ripple_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_TMProposeSet_ripple_2eproto}, {}};

static void InitDefaultsscc_info_TMShardInfo_ripple_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::protocol::_TMShardInfo_default_instance_;
    new (ptr) ::protocol::TMShardInfo();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::protocol::TMShardInfo::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_TMShardInfo_ripple_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_TMShardInfo_ripple_2eproto}, {}};

static void InitDefaultsscc_info_TMStatusChange_ripple_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::protocol::_TMStatusChange_default_instance_;
    new (ptr) ::protocol::TMStatusChange();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::protocol::TMStatusChange::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_TMStatusChange_ripple_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_TMStatusChange_ripple_2eproto}, {}};

static void InitDefaultsscc_info_TMTransaction_ripple_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::protocol::_TMTransaction_default_instance_;
    new (ptr) ::protocol::TMTransaction();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::protocol::TMTransaction::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_TMTransaction_ripple_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_TMTransaction_ripple_2eproto}, {}};

static void InitDefaultsscc_info_TMValidation_ripple_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::protocol::_TMValidation_default_instance_;
    new (ptr) ::protocol::TMValidation();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::protocol::TMValidation::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_TMValidation_ripple_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_TMValidation_ripple_2eproto}, {}};

static void InitDefaultsscc_info_TMValidatorList_ripple_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::protocol::_TMValidatorList_default_instance_;
    new (ptr) ::protocol::TMValidatorList();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::protocol::TMValidatorList::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_TMValidatorList_ripple_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_TMValidatorList_ripple_2eproto}, {}};

static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_ripple_2eproto[26];
static const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* file_level_enum_descriptors_ripple_2eproto[11];
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_ripple_2eproto = nullptr;

const ::PROTOBUF_NAMESPACE_ID::uint32 TableStruct_ripple_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::protocol::TMManifest, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMManifest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::protocol::TMManifest, stobject_),
  0,
  PROTOBUF_FIELD_OFFSET(::protocol::TMManifests, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMManifests, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::protocol::TMManifests, list_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMManifests, history_),
  ~0u,
  0,
  PROTOBUF_FIELD_OFFSET(::protocol::TMClusterNode, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMClusterNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::protocol::TMClusterNode, publickey_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMClusterNode, reporttime_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMClusterNode, nodeload_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMClusterNode, nodename_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMClusterNode, address_),
  0,
  3,
  4,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::protocol::TMLoadSource, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMLoadSource, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::protocol::TMLoadSource, name_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMLoadSource, cost_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMLoadSource, count_),
  0,
  1,
  2,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::protocol::TMCluster, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::protocol::TMCluster, clusternodes_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMCluster, loadsources_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMGetShardInfo, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMGetShardInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::protocol::TMGetShardInfo, hops_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMGetShardInfo, lastlink_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMGetShardInfo, peerchain_),
  0,
  1,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::protocol::TMShardInfo, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMShardInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::protocol::TMShardInfo, shardindexes_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMShardInfo, nodepubkey_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMShardInfo, endpoint_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMShardInfo, lastlink_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMShardInfo, peerchain_),
  0,
  1,
  2,
  3,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::protocol::TMLink, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMLink, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::protocol::TMLink, nodepubkey_),
  0,
  PROTOBUF_FIELD_OFFSET(::protocol::TMGetPeerShardInfo, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMGetPeerShardInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::protocol::TMGetPeerShardInfo, hops_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMGetPeerShardInfo, lastlink_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMGetPeerShardInfo, peerchain_),
  0,
  1,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::protocol::TMPeerShardInfo, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMPeerShardInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::protocol::TMPeerShardInfo, shardindexes_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMPeerShardInfo, nodepubkey_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMPeerShardInfo, endpoint_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMPeerShardInfo, lastlink_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMPeerShardInfo, peerchain_),
  0,
  1,
  2,
  3,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::protocol::TMTransaction, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMTransaction, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::protocol::TMTransaction, rawtransaction_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMTransaction, status_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMTransaction, receivetimestamp_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMTransaction, deferred_),
  0,
  3,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::protocol::TMStatusChange, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMStatusChange, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::protocol::TMStatusChange, newstatus_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMStatusChange, newevent_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMStatusChange, ledgerseq_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMStatusChange, ledgerhash_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMStatusChange, ledgerhashprevious_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMStatusChange, networktime_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMStatusChange, firstseq_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMStatusChange, lastseq_),
  6,
  7,
  2,
  0,
  1,
  4,
  3,
  5,
  PROTOBUF_FIELD_OFFSET(::protocol::TMProposeSet, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMProposeSet, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::protocol::TMProposeSet, proposeseq_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMProposeSet, currenttxhash_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMProposeSet, nodepubkey_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMProposeSet, closetime_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMProposeSet, signature_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMProposeSet, previousledger_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMProposeSet, checkedsignature_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMProposeSet, addedtransactions_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMProposeSet, removedtransactions_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMProposeSet, hops_),
  4,
  0,
  1,
  5,
  2,
  3,
  6,
  ~0u,
  ~0u,
  7,
  PROTOBUF_FIELD_OFFSET(::protocol::TMHaveTransactionSet, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMHaveTransactionSet, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::protocol::TMHaveTransactionSet, status_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMHaveTransactionSet, hash_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::protocol::TMValidatorList, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMValidatorList, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::protocol::TMValidatorList, manifest_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMValidatorList, blob_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMValidatorList, signature_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMValidatorList, version_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::protocol::TMValidation, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMValidation, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::protocol::TMValidation, validation_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMValidation, checkedsignature_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMValidation, hops_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::protocol::TMIPv4Endpoint, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMIPv4Endpoint, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::protocol::TMIPv4Endpoint, ipv4_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMIPv4Endpoint, ipv4port_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::protocol::TMEndpoint, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMEndpoint, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::protocol::TMEndpoint, ipv4_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMEndpoint, hops_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::protocol::TMEndpoints_TMEndpointv2, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMEndpoints_TMEndpointv2, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::protocol::TMEndpoints_TMEndpointv2, endpoint_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMEndpoints_TMEndpointv2, hops_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::protocol::TMEndpoints, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMEndpoints, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::protocol::TMEndpoints, version_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMEndpoints, endpoints_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMEndpoints, endpoints_v2_),
  0,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::protocol::TMIndexedObject, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMIndexedObject, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::protocol::TMIndexedObject, hash_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMIndexedObject, nodeid_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMIndexedObject, index_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMIndexedObject, data_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMIndexedObject, ledgerseq_),
  0,
  1,
  2,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::protocol::TMGetObjectByHash, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMGetObjectByHash, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::protocol::TMGetObjectByHash, type_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMGetObjectByHash, query_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMGetObjectByHash, seq_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMGetObjectByHash, ledgerhash_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMGetObjectByHash, fat_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMGetObjectByHash, objects_),
  1,
  3,
  2,
  0,
  4,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::protocol::TMLedgerNode, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMLedgerNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::protocol::TMLedgerNode, nodedata_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMLedgerNode, nodeid_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::protocol::TMGetLedger, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMGetLedger, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::protocol::TMGetLedger, itype_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMGetLedger, ltype_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMGetLedger, ledgerhash_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMGetLedger, ledgerseq_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMGetLedger, nodeids_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMGetLedger, requestcookie_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMGetLedger, querytype_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMGetLedger, querydepth_),
  1,
  2,
  0,
  3,
  ~0u,
  5,
  4,
  6,
  PROTOBUF_FIELD_OFFSET(::protocol::TMLedgerData, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMLedgerData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::protocol::TMLedgerData, ledgerhash_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMLedgerData, ledgerseq_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMLedgerData, type_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMLedgerData, nodes_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMLedgerData, requestcookie_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMLedgerData, error_),
  0,
  1,
  2,
  ~0u,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::protocol::TMPing, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMPing, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::protocol::TMPing, type_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMPing, seq_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMPing, pingtime_),
  PROTOBUF_FIELD_OFFSET(::protocol::TMPing, nettime_),
  0,
  1,
  2,
  3,
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 6, sizeof(::protocol::TMManifest)},
  { 7, 14, sizeof(::protocol::TMManifests)},
  { 16, 26, sizeof(::protocol::TMClusterNode)},
  { 31, 39, sizeof(::protocol::TMLoadSource)},
  { 42, -1, sizeof(::protocol::TMCluster)},
  { 49, 57, sizeof(::protocol::TMGetShardInfo)},
  { 60, 70, sizeof(::protocol::TMShardInfo)},
  { 75, 81, sizeof(::protocol::TMLink)},
  { 82, 90, sizeof(::protocol::TMGetPeerShardInfo)},
  { 93, 103, sizeof(::protocol::TMPeerShardInfo)},
  { 108, 117, sizeof(::protocol::TMTransaction)},
  { 121, 134, sizeof(::protocol::TMStatusChange)},
  { 142, 157, sizeof(::protocol::TMProposeSet)},
  { 167, 174, sizeof(::protocol::TMHaveTransactionSet)},
  { 176, 185, sizeof(::protocol::TMValidatorList)},
  { 189, 197, sizeof(::protocol::TMValidation)},
  { 200, 207, sizeof(::protocol::TMIPv4Endpoint)},
  { 209, 216, sizeof(::protocol::TMEndpoint)},
  { 218, 225, sizeof(::protocol::TMEndpoints_TMEndpointv2)},
  { 227, 235, sizeof(::protocol::TMEndpoints)},
  { 238, 248, sizeof(::protocol::TMIndexedObject)},
  { 253, 264, sizeof(::protocol::TMGetObjectByHash)},
  { 270, 277, sizeof(::protocol::TMLedgerNode)},
  { 279, 292, sizeof(::protocol::TMGetLedger)},
  { 300, 311, sizeof(::protocol::TMLedgerData)},
  { 317, 326, sizeof(::protocol::TMPing)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::protocol::_TMManifest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::protocol::_TMManifests_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::protocol::_TMClusterNode_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::protocol::_TMLoadSource_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::protocol::_TMCluster_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::protocol::_TMGetShardInfo_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::protocol::_TMShardInfo_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::protocol::_TMLink_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::protocol::_TMGetPeerShardInfo_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::protocol::_TMPeerShardInfo_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::protocol::_TMTransaction_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::protocol::_TMStatusChange_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::protocol::_TMProposeSet_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::protocol::_TMHaveTransactionSet_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::protocol::_TMValidatorList_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::protocol::_TMValidation_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::protocol::_TMIPv4Endpoint_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::protocol::_TMEndpoint_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::protocol::_TMEndpoints_TMEndpointv2_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::protocol::_TMEndpoints_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::protocol::_TMIndexedObject_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::protocol::_TMGetObjectByHash_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::protocol::_TMLedgerNode_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::protocol::_TMGetLedger_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::protocol::_TMLedgerData_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::protocol::_TMPing_default_instance_),
};

const char descriptor_table_protodef_ripple_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\014ripple.proto\022\010protocol\"\036\n\nTMManifest\022\020"
  "\n\010stobject\030\001 \002(\014\"F\n\013TMManifests\022\"\n\004list\030"
  "\001 \003(\0132\024.protocol.TMManifest\022\023\n\007history\030\002"
  " \001(\010B\002\030\001\"k\n\rTMClusterNode\022\021\n\tpublicKey\030\001"
  " \002(\t\022\022\n\nreportTime\030\002 \002(\r\022\020\n\010nodeLoad\030\003 \002"
  "(\r\022\020\n\010nodeName\030\004 \001(\t\022\017\n\007address\030\005 \001(\t\"9\n"
  "\014TMLoadSource\022\014\n\004name\030\001 \002(\t\022\014\n\004cost\030\002 \002("
  "\r\022\r\n\005count\030\003 \001(\r\"g\n\tTMCluster\022-\n\014cluster"
  "Nodes\030\001 \003(\0132\027.protocol.TMClusterNode\022+\n\013"
  "loadSources\030\002 \003(\0132\026.protocol.TMLoadSourc"
  "e\"O\n\016TMGetShardInfo\022\020\n\004hops\030\001 \002(\rB\002\030\001\022\024\n"
  "\010lastLink\030\002 \001(\010B\002\030\001\022\025\n\tpeerchain\030\003 \003(\rB\002"
  "\030\001\"\202\001\n\013TMShardInfo\022\030\n\014shardIndexes\030\001 \002(\t"
  "B\002\030\001\022\026\n\nnodePubKey\030\002 \001(\014B\002\030\001\022\024\n\010endpoint"
  "\030\003 \001(\tB\002\030\001\022\024\n\010lastLink\030\004 \001(\010B\002\030\001\022\025\n\tpeer"
  "chain\030\005 \003(\rB\002\030\001\"\034\n\006TMLink\022\022\n\nnodePubKey\030"
  "\001 \002(\014\"Y\n\022TMGetPeerShardInfo\022\014\n\004hops\030\001 \002("
  "\r\022\020\n\010lastLink\030\002 \001(\010\022#\n\tpeerChain\030\003 \003(\0132\020"
  ".protocol.TMLink\"\204\001\n\017TMPeerShardInfo\022\024\n\014"
  "shardIndexes\030\001 \002(\t\022\022\n\nnodePubKey\030\002 \001(\014\022\020"
  "\n\010endpoint\030\003 \001(\t\022\020\n\010lastLink\030\004 \001(\010\022#\n\tpe"
  "erChain\030\005 \003(\0132\020.protocol.TMLink\"\200\001\n\rTMTr"
  "ansaction\022\026\n\016rawTransaction\030\001 \002(\014\022+\n\006sta"
  "tus\030\002 \002(\0162\033.protocol.TransactionStatus\022\030"
  "\n\020receiveTimestamp\030\003 \001(\004\022\020\n\010deferred\030\004 \001"
  "(\010\"\333\001\n\016TMStatusChange\022\'\n\tnewStatus\030\001 \001(\016"
  "2\024.protocol.NodeStatus\022%\n\010newEvent\030\002 \001(\016"
  "2\023.protocol.NodeEvent\022\021\n\tledgerSeq\030\003 \001(\r"
  "\022\022\n\nledgerHash\030\004 \001(\014\022\032\n\022ledgerHashPrevio"
  "us\030\005 \001(\014\022\023\n\013networkTime\030\006 \001(\004\022\020\n\010firstSe"
  "q\030\007 \001(\r\022\017\n\007lastSeq\030\010 \001(\r\"\353\001\n\014TMProposeSe"
  "t\022\022\n\nproposeSeq\030\001 \002(\r\022\025\n\rcurrentTxHash\030\002"
  " \002(\014\022\022\n\nnodePubKey\030\003 \002(\014\022\021\n\tcloseTime\030\004 "
  "\002(\r\022\021\n\tsignature\030\005 \002(\014\022\026\n\016previousledger"
  "\030\006 \002(\014\022\030\n\020checkedSignature\030\007 \001(\010\022\031\n\021adde"
  "dTransactions\030\n \003(\014\022\033\n\023removedTransactio"
  "ns\030\013 \003(\014\022\014\n\004hops\030\014 \001(\r\"K\n\024TMHaveTransact"
  "ionSet\022%\n\006status\030\001 \002(\0162\025.protocol.TxSetS"
  "tatus\022\014\n\004hash\030\002 \002(\014\"U\n\017TMValidatorList\022\020"
  "\n\010manifest\030\001 \002(\014\022\014\n\004blob\030\002 \002(\014\022\021\n\tsignat"
  "ure\030\003 \002(\014\022\017\n\007version\030\004 \002(\r\"J\n\014TMValidati"
  "on\022\022\n\nvalidation\030\001 \002(\014\022\030\n\020checkedSignatu"
  "re\030\002 \001(\010\022\014\n\004hops\030\003 \001(\r\"0\n\016TMIPv4Endpoint"
  "\022\014\n\004ipv4\030\001 \002(\r\022\020\n\010ipv4Port\030\002 \002(\r\"B\n\nTMEn"
  "dpoint\022&\n\004ipv4\030\001 \002(\0132\030.protocol.TMIPv4En"
  "dpoint\022\014\n\004hops\030\002 \002(\r\"\261\001\n\013TMEndpoints\022\017\n\007"
  "version\030\001 \002(\r\022\'\n\tendpoints\030\002 \003(\0132\024.proto"
  "col.TMEndpoint\0228\n\014endpoints_v2\030\003 \003(\0132\".p"
  "rotocol.TMEndpoints.TMEndpointv2\032.\n\014TMEn"
  "dpointv2\022\020\n\010endpoint\030\001 \002(\t\022\014\n\004hops\030\002 \002(\r"
  "\"_\n\017TMIndexedObject\022\014\n\004hash\030\001 \001(\014\022\016\n\006nod"
  "eID\030\002 \001(\014\022\r\n\005index\030\003 \001(\014\022\014\n\004data\030\004 \001(\014\022\021"
  "\n\tledgerSeq\030\005 \001(\r\"\277\002\n\021TMGetObjectByHash\022"
  "4\n\004type\030\001 \002(\0162&.protocol.TMGetObjectByHa"
  "sh.ObjectType\022\r\n\005query\030\002 \002(\010\022\013\n\003seq\030\003 \001("
  "\r\022\022\n\nledgerHash\030\004 \001(\014\022\013\n\003fat\030\005 \001(\010\022*\n\007ob"
  "jects\030\006 \003(\0132\031.protocol.TMIndexedObject\"\212"
  "\001\n\nObjectType\022\r\n\totUNKNOWN\020\000\022\014\n\010otLEDGER"
  "\020\001\022\021\n\rotTRANSACTION\020\002\022\026\n\022otTRANSACTION_N"
  "ODE\020\003\022\020\n\014otSTATE_NODE\020\004\022\020\n\014otCAS_OBJECT\020"
  "\005\022\020\n\014otFETCH_PACK\020\006\"0\n\014TMLedgerNode\022\020\n\010n"
  "odedata\030\001 \002(\014\022\016\n\006nodeid\030\002 \001(\014\"\354\001\n\013TMGetL"
  "edger\022)\n\005itype\030\001 \002(\0162\032.protocol.TMLedger"
  "InfoType\022%\n\005ltype\030\002 \001(\0162\026.protocol.TMLed"
  "gerType\022\022\n\nledgerHash\030\003 \001(\014\022\021\n\tledgerSeq"
  "\030\004 \001(\r\022\017\n\007nodeIDs\030\005 \003(\014\022\025\n\rrequestCookie"
  "\030\006 \001(\004\022(\n\tqueryType\030\007 \001(\0162\025.protocol.TMQ"
  "ueryType\022\022\n\nqueryDepth\030\010 \001(\r\"\304\001\n\014TMLedge"
  "rData\022\022\n\nledgerHash\030\001 \002(\014\022\021\n\tledgerSeq\030\002"
  " \002(\r\022(\n\004type\030\003 \002(\0162\032.protocol.TMLedgerIn"
  "foType\022%\n\005nodes\030\004 \003(\0132\026.protocol.TMLedge"
  "rNode\022\025\n\rrequestCookie\030\005 \001(\r\022%\n\005error\030\006 "
  "\001(\0162\026.protocol.TMReplyError\"\205\001\n\006TMPing\022\'"
  "\n\004type\030\001 \002(\0162\031.protocol.TMPing.pingType\022"
  "\013\n\003seq\030\002 \001(\r\022\020\n\010pingTime\030\003 \001(\004\022\017\n\007netTim"
  "e\030\004 \001(\004\"\"\n\010pingType\022\n\n\006ptPING\020\000\022\n\n\006ptPON"
  "G\020\001*\321\002\n\013MessageType\022\017\n\013mtMANIFESTS\020\002\022\n\n\006"
  "mtPING\020\003\022\r\n\tmtCLUSTER\020\005\022\017\n\013mtENDPOINTS\020\017"
  "\022\021\n\rmtTRANSACTION\020\036\022\020\n\014mtGET_LEDGER\020\037\022\021\n"
  "\rmtLEDGER_DATA\020 \022\024\n\020mtPROPOSE_LEDGER\020!\022\023"
  "\n\017mtSTATUS_CHANGE\020\"\022\016\n\nmtHAVE_SET\020#\022\020\n\014m"
  "tVALIDATION\020)\022\021\n\rmtGET_OBJECTS\020*\022\024\n\020mtGE"
  "T_SHARD_INFO\0202\022\020\n\014mtSHARD_INFO\0203\022\031\n\025mtGE"
  "T_PEER_SHARD_INFO\0204\022\025\n\021mtPEER_SHARD_INFO"
  "\0205\022\023\n\017mtVALIDATORLIST\0206*\241\001\n\021TransactionS"
  "tatus\022\t\n\005tsNEW\020\001\022\r\n\ttsCURRENT\020\002\022\016\n\ntsCOM"
  "MITED\020\003\022\025\n\021tsREJECT_CONFLICT\020\004\022\024\n\020tsREJE"
  "CT_INVALID\020\005\022\022\n\016tsREJECT_FUNDS\020\006\022\016\n\ntsHE"
  "LD_SEQ\020\007\022\021\n\rtsHELD_LEDGER\020\010*c\n\nNodeStatu"
  "s\022\020\n\014nsCONNECTING\020\001\022\017\n\013nsCONNECTED\020\002\022\020\n\014"
  "nsMONITORING\020\003\022\020\n\014nsVALIDATING\020\004\022\016\n\nnsSH"
  "UTTING\020\005*`\n\tNodeEvent\022\024\n\020neCLOSING_LEDGE"
  "R\020\001\022\025\n\021neACCEPTED_LEDGER\020\002\022\025\n\021neSWITCHED"
  "_LEDGER\020\003\022\017\n\013neLOST_SYNC\020\004*4\n\013TxSetStatu"
  "s\022\n\n\006tsHAVE\020\001\022\r\n\ttsCAN_GET\020\002\022\n\n\006tsNEED\020\003"
  "*P\n\020TMLedgerInfoType\022\n\n\006liBASE\020\000\022\r\n\tliTX"
  "_NODE\020\001\022\r\n\tliAS_NODE\020\002\022\022\n\016liTS_CANDIDATE"
  "\020\003*;\n\014TMLedgerType\022\016\n\nltACCEPTED\020\000\022\r\n\tlt"
  "CURRENT\020\001\022\014\n\010ltCLOSED\020\002*\035\n\013TMQueryType\022\016"
  "\n\nqtINDIRECT\020\000*.\n\014TMReplyError\022\017\n\013reNO_L"
  "EDGER\020\001\022\r\n\treNO_NODE\020\002"
  ;
static const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable*const descriptor_table_ripple_2eproto_deps[1] = {
};
static ::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase*const descriptor_table_ripple_2eproto_sccs[26] = {
  &scc_info_TMCluster_ripple_2eproto.base,
  &scc_info_TMClusterNode_ripple_2eproto.base,
  &scc_info_TMEndpoint_ripple_2eproto.base,
  &scc_info_TMEndpoints_ripple_2eproto.base,
  &scc_info_TMEndpoints_TMEndpointv2_ripple_2eproto.base,
  &scc_info_TMGetLedger_ripple_2eproto.base,
  &scc_info_TMGetObjectByHash_ripple_2eproto.base,
  &scc_info_TMGetPeerShardInfo_ripple_2eproto.base,
  &scc_info_TMGetShardInfo_ripple_2eproto.base,
  &scc_info_TMHaveTransactionSet_ripple_2eproto.base,
  &scc_info_TMIPv4Endpoint_ripple_2eproto.base,
  &scc_info_TMIndexedObject_ripple_2eproto.base,
  &scc_info_TMLedgerData_ripple_2eproto.base,
  &scc_info_TMLedgerNode_ripple_2eproto.base,
  &scc_info_TMLink_ripple_2eproto.base,
  &scc_info_TMLoadSource_ripple_2eproto.base,
  &scc_info_TMManifest_ripple_2eproto.base,
  &scc_info_TMManifests_ripple_2eproto.base,
  &scc_info_TMPeerShardInfo_ripple_2eproto.base,
  &scc_info_TMPing_ripple_2eproto.base,
  &scc_info_TMProposeSet_ripple_2eproto.base,
  &scc_info_TMShardInfo_ripple_2eproto.base,
  &scc_info_TMStatusChange_ripple_2eproto.base,
  &scc_info_TMTransaction_ripple_2eproto.base,
  &scc_info_TMValidation_ripple_2eproto.base,
  &scc_info_TMValidatorList_ripple_2eproto.base,
};
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_ripple_2eproto_once;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_ripple_2eproto = {
  false, false, descriptor_table_protodef_ripple_2eproto, "ripple.proto", 4022,
  &descriptor_table_ripple_2eproto_once, descriptor_table_ripple_2eproto_sccs, descriptor_table_ripple_2eproto_deps, 26, 0,
  schemas, file_default_instances, TableStruct_ripple_2eproto::offsets,
  file_level_metadata_ripple_2eproto, 26, file_level_enum_descriptors_ripple_2eproto, file_level_service_descriptors_ripple_2eproto,
};

// Force running AddDescriptors() at dynamic initialization time.
static bool dynamic_init_dummy_ripple_2eproto = (static_cast<void>(::PROTOBUF_NAMESPACE_ID::internal::AddDescriptors(&descriptor_table_ripple_2eproto)), true);
namespace protocol {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TMGetObjectByHash_ObjectType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_ripple_2eproto);
  return file_level_enum_descriptors_ripple_2eproto[0];
}
bool TMGetObjectByHash_ObjectType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr TMGetObjectByHash_ObjectType TMGetObjectByHash::otUNKNOWN;
constexpr TMGetObjectByHash_ObjectType TMGetObjectByHash::otLEDGER;
constexpr TMGetObjectByHash_ObjectType TMGetObjectByHash::otTRANSACTION;
constexpr TMGetObjectByHash_ObjectType TMGetObjectByHash::otTRANSACTION_NODE;
constexpr TMGetObjectByHash_ObjectType TMGetObjectByHash::otSTATE_NODE;
constexpr TMGetObjectByHash_ObjectType TMGetObjectByHash::otCAS_OBJECT;
constexpr TMGetObjectByHash_ObjectType TMGetObjectByHash::otFETCH_PACK;
constexpr TMGetObjectByHash_ObjectType TMGetObjectByHash::ObjectType_MIN;
constexpr TMGetObjectByHash_ObjectType TMGetObjectByHash::ObjectType_MAX;
constexpr int TMGetObjectByHash::ObjectType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TMPing_pingType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_ripple_2eproto);
  return file_level_enum_descriptors_ripple_2eproto[1];
}
bool TMPing_pingType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr TMPing_pingType TMPing::ptPING;
constexpr TMPing_pingType TMPing::ptPONG;
constexpr TMPing_pingType TMPing::pingType_MIN;
constexpr TMPing_pingType TMPing::pingType_MAX;
constexpr int TMPing::pingType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MessageType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_ripple_2eproto);
  return file_level_enum_descriptors_ripple_2eproto[2];
}
bool MessageType_IsValid(int value) {
  switch (value) {
    case 2:
    case 3:
    case 5:
    case 15:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
    case 35:
    case 41:
    case 42:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TransactionStatus_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_ripple_2eproto);
  return file_level_enum_descriptors_ripple_2eproto[3];
}
bool TransactionStatus_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* NodeStatus_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_ripple_2eproto);
  return file_level_enum_descriptors_ripple_2eproto[4];
}
bool NodeStatus_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* NodeEvent_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_ripple_2eproto);
  return file_level_enum_descriptors_ripple_2eproto[5];
}
bool NodeEvent_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TxSetStatus_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_ripple_2eproto);
  return file_level_enum_descriptors_ripple_2eproto[6];
}
bool TxSetStatus_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TMLedgerInfoType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_ripple_2eproto);
  return file_level_enum_descriptors_ripple_2eproto[7];
}
bool TMLedgerInfoType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TMLedgerType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_ripple_2eproto);
  return file_level_enum_descriptors_ripple_2eproto[8];
}
bool TMLedgerType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TMQueryType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_ripple_2eproto);
  return file_level_enum_descriptors_ripple_2eproto[9];
}
bool TMQueryType_IsValid(int value) {
  switch (value) {
    case 0:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TMReplyError_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_ripple_2eproto);
  return file_level_enum_descriptors_ripple_2eproto[10];
}
bool TMReplyError_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}


// ===================================================================

void TMManifest::InitAsDefaultInstance() {
}
class TMManifest::_Internal {
 public:
  using HasBits = decltype(std::declval<TMManifest>()._has_bits_);
  static void set_has_stobject(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

TMManifest::TMManifest(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:protocol.TMManifest)
}
TMManifest::TMManifest(const TMManifest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  stobject_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_stobject()) {
    stobject_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_stobject(),
      GetArena());
  }
  // @@protoc_insertion_point(copy_constructor:protocol.TMManifest)
}

void TMManifest::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_TMManifest_ripple_2eproto.base);
  stobject_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

TMManifest::~TMManifest() {
  // @@protoc_insertion_point(destructor:protocol.TMManifest)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void TMManifest::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  stobject_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void TMManifest::ArenaDtor(void* object) {
  TMManifest* _this = reinterpret_cast< TMManifest* >(object);
  (void)_this;
}
void TMManifest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TMManifest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TMManifest& TMManifest::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TMManifest_ripple_2eproto.base);
  return *internal_default_instance();
}


void TMManifest::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMManifest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    stobject_.ClearNonDefaultToEmpty();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TMManifest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required bytes stobject = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_stobject();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* TMManifest::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMManifest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required bytes stobject = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_stobject(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMManifest)
  return target;
}

size_t TMManifest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMManifest)
  size_t total_size = 0;

  // required bytes stobject = 1;
  if (_internal_has_stobject()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_stobject());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TMManifest::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protocol.TMManifest)
  GOOGLE_DCHECK_NE(&from, this);
  const TMManifest* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<TMManifest>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protocol.TMManifest)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protocol.TMManifest)
    MergeFrom(*source);
  }
}

void TMManifest::MergeFrom(const TMManifest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMManifest)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_stobject()) {
    _internal_set_stobject(from._internal_stobject());
  }
}

void TMManifest::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protocol.TMManifest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMManifest::CopyFrom(const TMManifest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMManifest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMManifest::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void TMManifest::InternalSwap(TMManifest* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  stobject_.Swap(&other->stobject_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}

::PROTOBUF_NAMESPACE_ID::Metadata TMManifest::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void TMManifests::InitAsDefaultInstance() {
}
class TMManifests::_Internal {
 public:
  using HasBits = decltype(std::declval<TMManifests>()._has_bits_);
  static void set_has_history(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

TMManifests::TMManifests(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  list_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:protocol.TMManifests)
}
TMManifests::TMManifests(const TMManifests& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      list_(from.list_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  history_ = from.history_;
  // @@protoc_insertion_point(copy_constructor:protocol.TMManifests)
}

void TMManifests::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_TMManifests_ripple_2eproto.base);
  history_ = false;
}

TMManifests::~TMManifests() {
  // @@protoc_insertion_point(destructor:protocol.TMManifests)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void TMManifests::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void TMManifests::ArenaDtor(void* object) {
  TMManifests* _this = reinterpret_cast< TMManifests* >(object);
  (void)_this;
}
void TMManifests::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TMManifests::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TMManifests& TMManifests::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TMManifests_ripple_2eproto.base);
  return *internal_default_instance();
}


void TMManifests::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMManifests)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  list_.Clear();
  history_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TMManifests::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated .protocol.TMManifest list = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_list(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else goto handle_unusual;
        continue;
      // optional bool history = 2 [deprecated = true];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_history(&has_bits);
          history_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* TMManifests::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMManifests)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .protocol.TMManifest list = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_list_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_list(i), target, stream);
  }

  cached_has_bits = _has_bits_[0];
  // optional bool history = 2 [deprecated = true];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->_internal_history(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMManifests)
  return target;
}

size_t TMManifests::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMManifests)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .protocol.TMManifest list = 1;
  total_size += 1UL * this->_internal_list_size();
  for (const auto& msg : this->list_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional bool history = 2 [deprecated = true];
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TMManifests::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protocol.TMManifests)
  GOOGLE_DCHECK_NE(&from, this);
  const TMManifests* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<TMManifests>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protocol.TMManifests)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protocol.TMManifests)
    MergeFrom(*source);
  }
}

void TMManifests::MergeFrom(const TMManifests& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMManifests)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  list_.MergeFrom(from.list_);
  if (from._internal_has_history()) {
    _internal_set_history(from._internal_history());
  }
}

void TMManifests::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protocol.TMManifests)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMManifests::CopyFrom(const TMManifests& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMManifests)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMManifests::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(list_)) return false;
  return true;
}

void TMManifests::InternalSwap(TMManifests* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  list_.InternalSwap(&other->list_);
  swap(history_, other->history_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TMManifests::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void TMClusterNode::InitAsDefaultInstance() {
}
class TMClusterNode::_Internal {
 public:
  using HasBits = decltype(std::declval<TMClusterNode>()._has_bits_);
  static void set_has_publickey(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_reporttime(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_nodeload(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_nodename(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_address(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000019) ^ 0x00000019) != 0;
  }
};

TMClusterNode::TMClusterNode(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:protocol.TMClusterNode)
}
TMClusterNode::TMClusterNode(const TMClusterNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  publickey_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_publickey()) {
    publickey_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_publickey(),
      GetArena());
  }
  nodename_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_nodename()) {
    nodename_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_nodename(),
      GetArena());
  }
  address_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_address()) {
    address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_address(),
      GetArena());
  }
  ::memcpy(&reporttime_, &from.reporttime_,
    static_cast<size_t>(reinterpret_cast<char*>(&nodeload_) -
    reinterpret_cast<char*>(&reporttime_)) + sizeof(nodeload_));
  // @@protoc_insertion_point(copy_constructor:protocol.TMClusterNode)
}

void TMClusterNode::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_TMClusterNode_ripple_2eproto.base);
  publickey_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  nodename_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  address_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&reporttime_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&nodeload_) -
      reinterpret_cast<char*>(&reporttime_)) + sizeof(nodeload_));
}

TMClusterNode::~TMClusterNode() {
  // @@protoc_insertion_point(destructor:protocol.TMClusterNode)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void TMClusterNode::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  publickey_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  nodename_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  address_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void TMClusterNode::ArenaDtor(void* object) {
  TMClusterNode* _this = reinterpret_cast< TMClusterNode* >(object);
  (void)_this;
}
void TMClusterNode::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TMClusterNode::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TMClusterNode& TMClusterNode::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TMClusterNode_ripple_2eproto.base);
  return *internal_default_instance();
}


void TMClusterNode::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMClusterNode)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      publickey_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      nodename_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      address_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x00000018u) {
    ::memset(&reporttime_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&nodeload_) -
        reinterpret_cast<char*>(&reporttime_)) + sizeof(nodeload_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TMClusterNode::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required string publicKey = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_publickey();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "protocol.TMClusterNode.publicKey");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required uint32 reportTime = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_reporttime(&has_bits);
          reporttime_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required uint32 nodeLoad = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_nodeload(&has_bits);
          nodeload_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string nodeName = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          auto str = _internal_mutable_nodename();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "protocol.TMClusterNode.nodeName");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string address = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          auto str = _internal_mutable_address();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "protocol.TMClusterNode.address");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* TMClusterNode::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMClusterNode)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string publicKey = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_publickey().data(), static_cast<int>(this->_internal_publickey().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "protocol.TMClusterNode.publicKey");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_publickey(), target);
  }

  // required uint32 reportTime = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_reporttime(), target);
  }

  // required uint32 nodeLoad = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_nodeload(), target);
  }

  // optional string nodeName = 4;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_nodename().data(), static_cast<int>(this->_internal_nodename().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "protocol.TMClusterNode.nodeName");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_nodename(), target);
  }

  // optional string address = 5;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_address().data(), static_cast<int>(this->_internal_address().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "protocol.TMClusterNode.address");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_address(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMClusterNode)
  return target;
}

size_t TMClusterNode::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:protocol.TMClusterNode)
  size_t total_size = 0;

  if (_internal_has_publickey()) {
    // required string publicKey = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_publickey());
  }

  if (_internal_has_reporttime()) {
    // required uint32 reportTime = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_reporttime());
  }

  if (_internal_has_nodeload()) {
    // required uint32 nodeLoad = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_nodeload());
  }

  return total_size;
}
size_t TMClusterNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMClusterNode)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000019) ^ 0x00000019) == 0) {  // All required fields are present.
    // required string publicKey = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_publickey());

    // required uint32 reportTime = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_reporttime());

    // required uint32 nodeLoad = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_nodeload());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000006u) {
    // optional string nodeName = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_nodename());
    }

    // optional string address = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_address());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TMClusterNode::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protocol.TMClusterNode)
  GOOGLE_DCHECK_NE(&from, this);
  const TMClusterNode* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<TMClusterNode>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protocol.TMClusterNode)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protocol.TMClusterNode)
    MergeFrom(*source);
  }
}

void TMClusterNode::MergeFrom(const TMClusterNode& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMClusterNode)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_publickey(from._internal_publickey());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_nodename(from._internal_nodename());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_address(from._internal_address());
    }
    if (cached_has_bits & 0x00000008u) {
      reporttime_ = from.reporttime_;
    }
    if (cached_has_bits & 0x00000010u) {
      nodeload_ = from.nodeload_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void TMClusterNode::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protocol.TMClusterNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMClusterNode::CopyFrom(const TMClusterNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMClusterNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMClusterNode::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void TMClusterNode::InternalSwap(TMClusterNode* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  publickey_.Swap(&other->publickey_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  nodename_.Swap(&other->nodename_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  address_.Swap(&other->address_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TMClusterNode, nodeload_)
      + sizeof(TMClusterNode::nodeload_)
      - PROTOBUF_FIELD_OFFSET(TMClusterNode, reporttime_)>(
          reinterpret_cast<char*>(&reporttime_),
          reinterpret_cast<char*>(&other->reporttime_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TMClusterNode::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void TMLoadSource::InitAsDefaultInstance() {
}
class TMLoadSource::_Internal {
 public:
  using HasBits = decltype(std::declval<TMLoadSource>()._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_cost(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_count(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

TMLoadSource::TMLoadSource(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:protocol.TMLoadSource)
}
TMLoadSource::TMLoadSource(const TMLoadSource& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_name()) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_name(),
      GetArena());
  }
  ::memcpy(&cost_, &from.cost_,
    static_cast<size_t>(reinterpret_cast<char*>(&count_) -
    reinterpret_cast<char*>(&cost_)) + sizeof(count_));
  // @@protoc_insertion_point(copy_constructor:protocol.TMLoadSource)
}

void TMLoadSource::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_TMLoadSource_ripple_2eproto.base);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&cost_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&count_) -
      reinterpret_cast<char*>(&cost_)) + sizeof(count_));
}

TMLoadSource::~TMLoadSource() {
  // @@protoc_insertion_point(destructor:protocol.TMLoadSource)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void TMLoadSource::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void TMLoadSource::ArenaDtor(void* object) {
  TMLoadSource* _this = reinterpret_cast< TMLoadSource* >(object);
  (void)_this;
}
void TMLoadSource::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TMLoadSource::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TMLoadSource& TMLoadSource::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TMLoadSource_ripple_2eproto.base);
  return *internal_default_instance();
}


void TMLoadSource::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMLoadSource)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    name_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&cost_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&count_) -
        reinterpret_cast<char*>(&cost_)) + sizeof(count_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TMLoadSource::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "protocol.TMLoadSource.name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required uint32 cost = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_cost(&has_bits);
          cost_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 count = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_count(&has_bits);
          count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* TMLoadSource::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMLoadSource)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "protocol.TMLoadSource.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // required uint32 cost = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_cost(), target);
  }

  // optional uint32 count = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_count(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMLoadSource)
  return target;
}

size_t TMLoadSource::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:protocol.TMLoadSource)
  size_t total_size = 0;

  if (_internal_has_name()) {
    // required string name = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  if (_internal_has_cost()) {
    // required uint32 cost = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_cost());
  }

  return total_size;
}
size_t TMLoadSource::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMLoadSource)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required string name = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());

    // required uint32 cost = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_cost());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint32 count = 3;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000004u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_count());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TMLoadSource::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protocol.TMLoadSource)
  GOOGLE_DCHECK_NE(&from, this);
  const TMLoadSource* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<TMLoadSource>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protocol.TMLoadSource)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protocol.TMLoadSource)
    MergeFrom(*source);
  }
}

void TMLoadSource::MergeFrom(const TMLoadSource& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMLoadSource)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      cost_ = from.cost_;
    }
    if (cached_has_bits & 0x00000004u) {
      count_ = from.count_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void TMLoadSource::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protocol.TMLoadSource)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMLoadSource::CopyFrom(const TMLoadSource& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMLoadSource)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMLoadSource::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void TMLoadSource::InternalSwap(TMLoadSource* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  name_.Swap(&other->name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TMLoadSource, count_)
      + sizeof(TMLoadSource::count_)
      - PROTOBUF_FIELD_OFFSET(TMLoadSource, cost_)>(
          reinterpret_cast<char*>(&cost_),
          reinterpret_cast<char*>(&other->cost_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TMLoadSource::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void TMCluster::InitAsDefaultInstance() {
}
class TMCluster::_Internal {
 public:
};

TMCluster::TMCluster(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  clusternodes_(arena),
  loadsources_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:protocol.TMCluster)
}
TMCluster::TMCluster(const TMCluster& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      clusternodes_(from.clusternodes_),
      loadsources_(from.loadsources_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:protocol.TMCluster)
}

void TMCluster::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_TMCluster_ripple_2eproto.base);
}

TMCluster::~TMCluster() {
  // @@protoc_insertion_point(destructor:protocol.TMCluster)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void TMCluster::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void TMCluster::ArenaDtor(void* object) {
  TMCluster* _this = reinterpret_cast< TMCluster* >(object);
  (void)_this;
}
void TMCluster::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TMCluster::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TMCluster& TMCluster::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TMCluster_ripple_2eproto.base);
  return *internal_default_instance();
}


void TMCluster::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMCluster)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clusternodes_.Clear();
  loadsources_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TMCluster::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated .protocol.TMClusterNode clusterNodes = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_clusternodes(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else goto handle_unusual;
        continue;
      // repeated .protocol.TMLoadSource loadSources = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_loadsources(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* TMCluster::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMCluster)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .protocol.TMClusterNode clusterNodes = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_clusternodes_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_clusternodes(i), target, stream);
  }

  // repeated .protocol.TMLoadSource loadSources = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_loadsources_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, this->_internal_loadsources(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMCluster)
  return target;
}

size_t TMCluster::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMCluster)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .protocol.TMClusterNode clusterNodes = 1;
  total_size += 1UL * this->_internal_clusternodes_size();
  for (const auto& msg : this->clusternodes_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .protocol.TMLoadSource loadSources = 2;
  total_size += 1UL * this->_internal_loadsources_size();
  for (const auto& msg : this->loadsources_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TMCluster::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protocol.TMCluster)
  GOOGLE_DCHECK_NE(&from, this);
  const TMCluster* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<TMCluster>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protocol.TMCluster)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protocol.TMCluster)
    MergeFrom(*source);
  }
}

void TMCluster::MergeFrom(const TMCluster& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMCluster)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  clusternodes_.MergeFrom(from.clusternodes_);
  loadsources_.MergeFrom(from.loadsources_);
}

void TMCluster::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protocol.TMCluster)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMCluster::CopyFrom(const TMCluster& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMCluster)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMCluster::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(clusternodes_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(loadsources_)) return false;
  return true;
}

void TMCluster::InternalSwap(TMCluster* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  clusternodes_.InternalSwap(&other->clusternodes_);
  loadsources_.InternalSwap(&other->loadsources_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TMCluster::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void TMGetShardInfo::InitAsDefaultInstance() {
}
class TMGetShardInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<TMGetShardInfo>()._has_bits_);
  static void set_has_hops(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_lastlink(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

TMGetShardInfo::TMGetShardInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  peerchain_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:protocol.TMGetShardInfo)
}
TMGetShardInfo::TMGetShardInfo(const TMGetShardInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      peerchain_(from.peerchain_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&hops_, &from.hops_,
    static_cast<size_t>(reinterpret_cast<char*>(&lastlink_) -
    reinterpret_cast<char*>(&hops_)) + sizeof(lastlink_));
  // @@protoc_insertion_point(copy_constructor:protocol.TMGetShardInfo)
}

void TMGetShardInfo::SharedCtor() {
  ::memset(&hops_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&lastlink_) -
      reinterpret_cast<char*>(&hops_)) + sizeof(lastlink_));
}

TMGetShardInfo::~TMGetShardInfo() {
  // @@protoc_insertion_point(destructor:protocol.TMGetShardInfo)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void TMGetShardInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void TMGetShardInfo::ArenaDtor(void* object) {
  TMGetShardInfo* _this = reinterpret_cast< TMGetShardInfo* >(object);
  (void)_this;
}
void TMGetShardInfo::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TMGetShardInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TMGetShardInfo& TMGetShardInfo::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TMGetShardInfo_ripple_2eproto.base);
  return *internal_default_instance();
}


void TMGetShardInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMGetShardInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  peerchain_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&hops_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&lastlink_) -
        reinterpret_cast<char*>(&hops_)) + sizeof(lastlink_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TMGetShardInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required uint32 hops = 1 [deprecated = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_hops(&has_bits);
          hops_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool lastLink = 2 [deprecated = true];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_lastlink(&has_bits);
          lastlink_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated uint32 peerchain = 3 [deprecated = true];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_peerchain(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<24>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_peerchain(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* TMGetShardInfo::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMGetShardInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 hops = 1 [deprecated = true];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_hops(), target);
  }

  // optional bool lastLink = 2 [deprecated = true];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->_internal_lastlink(), target);
  }

  // repeated uint32 peerchain = 3 [deprecated = true];
  for (int i = 0, n = this->_internal_peerchain_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_peerchain(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMGetShardInfo)
  return target;
}

size_t TMGetShardInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMGetShardInfo)
  size_t total_size = 0;

  // required uint32 hops = 1 [deprecated = true];
  if (_internal_has_hops()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_hops());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 peerchain = 3 [deprecated = true];
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      UInt32Size(this->peerchain_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_peerchain_size());
    total_size += data_size;
  }

  // optional bool lastLink = 2 [deprecated = true];
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000002u) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TMGetShardInfo::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protocol.TMGetShardInfo)
  GOOGLE_DCHECK_NE(&from, this);
  const TMGetShardInfo* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<TMGetShardInfo>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protocol.TMGetShardInfo)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protocol.TMGetShardInfo)
    MergeFrom(*source);
  }
}

void TMGetShardInfo::MergeFrom(const TMGetShardInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMGetShardInfo)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  peerchain_.MergeFrom(from.peerchain_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      hops_ = from.hops_;
    }
    if (cached_has_bits & 0x00000002u) {
      lastlink_ = from.lastlink_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void TMGetShardInfo::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protocol.TMGetShardInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMGetShardInfo::CopyFrom(const TMGetShardInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMGetShardInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMGetShardInfo::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void TMGetShardInfo::InternalSwap(TMGetShardInfo* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  peerchain_.InternalSwap(&other->peerchain_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TMGetShardInfo, lastlink_)
      + sizeof(TMGetShardInfo::lastlink_)
      - PROTOBUF_FIELD_OFFSET(TMGetShardInfo, hops_)>(
          reinterpret_cast<char*>(&hops_),
          reinterpret_cast<char*>(&other->hops_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TMGetShardInfo::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void TMShardInfo::InitAsDefaultInstance() {
}
class TMShardInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<TMShardInfo>()._has_bits_);
  static void set_has_shardindexes(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_nodepubkey(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_endpoint(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_lastlink(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

TMShardInfo::TMShardInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  peerchain_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:protocol.TMShardInfo)
}
TMShardInfo::TMShardInfo(const TMShardInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      peerchain_(from.peerchain_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  shardindexes_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_shardindexes()) {
    shardindexes_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_shardindexes(),
      GetArena());
  }
  nodepubkey_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_nodepubkey()) {
    nodepubkey_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_nodepubkey(),
      GetArena());
  }
  endpoint_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_endpoint()) {
    endpoint_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_endpoint(),
      GetArena());
  }
  lastlink_ = from.lastlink_;
  // @@protoc_insertion_point(copy_constructor:protocol.TMShardInfo)
}

void TMShardInfo::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_TMShardInfo_ripple_2eproto.base);
  shardindexes_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  nodepubkey_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  endpoint_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  lastlink_ = false;
}

TMShardInfo::~TMShardInfo() {
  // @@protoc_insertion_point(destructor:protocol.TMShardInfo)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void TMShardInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  shardindexes_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  nodepubkey_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  endpoint_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void TMShardInfo::ArenaDtor(void* object) {
  TMShardInfo* _this = reinterpret_cast< TMShardInfo* >(object);
  (void)_this;
}
void TMShardInfo::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TMShardInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TMShardInfo& TMShardInfo::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TMShardInfo_ripple_2eproto.base);
  return *internal_default_instance();
}


void TMShardInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMShardInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  peerchain_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      shardindexes_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      nodepubkey_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      endpoint_.ClearNonDefaultToEmpty();
    }
  }
  lastlink_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TMShardInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required string shardIndexes = 1 [deprecated = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_shardindexes();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "protocol.TMShardInfo.shardIndexes");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bytes nodePubKey = 2 [deprecated = true];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_nodepubkey();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string endpoint = 3 [deprecated = true];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          auto str = _internal_mutable_endpoint();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "protocol.TMShardInfo.endpoint");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool lastLink = 4 [deprecated = true];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_lastlink(&has_bits);
          lastlink_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated uint32 peerchain = 5 [deprecated = true];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_peerchain(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<40>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_peerchain(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* TMShardInfo::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMShardInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string shardIndexes = 1 [deprecated = true];
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_shardindexes().data(), static_cast<int>(this->_internal_shardindexes().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "protocol.TMShardInfo.shardIndexes");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_shardindexes(), target);
  }

  // optional bytes nodePubKey = 2 [deprecated = true];
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_nodepubkey(), target);
  }

  // optional string endpoint = 3 [deprecated = true];
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_endpoint().data(), static_cast<int>(this->_internal_endpoint().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "protocol.TMShardInfo.endpoint");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_endpoint(), target);
  }

  // optional bool lastLink = 4 [deprecated = true];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(4, this->_internal_lastlink(), target);
  }

  // repeated uint32 peerchain = 5 [deprecated = true];
  for (int i = 0, n = this->_internal_peerchain_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(5, this->_internal_peerchain(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMShardInfo)
  return target;
}

size_t TMShardInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMShardInfo)
  size_t total_size = 0;

  // required string shardIndexes = 1 [deprecated = true];
  if (_internal_has_shardindexes()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_shardindexes());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 peerchain = 5 [deprecated = true];
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      UInt32Size(this->peerchain_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_peerchain_size());
    total_size += data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000eu) {
    // optional bytes nodePubKey = 2 [deprecated = true];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_nodepubkey());
    }

    // optional string endpoint = 3 [deprecated = true];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_endpoint());
    }

    // optional bool lastLink = 4 [deprecated = true];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TMShardInfo::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protocol.TMShardInfo)
  GOOGLE_DCHECK_NE(&from, this);
  const TMShardInfo* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<TMShardInfo>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protocol.TMShardInfo)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protocol.TMShardInfo)
    MergeFrom(*source);
  }
}

void TMShardInfo::MergeFrom(const TMShardInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMShardInfo)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  peerchain_.MergeFrom(from.peerchain_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_shardindexes(from._internal_shardindexes());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_nodepubkey(from._internal_nodepubkey());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_endpoint(from._internal_endpoint());
    }
    if (cached_has_bits & 0x00000008u) {
      lastlink_ = from.lastlink_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void TMShardInfo::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protocol.TMShardInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMShardInfo::CopyFrom(const TMShardInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMShardInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMShardInfo::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void TMShardInfo::InternalSwap(TMShardInfo* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  peerchain_.InternalSwap(&other->peerchain_);
  shardindexes_.Swap(&other->shardindexes_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  nodepubkey_.Swap(&other->nodepubkey_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  endpoint_.Swap(&other->endpoint_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  swap(lastlink_, other->lastlink_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TMShardInfo::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void TMLink::InitAsDefaultInstance() {
}
class TMLink::_Internal {
 public:
  using HasBits = decltype(std::declval<TMLink>()._has_bits_);
  static void set_has_nodepubkey(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

TMLink::TMLink(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:protocol.TMLink)
}
TMLink::TMLink(const TMLink& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  nodepubkey_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_nodepubkey()) {
    nodepubkey_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_nodepubkey(),
      GetArena());
  }
  // @@protoc_insertion_point(copy_constructor:protocol.TMLink)
}

void TMLink::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_TMLink_ripple_2eproto.base);
  nodepubkey_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

TMLink::~TMLink() {
  // @@protoc_insertion_point(destructor:protocol.TMLink)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void TMLink::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  nodepubkey_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void TMLink::ArenaDtor(void* object) {
  TMLink* _this = reinterpret_cast< TMLink* >(object);
  (void)_this;
}
void TMLink::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TMLink::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TMLink& TMLink::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TMLink_ripple_2eproto.base);
  return *internal_default_instance();
}


void TMLink::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMLink)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    nodepubkey_.ClearNonDefaultToEmpty();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TMLink::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required bytes nodePubKey = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_nodepubkey();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* TMLink::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMLink)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required bytes nodePubKey = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_nodepubkey(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMLink)
  return target;
}

size_t TMLink::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMLink)
  size_t total_size = 0;

  // required bytes nodePubKey = 1;
  if (_internal_has_nodepubkey()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_nodepubkey());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TMLink::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protocol.TMLink)
  GOOGLE_DCHECK_NE(&from, this);
  const TMLink* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<TMLink>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protocol.TMLink)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protocol.TMLink)
    MergeFrom(*source);
  }
}

void TMLink::MergeFrom(const TMLink& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMLink)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_nodepubkey()) {
    _internal_set_nodepubkey(from._internal_nodepubkey());
  }
}

void TMLink::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protocol.TMLink)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMLink::CopyFrom(const TMLink& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMLink)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMLink::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void TMLink::InternalSwap(TMLink* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  nodepubkey_.Swap(&other->nodepubkey_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}

::PROTOBUF_NAMESPACE_ID::Metadata TMLink::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void TMGetPeerShardInfo::InitAsDefaultInstance() {
}
class TMGetPeerShardInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<TMGetPeerShardInfo>()._has_bits_);
  static void set_has_hops(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_lastlink(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

TMGetPeerShardInfo::TMGetPeerShardInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  peerchain_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:protocol.TMGetPeerShardInfo)
}
TMGetPeerShardInfo::TMGetPeerShardInfo(const TMGetPeerShardInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      peerchain_(from.peerchain_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&hops_, &from.hops_,
    static_cast<size_t>(reinterpret_cast<char*>(&lastlink_) -
    reinterpret_cast<char*>(&hops_)) + sizeof(lastlink_));
  // @@protoc_insertion_point(copy_constructor:protocol.TMGetPeerShardInfo)
}

void TMGetPeerShardInfo::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_TMGetPeerShardInfo_ripple_2eproto.base);
  ::memset(&hops_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&lastlink_) -
      reinterpret_cast<char*>(&hops_)) + sizeof(lastlink_));
}

TMGetPeerShardInfo::~TMGetPeerShardInfo() {
  // @@protoc_insertion_point(destructor:protocol.TMGetPeerShardInfo)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void TMGetPeerShardInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void TMGetPeerShardInfo::ArenaDtor(void* object) {
  TMGetPeerShardInfo* _this = reinterpret_cast< TMGetPeerShardInfo* >(object);
  (void)_this;
}
void TMGetPeerShardInfo::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TMGetPeerShardInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TMGetPeerShardInfo& TMGetPeerShardInfo::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TMGetPeerShardInfo_ripple_2eproto.base);
  return *internal_default_instance();
}


void TMGetPeerShardInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMGetPeerShardInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  peerchain_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&hops_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&lastlink_) -
        reinterpret_cast<char*>(&hops_)) + sizeof(lastlink_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TMGetPeerShardInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required uint32 hops = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_hops(&has_bits);
          hops_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool lastLink = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_lastlink(&has_bits);
          lastlink_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .protocol.TMLink peerChain = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_peerchain(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* TMGetPeerShardInfo::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMGetPeerShardInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 hops = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_hops(), target);
  }

  // optional bool lastLink = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->_internal_lastlink(), target);
  }

  // repeated .protocol.TMLink peerChain = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_peerchain_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, this->_internal_peerchain(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMGetPeerShardInfo)
  return target;
}

size_t TMGetPeerShardInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMGetPeerShardInfo)
  size_t total_size = 0;

  // required uint32 hops = 1;
  if (_internal_has_hops()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_hops());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .protocol.TMLink peerChain = 3;
  total_size += 1UL * this->_internal_peerchain_size();
  for (const auto& msg : this->peerchain_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional bool lastLink = 2;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000002u) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TMGetPeerShardInfo::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protocol.TMGetPeerShardInfo)
  GOOGLE_DCHECK_NE(&from, this);
  const TMGetPeerShardInfo* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<TMGetPeerShardInfo>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protocol.TMGetPeerShardInfo)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protocol.TMGetPeerShardInfo)
    MergeFrom(*source);
  }
}

void TMGetPeerShardInfo::MergeFrom(const TMGetPeerShardInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMGetPeerShardInfo)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  peerchain_.MergeFrom(from.peerchain_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      hops_ = from.hops_;
    }
    if (cached_has_bits & 0x00000002u) {
      lastlink_ = from.lastlink_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void TMGetPeerShardInfo::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protocol.TMGetPeerShardInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMGetPeerShardInfo::CopyFrom(const TMGetPeerShardInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMGetPeerShardInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMGetPeerShardInfo::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(peerchain_)) return false;
  return true;
}

void TMGetPeerShardInfo::InternalSwap(TMGetPeerShardInfo* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  peerchain_.InternalSwap(&other->peerchain_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TMGetPeerShardInfo, lastlink_)
      + sizeof(TMGetPeerShardInfo::lastlink_)
      - PROTOBUF_FIELD_OFFSET(TMGetPeerShardInfo, hops_)>(
          reinterpret_cast<char*>(&hops_),
          reinterpret_cast<char*>(&other->hops_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TMGetPeerShardInfo::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void TMPeerShardInfo::InitAsDefaultInstance() {
}
class TMPeerShardInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<TMPeerShardInfo>()._has_bits_);
  static void set_has_shardindexes(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_nodepubkey(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_endpoint(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_lastlink(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

TMPeerShardInfo::TMPeerShardInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  peerchain_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:protocol.TMPeerShardInfo)
}
TMPeerShardInfo::TMPeerShardInfo(const TMPeerShardInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      peerchain_(from.peerchain_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  shardindexes_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_shardindexes()) {
    shardindexes_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_shardindexes(),
      GetArena());
  }
  nodepubkey_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_nodepubkey()) {
    nodepubkey_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_nodepubkey(),
      GetArena());
  }
  endpoint_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_endpoint()) {
    endpoint_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_endpoint(),
      GetArena());
  }
  lastlink_ = from.lastlink_;
  // @@protoc_insertion_point(copy_constructor:protocol.TMPeerShardInfo)
}

void TMPeerShardInfo::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_TMPeerShardInfo_ripple_2eproto.base);
  shardindexes_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  nodepubkey_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  endpoint_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  lastlink_ = false;
}

TMPeerShardInfo::~TMPeerShardInfo() {
  // @@protoc_insertion_point(destructor:protocol.TMPeerShardInfo)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void TMPeerShardInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  shardindexes_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  nodepubkey_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  endpoint_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void TMPeerShardInfo::ArenaDtor(void* object) {
  TMPeerShardInfo* _this = reinterpret_cast< TMPeerShardInfo* >(object);
  (void)_this;
}
void TMPeerShardInfo::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TMPeerShardInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TMPeerShardInfo& TMPeerShardInfo::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TMPeerShardInfo_ripple_2eproto.base);
  return *internal_default_instance();
}


void TMPeerShardInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMPeerShardInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  peerchain_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      shardindexes_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      nodepubkey_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      endpoint_.ClearNonDefaultToEmpty();
    }
  }
  lastlink_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TMPeerShardInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required string shardIndexes = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_shardindexes();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "protocol.TMPeerShardInfo.shardIndexes");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bytes nodePubKey = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_nodepubkey();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string endpoint = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          auto str = _internal_mutable_endpoint();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "protocol.TMPeerShardInfo.endpoint");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool lastLink = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_lastlink(&has_bits);
          lastlink_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .protocol.TMLink peerChain = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_peerchain(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* TMPeerShardInfo::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMPeerShardInfo)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string shardIndexes = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_shardindexes().data(), static_cast<int>(this->_internal_shardindexes().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "protocol.TMPeerShardInfo.shardIndexes");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_shardindexes(), target);
  }

  // optional bytes nodePubKey = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_nodepubkey(), target);
  }

  // optional string endpoint = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_endpoint().data(), static_cast<int>(this->_internal_endpoint().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "protocol.TMPeerShardInfo.endpoint");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_endpoint(), target);
  }

  // optional bool lastLink = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(4, this->_internal_lastlink(), target);
  }

  // repeated .protocol.TMLink peerChain = 5;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_peerchain_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, this->_internal_peerchain(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMPeerShardInfo)
  return target;
}

size_t TMPeerShardInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMPeerShardInfo)
  size_t total_size = 0;

  // required string shardIndexes = 1;
  if (_internal_has_shardindexes()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_shardindexes());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .protocol.TMLink peerChain = 5;
  total_size += 1UL * this->_internal_peerchain_size();
  for (const auto& msg : this->peerchain_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000eu) {
    // optional bytes nodePubKey = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_nodepubkey());
    }

    // optional string endpoint = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_endpoint());
    }

    // optional bool lastLink = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TMPeerShardInfo::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protocol.TMPeerShardInfo)
  GOOGLE_DCHECK_NE(&from, this);
  const TMPeerShardInfo* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<TMPeerShardInfo>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protocol.TMPeerShardInfo)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protocol.TMPeerShardInfo)
    MergeFrom(*source);
  }
}

void TMPeerShardInfo::MergeFrom(const TMPeerShardInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMPeerShardInfo)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  peerchain_.MergeFrom(from.peerchain_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_shardindexes(from._internal_shardindexes());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_nodepubkey(from._internal_nodepubkey());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_endpoint(from._internal_endpoint());
    }
    if (cached_has_bits & 0x00000008u) {
      lastlink_ = from.lastlink_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void TMPeerShardInfo::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protocol.TMPeerShardInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMPeerShardInfo::CopyFrom(const TMPeerShardInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMPeerShardInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMPeerShardInfo::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(peerchain_)) return false;
  return true;
}

void TMPeerShardInfo::InternalSwap(TMPeerShardInfo* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  peerchain_.InternalSwap(&other->peerchain_);
  shardindexes_.Swap(&other->shardindexes_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  nodepubkey_.Swap(&other->nodepubkey_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  endpoint_.Swap(&other->endpoint_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  swap(lastlink_, other->lastlink_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TMPeerShardInfo::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void TMTransaction::InitAsDefaultInstance() {
}
class TMTransaction::_Internal {
 public:
  using HasBits = decltype(std::declval<TMTransaction>()._has_bits_);
  static void set_has_rawtransaction(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_receivetimestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_deferred(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000009) ^ 0x00000009) != 0;
  }
};

TMTransaction::TMTransaction(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:protocol.TMTransaction)
}
TMTransaction::TMTransaction(const TMTransaction& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  rawtransaction_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_rawtransaction()) {
    rawtransaction_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_rawtransaction(),
      GetArena());
  }
  ::memcpy(&receivetimestamp_, &from.receivetimestamp_,
    static_cast<size_t>(reinterpret_cast<char*>(&status_) -
    reinterpret_cast<char*>(&receivetimestamp_)) + sizeof(status_));
  // @@protoc_insertion_point(copy_constructor:protocol.TMTransaction)
}

void TMTransaction::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_TMTransaction_ripple_2eproto.base);
  rawtransaction_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&receivetimestamp_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&deferred_) -
      reinterpret_cast<char*>(&receivetimestamp_)) + sizeof(deferred_));
  status_ = 1;
}

TMTransaction::~TMTransaction() {
  // @@protoc_insertion_point(destructor:protocol.TMTransaction)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void TMTransaction::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  rawtransaction_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void TMTransaction::ArenaDtor(void* object) {
  TMTransaction* _this = reinterpret_cast< TMTransaction* >(object);
  (void)_this;
}
void TMTransaction::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TMTransaction::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TMTransaction& TMTransaction::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TMTransaction_ripple_2eproto.base);
  return *internal_default_instance();
}


void TMTransaction::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMTransaction)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    rawtransaction_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&receivetimestamp_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&deferred_) -
        reinterpret_cast<char*>(&receivetimestamp_)) + sizeof(deferred_));
    status_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TMTransaction::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required bytes rawTransaction = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_rawtransaction();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required .protocol.TransactionStatus status = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::protocol::TransactionStatus_IsValid(val))) {
            _internal_set_status(static_cast<::protocol::TransactionStatus>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional uint64 receiveTimestamp = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_receivetimestamp(&has_bits);
          receivetimestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool deferred = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_deferred(&has_bits);
          deferred_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* TMTransaction::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMTransaction)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required bytes rawTransaction = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_rawtransaction(), target);
  }

  // required .protocol.TransactionStatus status = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_status(), target);
  }

  // optional uint64 receiveTimestamp = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(3, this->_internal_receivetimestamp(), target);
  }

  // optional bool deferred = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(4, this->_internal_deferred(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMTransaction)
  return target;
}

size_t TMTransaction::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:protocol.TMTransaction)
  size_t total_size = 0;

  if (_internal_has_rawtransaction()) {
    // required bytes rawTransaction = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_rawtransaction());
  }

  if (_internal_has_status()) {
    // required .protocol.TransactionStatus status = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_status());
  }

  return total_size;
}
size_t TMTransaction::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMTransaction)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000009) ^ 0x00000009) == 0) {  // All required fields are present.
    // required bytes rawTransaction = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_rawtransaction());

    // required .protocol.TransactionStatus status = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_status());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000006u) {
    // optional uint64 receiveTimestamp = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_receivetimestamp());
    }

    // optional bool deferred = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TMTransaction::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protocol.TMTransaction)
  GOOGLE_DCHECK_NE(&from, this);
  const TMTransaction* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<TMTransaction>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protocol.TMTransaction)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protocol.TMTransaction)
    MergeFrom(*source);
  }
}

void TMTransaction::MergeFrom(const TMTransaction& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMTransaction)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_rawtransaction(from._internal_rawtransaction());
    }
    if (cached_has_bits & 0x00000002u) {
      receivetimestamp_ = from.receivetimestamp_;
    }
    if (cached_has_bits & 0x00000004u) {
      deferred_ = from.deferred_;
    }
    if (cached_has_bits & 0x00000008u) {
      status_ = from.status_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void TMTransaction::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protocol.TMTransaction)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMTransaction::CopyFrom(const TMTransaction& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMTransaction)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMTransaction::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void TMTransaction::InternalSwap(TMTransaction* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  rawtransaction_.Swap(&other->rawtransaction_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TMTransaction, deferred_)
      + sizeof(TMTransaction::deferred_)
      - PROTOBUF_FIELD_OFFSET(TMTransaction, receivetimestamp_)>(
          reinterpret_cast<char*>(&receivetimestamp_),
          reinterpret_cast<char*>(&other->receivetimestamp_));
  swap(status_, other->status_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TMTransaction::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void TMStatusChange::InitAsDefaultInstance() {
}
class TMStatusChange::_Internal {
 public:
  using HasBits = decltype(std::declval<TMStatusChange>()._has_bits_);
  static void set_has_newstatus(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_newevent(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_ledgerseq(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_ledgerhash(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ledgerhashprevious(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_networktime(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_firstseq(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_lastseq(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

TMStatusChange::TMStatusChange(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:protocol.TMStatusChange)
}
TMStatusChange::TMStatusChange(const TMStatusChange& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ledgerhash_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_ledgerhash()) {
    ledgerhash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_ledgerhash(),
      GetArena());
  }
  ledgerhashprevious_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_ledgerhashprevious()) {
    ledgerhashprevious_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_ledgerhashprevious(),
      GetArena());
  }
  ::memcpy(&ledgerseq_, &from.ledgerseq_,
    static_cast<size_t>(reinterpret_cast<char*>(&newevent_) -
    reinterpret_cast<char*>(&ledgerseq_)) + sizeof(newevent_));
  // @@protoc_insertion_point(copy_constructor:protocol.TMStatusChange)
}

void TMStatusChange::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_TMStatusChange_ripple_2eproto.base);
  ledgerhash_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ledgerhashprevious_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&ledgerseq_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&lastseq_) -
      reinterpret_cast<char*>(&ledgerseq_)) + sizeof(lastseq_));
  newstatus_ = 1;
  newevent_ = 1;
}

TMStatusChange::~TMStatusChange() {
  // @@protoc_insertion_point(destructor:protocol.TMStatusChange)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void TMStatusChange::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  ledgerhash_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ledgerhashprevious_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void TMStatusChange::ArenaDtor(void* object) {
  TMStatusChange* _this = reinterpret_cast< TMStatusChange* >(object);
  (void)_this;
}
void TMStatusChange::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TMStatusChange::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TMStatusChange& TMStatusChange::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TMStatusChange_ripple_2eproto.base);
  return *internal_default_instance();
}


void TMStatusChange::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMStatusChange)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ledgerhash_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      ledgerhashprevious_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000fcu) {
    ::memset(&ledgerseq_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&lastseq_) -
        reinterpret_cast<char*>(&ledgerseq_)) + sizeof(lastseq_));
    newstatus_ = 1;
    newevent_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TMStatusChange::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .protocol.NodeStatus newStatus = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::protocol::NodeStatus_IsValid(val))) {
            _internal_set_newstatus(static_cast<::protocol::NodeStatus>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional .protocol.NodeEvent newEvent = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::protocol::NodeEvent_IsValid(val))) {
            _internal_set_newevent(static_cast<::protocol::NodeEvent>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional uint32 ledgerSeq = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_ledgerseq(&has_bits);
          ledgerseq_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bytes ledgerHash = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          auto str = _internal_mutable_ledgerhash();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bytes ledgerHashPrevious = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          auto str = _internal_mutable_ledgerhashprevious();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 networkTime = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_networktime(&has_bits);
          networktime_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 firstSeq = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          _Internal::set_has_firstseq(&has_bits);
          firstseq_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 lastSeq = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          _Internal::set_has_lastseq(&has_bits);
          lastseq_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* TMStatusChange::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMStatusChange)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .protocol.NodeStatus newStatus = 1;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_newstatus(), target);
  }

  // optional .protocol.NodeEvent newEvent = 2;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_newevent(), target);
  }

  // optional uint32 ledgerSeq = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_ledgerseq(), target);
  }

  // optional bytes ledgerHash = 4;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_ledgerhash(), target);
  }

  // optional bytes ledgerHashPrevious = 5;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        5, this->_internal_ledgerhashprevious(), target);
  }

  // optional uint64 networkTime = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(6, this->_internal_networktime(), target);
  }

  // optional uint32 firstSeq = 7;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(7, this->_internal_firstseq(), target);
  }

  // optional uint32 lastSeq = 8;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(8, this->_internal_lastseq(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMStatusChange)
  return target;
}

size_t TMStatusChange::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMStatusChange)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional bytes ledgerHash = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_ledgerhash());
    }

    // optional bytes ledgerHashPrevious = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_ledgerhashprevious());
    }

    // optional uint32 ledgerSeq = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_ledgerseq());
    }

    // optional uint32 firstSeq = 7;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_firstseq());
    }

    // optional uint64 networkTime = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_networktime());
    }

    // optional uint32 lastSeq = 8;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_lastseq());
    }

    // optional .protocol.NodeStatus newStatus = 1;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_newstatus());
    }

    // optional .protocol.NodeEvent newEvent = 2;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_newevent());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TMStatusChange::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protocol.TMStatusChange)
  GOOGLE_DCHECK_NE(&from, this);
  const TMStatusChange* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<TMStatusChange>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protocol.TMStatusChange)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protocol.TMStatusChange)
    MergeFrom(*source);
  }
}

void TMStatusChange::MergeFrom(const TMStatusChange& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMStatusChange)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_ledgerhash(from._internal_ledgerhash());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_ledgerhashprevious(from._internal_ledgerhashprevious());
    }
    if (cached_has_bits & 0x00000004u) {
      ledgerseq_ = from.ledgerseq_;
    }
    if (cached_has_bits & 0x00000008u) {
      firstseq_ = from.firstseq_;
    }
    if (cached_has_bits & 0x00000010u) {
      networktime_ = from.networktime_;
    }
    if (cached_has_bits & 0x00000020u) {
      lastseq_ = from.lastseq_;
    }
    if (cached_has_bits & 0x00000040u) {
      newstatus_ = from.newstatus_;
    }
    if (cached_has_bits & 0x00000080u) {
      newevent_ = from.newevent_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void TMStatusChange::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protocol.TMStatusChange)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMStatusChange::CopyFrom(const TMStatusChange& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMStatusChange)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMStatusChange::IsInitialized() const {
  return true;
}

void TMStatusChange::InternalSwap(TMStatusChange* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ledgerhash_.Swap(&other->ledgerhash_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  ledgerhashprevious_.Swap(&other->ledgerhashprevious_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TMStatusChange, lastseq_)
      + sizeof(TMStatusChange::lastseq_)
      - PROTOBUF_FIELD_OFFSET(TMStatusChange, ledgerseq_)>(
          reinterpret_cast<char*>(&ledgerseq_),
          reinterpret_cast<char*>(&other->ledgerseq_));
  swap(newstatus_, other->newstatus_);
  swap(newevent_, other->newevent_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TMStatusChange::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void TMProposeSet::InitAsDefaultInstance() {
}
class TMProposeSet::_Internal {
 public:
  using HasBits = decltype(std::declval<TMProposeSet>()._has_bits_);
  static void set_has_proposeseq(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_currenttxhash(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_nodepubkey(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_closetime(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_signature(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_previousledger(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_checkedsignature(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_hops(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000003f) ^ 0x0000003f) != 0;
  }
};

TMProposeSet::TMProposeSet(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  addedtransactions_(arena),
  removedtransactions_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:protocol.TMProposeSet)
}
TMProposeSet::TMProposeSet(const TMProposeSet& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      addedtransactions_(from.addedtransactions_),
      removedtransactions_(from.removedtransactions_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  currenttxhash_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_currenttxhash()) {
    currenttxhash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_currenttxhash(),
      GetArena());
  }
  nodepubkey_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_nodepubkey()) {
    nodepubkey_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_nodepubkey(),
      GetArena());
  }
  signature_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_signature()) {
    signature_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_signature(),
      GetArena());
  }
  previousledger_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_previousledger()) {
    previousledger_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_previousledger(),
      GetArena());
  }
  ::memcpy(&proposeseq_, &from.proposeseq_,
    static_cast<size_t>(reinterpret_cast<char*>(&hops_) -
    reinterpret_cast<char*>(&proposeseq_)) + sizeof(hops_));
  // @@protoc_insertion_point(copy_constructor:protocol.TMProposeSet)
}

void TMProposeSet::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_TMProposeSet_ripple_2eproto.base);
  currenttxhash_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  nodepubkey_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  signature_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  previousledger_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&proposeseq_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&hops_) -
      reinterpret_cast<char*>(&proposeseq_)) + sizeof(hops_));
}

TMProposeSet::~TMProposeSet() {
  // @@protoc_insertion_point(destructor:protocol.TMProposeSet)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void TMProposeSet::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  currenttxhash_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  nodepubkey_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  signature_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  previousledger_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void TMProposeSet::ArenaDtor(void* object) {
  TMProposeSet* _this = reinterpret_cast< TMProposeSet* >(object);
  (void)_this;
}
void TMProposeSet::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TMProposeSet::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TMProposeSet& TMProposeSet::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TMProposeSet_ripple_2eproto.base);
  return *internal_default_instance();
}


void TMProposeSet::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMProposeSet)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  addedtransactions_.Clear();
  removedtransactions_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      currenttxhash_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      nodepubkey_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      signature_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      previousledger_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000f0u) {
    ::memset(&proposeseq_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&hops_) -
        reinterpret_cast<char*>(&proposeseq_)) + sizeof(hops_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TMProposeSet::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required uint32 proposeSeq = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_proposeseq(&has_bits);
          proposeseq_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required bytes currentTxHash = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_currenttxhash();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required bytes nodePubKey = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          auto str = _internal_mutable_nodepubkey();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required uint32 closeTime = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_closetime(&has_bits);
          closetime_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required bytes signature = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          auto str = _internal_mutable_signature();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required bytes previousledger = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          auto str = _internal_mutable_previousledger();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool checkedSignature = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          _Internal::set_has_checkedsignature(&has_bits);
          checkedsignature_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated bytes addedTransactions = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 82)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_addedtransactions();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<82>(ptr));
        } else goto handle_unusual;
        continue;
      // repeated bytes removedTransactions = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 90)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_removedtransactions();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<90>(ptr));
        } else goto handle_unusual;
        continue;
      // optional uint32 hops = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 96)) {
          _Internal::set_has_hops(&has_bits);
          hops_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* TMProposeSet::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMProposeSet)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 proposeSeq = 1;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_proposeseq(), target);
  }

  // required bytes currentTxHash = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_currenttxhash(), target);
  }

  // required bytes nodePubKey = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_nodepubkey(), target);
  }

  // required uint32 closeTime = 4;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(4, this->_internal_closetime(), target);
  }

  // required bytes signature = 5;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        5, this->_internal_signature(), target);
  }

  // required bytes previousledger = 6;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteBytesMaybeAliased(
        6, this->_internal_previousledger(), target);
  }

  // optional bool checkedSignature = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(7, this->_internal_checkedsignature(), target);
  }

  // repeated bytes addedTransactions = 10;
  for (int i = 0, n = this->_internal_addedtransactions_size(); i < n; i++) {
    const auto& s = this->_internal_addedtransactions(i);
    target = stream->WriteBytes(10, s, target);
  }

  // repeated bytes removedTransactions = 11;
  for (int i = 0, n = this->_internal_removedtransactions_size(); i < n; i++) {
    const auto& s = this->_internal_removedtransactions(i);
    target = stream->WriteBytes(11, s, target);
  }

  // optional uint32 hops = 12;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(12, this->_internal_hops(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMProposeSet)
  return target;
}

size_t TMProposeSet::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:protocol.TMProposeSet)
  size_t total_size = 0;

  if (_internal_has_currenttxhash()) {
    // required bytes currentTxHash = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_currenttxhash());
  }

  if (_internal_has_nodepubkey()) {
    // required bytes nodePubKey = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_nodepubkey());
  }

  if (_internal_has_signature()) {
    // required bytes signature = 5;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_signature());
  }

  if (_internal_has_previousledger()) {
    // required bytes previousledger = 6;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_previousledger());
  }

  if (_internal_has_proposeseq()) {
    // required uint32 proposeSeq = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_proposeseq());
  }

  if (_internal_has_closetime()) {
    // required uint32 closeTime = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_closetime());
  }

  return total_size;
}
size_t TMProposeSet::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMProposeSet)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x0000003f) ^ 0x0000003f) == 0) {  // All required fields are present.
    // required bytes currentTxHash = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_currenttxhash());

    // required bytes nodePubKey = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_nodepubkey());

    // required bytes signature = 5;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_signature());

    // required bytes previousledger = 6;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_previousledger());

    // required uint32 proposeSeq = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_proposeseq());

    // required uint32 closeTime = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_closetime());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated bytes addedTransactions = 10;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(addedtransactions_.size());
  for (int i = 0, n = addedtransactions_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
      addedtransactions_.Get(i));
  }

  // repeated bytes removedTransactions = 11;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(removedtransactions_.size());
  for (int i = 0, n = removedtransactions_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
      removedtransactions_.Get(i));
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000c0u) {
    // optional bool checkedSignature = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

    // optional uint32 hops = 12;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_hops());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TMProposeSet::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protocol.TMProposeSet)
  GOOGLE_DCHECK_NE(&from, this);
  const TMProposeSet* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<TMProposeSet>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protocol.TMProposeSet)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protocol.TMProposeSet)
    MergeFrom(*source);
  }
}

void TMProposeSet::MergeFrom(const TMProposeSet& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMProposeSet)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  addedtransactions_.MergeFrom(from.addedtransactions_);
  removedtransactions_.MergeFrom(from.removedtransactions_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_currenttxhash(from._internal_currenttxhash());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_nodepubkey(from._internal_nodepubkey());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_signature(from._internal_signature());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_previousledger(from._internal_previousledger());
    }
    if (cached_has_bits & 0x00000010u) {
      proposeseq_ = from.proposeseq_;
    }
    if (cached_has_bits & 0x00000020u) {
      closetime_ = from.closetime_;
    }
    if (cached_has_bits & 0x00000040u) {
      checkedsignature_ = from.checkedsignature_;
    }
    if (cached_has_bits & 0x00000080u) {
      hops_ = from.hops_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void TMProposeSet::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protocol.TMProposeSet)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMProposeSet::CopyFrom(const TMProposeSet& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMProposeSet)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMProposeSet::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void TMProposeSet::InternalSwap(TMProposeSet* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  addedtransactions_.InternalSwap(&other->addedtransactions_);
  removedtransactions_.InternalSwap(&other->removedtransactions_);
  currenttxhash_.Swap(&other->currenttxhash_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  nodepubkey_.Swap(&other->nodepubkey_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  signature_.Swap(&other->signature_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  previousledger_.Swap(&other->previousledger_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TMProposeSet, hops_)
      + sizeof(TMProposeSet::hops_)
      - PROTOBUF_FIELD_OFFSET(TMProposeSet, proposeseq_)>(
          reinterpret_cast<char*>(&proposeseq_),
          reinterpret_cast<char*>(&other->proposeseq_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TMProposeSet::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void TMHaveTransactionSet::InitAsDefaultInstance() {
}
class TMHaveTransactionSet::_Internal {
 public:
  using HasBits = decltype(std::declval<TMHaveTransactionSet>()._has_bits_);
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_hash(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

TMHaveTransactionSet::TMHaveTransactionSet(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:protocol.TMHaveTransactionSet)
}
TMHaveTransactionSet::TMHaveTransactionSet(const TMHaveTransactionSet& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  hash_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_hash()) {
    hash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_hash(),
      GetArena());
  }
  status_ = from.status_;
  // @@protoc_insertion_point(copy_constructor:protocol.TMHaveTransactionSet)
}

void TMHaveTransactionSet::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_TMHaveTransactionSet_ripple_2eproto.base);
  hash_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  status_ = 1;
}

TMHaveTransactionSet::~TMHaveTransactionSet() {
  // @@protoc_insertion_point(destructor:protocol.TMHaveTransactionSet)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void TMHaveTransactionSet::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  hash_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void TMHaveTransactionSet::ArenaDtor(void* object) {
  TMHaveTransactionSet* _this = reinterpret_cast< TMHaveTransactionSet* >(object);
  (void)_this;
}
void TMHaveTransactionSet::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TMHaveTransactionSet::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TMHaveTransactionSet& TMHaveTransactionSet::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TMHaveTransactionSet_ripple_2eproto.base);
  return *internal_default_instance();
}


void TMHaveTransactionSet::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMHaveTransactionSet)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      hash_.ClearNonDefaultToEmpty();
    }
    status_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TMHaveTransactionSet::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required .protocol.TxSetStatus status = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::protocol::TxSetStatus_IsValid(val))) {
            _internal_set_status(static_cast<::protocol::TxSetStatus>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // required bytes hash = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_hash();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* TMHaveTransactionSet::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMHaveTransactionSet)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .protocol.TxSetStatus status = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_status(), target);
  }

  // required bytes hash = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_hash(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMHaveTransactionSet)
  return target;
}

size_t TMHaveTransactionSet::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:protocol.TMHaveTransactionSet)
  size_t total_size = 0;

  if (_internal_has_hash()) {
    // required bytes hash = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_hash());
  }

  if (_internal_has_status()) {
    // required .protocol.TxSetStatus status = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_status());
  }

  return total_size;
}
size_t TMHaveTransactionSet::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMHaveTransactionSet)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required bytes hash = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_hash());

    // required .protocol.TxSetStatus status = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_status());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TMHaveTransactionSet::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protocol.TMHaveTransactionSet)
  GOOGLE_DCHECK_NE(&from, this);
  const TMHaveTransactionSet* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<TMHaveTransactionSet>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protocol.TMHaveTransactionSet)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protocol.TMHaveTransactionSet)
    MergeFrom(*source);
  }
}

void TMHaveTransactionSet::MergeFrom(const TMHaveTransactionSet& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMHaveTransactionSet)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_hash(from._internal_hash());
    }
    if (cached_has_bits & 0x00000002u) {
      status_ = from.status_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void TMHaveTransactionSet::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protocol.TMHaveTransactionSet)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMHaveTransactionSet::CopyFrom(const TMHaveTransactionSet& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMHaveTransactionSet)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMHaveTransactionSet::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void TMHaveTransactionSet::InternalSwap(TMHaveTransactionSet* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  hash_.Swap(&other->hash_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  swap(status_, other->status_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TMHaveTransactionSet::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void TMValidatorList::InitAsDefaultInstance() {
}
class TMValidatorList::_Internal {
 public:
  using HasBits = decltype(std::declval<TMValidatorList>()._has_bits_);
  static void set_has_manifest(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_blob(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_signature(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000f) ^ 0x0000000f) != 0;
  }
};

TMValidatorList::TMValidatorList(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:protocol.TMValidatorList)
}
TMValidatorList::TMValidatorList(const TMValidatorList& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  manifest_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_manifest()) {
    manifest_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_manifest(),
      GetArena());
  }
  blob_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_blob()) {
    blob_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_blob(),
      GetArena());
  }
  signature_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_signature()) {
    signature_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_signature(),
      GetArena());
  }
  version_ = from.version_;
  // @@protoc_insertion_point(copy_constructor:protocol.TMValidatorList)
}

void TMValidatorList::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_TMValidatorList_ripple_2eproto.base);
  manifest_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  blob_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  signature_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  version_ = 0u;
}

TMValidatorList::~TMValidatorList() {
  // @@protoc_insertion_point(destructor:protocol.TMValidatorList)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void TMValidatorList::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  manifest_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  blob_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  signature_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void TMValidatorList::ArenaDtor(void* object) {
  TMValidatorList* _this = reinterpret_cast< TMValidatorList* >(object);
  (void)_this;
}
void TMValidatorList::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TMValidatorList::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TMValidatorList& TMValidatorList::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TMValidatorList_ripple_2eproto.base);
  return *internal_default_instance();
}


void TMValidatorList::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMValidatorList)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      manifest_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      blob_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      signature_.ClearNonDefaultToEmpty();
    }
  }
  version_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TMValidatorList::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required bytes manifest = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_manifest();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required bytes blob = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_blob();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required bytes signature = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          auto str = _internal_mutable_signature();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required uint32 version = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_version(&has_bits);
          version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* TMValidatorList::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMValidatorList)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required bytes manifest = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_manifest(), target);
  }

  // required bytes blob = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_blob(), target);
  }

  // required bytes signature = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_signature(), target);
  }

  // required uint32 version = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(4, this->_internal_version(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMValidatorList)
  return target;
}

size_t TMValidatorList::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:protocol.TMValidatorList)
  size_t total_size = 0;

  if (_internal_has_manifest()) {
    // required bytes manifest = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_manifest());
  }

  if (_internal_has_blob()) {
    // required bytes blob = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_blob());
  }

  if (_internal_has_signature()) {
    // required bytes signature = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_signature());
  }

  if (_internal_has_version()) {
    // required uint32 version = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_version());
  }

  return total_size;
}
size_t TMValidatorList::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMValidatorList)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x0000000f) ^ 0x0000000f) == 0) {  // All required fields are present.
    // required bytes manifest = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_manifest());

    // required bytes blob = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_blob());

    // required bytes signature = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_signature());

    // required uint32 version = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_version());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TMValidatorList::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protocol.TMValidatorList)
  GOOGLE_DCHECK_NE(&from, this);
  const TMValidatorList* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<TMValidatorList>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protocol.TMValidatorList)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protocol.TMValidatorList)
    MergeFrom(*source);
  }
}

void TMValidatorList::MergeFrom(const TMValidatorList& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMValidatorList)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_manifest(from._internal_manifest());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_blob(from._internal_blob());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_signature(from._internal_signature());
    }
    if (cached_has_bits & 0x00000008u) {
      version_ = from.version_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void TMValidatorList::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protocol.TMValidatorList)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMValidatorList::CopyFrom(const TMValidatorList& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMValidatorList)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMValidatorList::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void TMValidatorList::InternalSwap(TMValidatorList* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  manifest_.Swap(&other->manifest_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  blob_.Swap(&other->blob_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  signature_.Swap(&other->signature_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  swap(version_, other->version_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TMValidatorList::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void TMValidation::InitAsDefaultInstance() {
}
class TMValidation::_Internal {
 public:
  using HasBits = decltype(std::declval<TMValidation>()._has_bits_);
  static void set_has_validation(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_checkedsignature(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_hops(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

TMValidation::TMValidation(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:protocol.TMValidation)
}
TMValidation::TMValidation(const TMValidation& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  validation_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_validation()) {
    validation_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_validation(),
      GetArena());
  }
  ::memcpy(&checkedsignature_, &from.checkedsignature_,
    static_cast<size_t>(reinterpret_cast<char*>(&hops_) -
    reinterpret_cast<char*>(&checkedsignature_)) + sizeof(hops_));
  // @@protoc_insertion_point(copy_constructor:protocol.TMValidation)
}

void TMValidation::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_TMValidation_ripple_2eproto.base);
  validation_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&checkedsignature_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&hops_) -
      reinterpret_cast<char*>(&checkedsignature_)) + sizeof(hops_));
}

TMValidation::~TMValidation() {
  // @@protoc_insertion_point(destructor:protocol.TMValidation)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void TMValidation::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  validation_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void TMValidation::ArenaDtor(void* object) {
  TMValidation* _this = reinterpret_cast< TMValidation* >(object);
  (void)_this;
}
void TMValidation::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TMValidation::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TMValidation& TMValidation::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TMValidation_ripple_2eproto.base);
  return *internal_default_instance();
}


void TMValidation::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMValidation)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    validation_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&checkedsignature_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&hops_) -
        reinterpret_cast<char*>(&checkedsignature_)) + sizeof(hops_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TMValidation::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required bytes validation = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_validation();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool checkedSignature = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_checkedsignature(&has_bits);
          checkedsignature_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 hops = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_hops(&has_bits);
          hops_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* TMValidation::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMValidation)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required bytes validation = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_validation(), target);
  }

  // optional bool checkedSignature = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->_internal_checkedsignature(), target);
  }

  // optional uint32 hops = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_hops(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMValidation)
  return target;
}

size_t TMValidation::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMValidation)
  size_t total_size = 0;

  // required bytes validation = 1;
  if (_internal_has_validation()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_validation());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000006u) {
    // optional bool checkedSignature = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

    // optional uint32 hops = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_hops());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TMValidation::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protocol.TMValidation)
  GOOGLE_DCHECK_NE(&from, this);
  const TMValidation* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<TMValidation>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protocol.TMValidation)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protocol.TMValidation)
    MergeFrom(*source);
  }
}

void TMValidation::MergeFrom(const TMValidation& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMValidation)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_validation(from._internal_validation());
    }
    if (cached_has_bits & 0x00000002u) {
      checkedsignature_ = from.checkedsignature_;
    }
    if (cached_has_bits & 0x00000004u) {
      hops_ = from.hops_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void TMValidation::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protocol.TMValidation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMValidation::CopyFrom(const TMValidation& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMValidation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMValidation::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void TMValidation::InternalSwap(TMValidation* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  validation_.Swap(&other->validation_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TMValidation, hops_)
      + sizeof(TMValidation::hops_)
      - PROTOBUF_FIELD_OFFSET(TMValidation, checkedsignature_)>(
          reinterpret_cast<char*>(&checkedsignature_),
          reinterpret_cast<char*>(&other->checkedsignature_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TMValidation::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void TMIPv4Endpoint::InitAsDefaultInstance() {
}
class TMIPv4Endpoint::_Internal {
 public:
  using HasBits = decltype(std::declval<TMIPv4Endpoint>()._has_bits_);
  static void set_has_ipv4(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ipv4port(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

TMIPv4Endpoint::TMIPv4Endpoint(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:protocol.TMIPv4Endpoint)
}
TMIPv4Endpoint::TMIPv4Endpoint(const TMIPv4Endpoint& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&ipv4_, &from.ipv4_,
    static_cast<size_t>(reinterpret_cast<char*>(&ipv4port_) -
    reinterpret_cast<char*>(&ipv4_)) + sizeof(ipv4port_));
  // @@protoc_insertion_point(copy_constructor:protocol.TMIPv4Endpoint)
}

void TMIPv4Endpoint::SharedCtor() {
  ::memset(&ipv4_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&ipv4port_) -
      reinterpret_cast<char*>(&ipv4_)) + sizeof(ipv4port_));
}

TMIPv4Endpoint::~TMIPv4Endpoint() {
  // @@protoc_insertion_point(destructor:protocol.TMIPv4Endpoint)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void TMIPv4Endpoint::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void TMIPv4Endpoint::ArenaDtor(void* object) {
  TMIPv4Endpoint* _this = reinterpret_cast< TMIPv4Endpoint* >(object);
  (void)_this;
}
void TMIPv4Endpoint::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TMIPv4Endpoint::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TMIPv4Endpoint& TMIPv4Endpoint::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TMIPv4Endpoint_ripple_2eproto.base);
  return *internal_default_instance();
}


void TMIPv4Endpoint::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMIPv4Endpoint)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&ipv4_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&ipv4port_) -
        reinterpret_cast<char*>(&ipv4_)) + sizeof(ipv4port_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TMIPv4Endpoint::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required uint32 ipv4 = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_ipv4(&has_bits);
          ipv4_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required uint32 ipv4Port = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_ipv4port(&has_bits);
          ipv4port_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* TMIPv4Endpoint::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMIPv4Endpoint)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 ipv4 = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_ipv4(), target);
  }

  // required uint32 ipv4Port = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_ipv4port(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMIPv4Endpoint)
  return target;
}

size_t TMIPv4Endpoint::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:protocol.TMIPv4Endpoint)
  size_t total_size = 0;

  if (_internal_has_ipv4()) {
    // required uint32 ipv4 = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_ipv4());
  }

  if (_internal_has_ipv4port()) {
    // required uint32 ipv4Port = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_ipv4port());
  }

  return total_size;
}
size_t TMIPv4Endpoint::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMIPv4Endpoint)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required uint32 ipv4 = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_ipv4());

    // required uint32 ipv4Port = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_ipv4port());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TMIPv4Endpoint::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protocol.TMIPv4Endpoint)
  GOOGLE_DCHECK_NE(&from, this);
  const TMIPv4Endpoint* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<TMIPv4Endpoint>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protocol.TMIPv4Endpoint)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protocol.TMIPv4Endpoint)
    MergeFrom(*source);
  }
}

void TMIPv4Endpoint::MergeFrom(const TMIPv4Endpoint& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMIPv4Endpoint)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ipv4_ = from.ipv4_;
    }
    if (cached_has_bits & 0x00000002u) {
      ipv4port_ = from.ipv4port_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void TMIPv4Endpoint::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protocol.TMIPv4Endpoint)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMIPv4Endpoint::CopyFrom(const TMIPv4Endpoint& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMIPv4Endpoint)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMIPv4Endpoint::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void TMIPv4Endpoint::InternalSwap(TMIPv4Endpoint* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TMIPv4Endpoint, ipv4port_)
      + sizeof(TMIPv4Endpoint::ipv4port_)
      - PROTOBUF_FIELD_OFFSET(TMIPv4Endpoint, ipv4_)>(
          reinterpret_cast<char*>(&ipv4_),
          reinterpret_cast<char*>(&other->ipv4_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TMIPv4Endpoint::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void TMEndpoint::InitAsDefaultInstance() {
  ::protocol::_TMEndpoint_default_instance_._instance.get_mutable()->ipv4_ = const_cast< ::protocol::TMIPv4Endpoint*>(
      ::protocol::TMIPv4Endpoint::internal_default_instance());
}
class TMEndpoint::_Internal {
 public:
  using HasBits = decltype(std::declval<TMEndpoint>()._has_bits_);
  static const ::protocol::TMIPv4Endpoint& ipv4(const TMEndpoint* msg);
  static void set_has_ipv4(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_hops(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

const ::protocol::TMIPv4Endpoint&
TMEndpoint::_Internal::ipv4(const TMEndpoint* msg) {
  return *msg->ipv4_;
}
TMEndpoint::TMEndpoint(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:protocol.TMEndpoint)
}
TMEndpoint::TMEndpoint(const TMEndpoint& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_ipv4()) {
    ipv4_ = new ::protocol::TMIPv4Endpoint(*from.ipv4_);
  } else {
    ipv4_ = nullptr;
  }
  hops_ = from.hops_;
  // @@protoc_insertion_point(copy_constructor:protocol.TMEndpoint)
}

void TMEndpoint::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_TMEndpoint_ripple_2eproto.base);
  ::memset(&ipv4_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&hops_) -
      reinterpret_cast<char*>(&ipv4_)) + sizeof(hops_));
}

TMEndpoint::~TMEndpoint() {
  // @@protoc_insertion_point(destructor:protocol.TMEndpoint)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void TMEndpoint::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete ipv4_;
}

void TMEndpoint::ArenaDtor(void* object) {
  TMEndpoint* _this = reinterpret_cast< TMEndpoint* >(object);
  (void)_this;
}
void TMEndpoint::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TMEndpoint::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TMEndpoint& TMEndpoint::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TMEndpoint_ripple_2eproto.base);
  return *internal_default_instance();
}


void TMEndpoint::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMEndpoint)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(ipv4_ != nullptr);
    ipv4_->Clear();
  }
  hops_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TMEndpoint::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required .protocol.TMIPv4Endpoint ipv4 = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_ipv4(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required uint32 hops = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_hops(&has_bits);
          hops_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* TMEndpoint::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMEndpoint)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .protocol.TMIPv4Endpoint ipv4 = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::ipv4(this), target, stream);
  }

  // required uint32 hops = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_hops(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMEndpoint)
  return target;
}

size_t TMEndpoint::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:protocol.TMEndpoint)
  size_t total_size = 0;

  if (_internal_has_ipv4()) {
    // required .protocol.TMIPv4Endpoint ipv4 = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *ipv4_);
  }

  if (_internal_has_hops()) {
    // required uint32 hops = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_hops());
  }

  return total_size;
}
size_t TMEndpoint::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMEndpoint)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required .protocol.TMIPv4Endpoint ipv4 = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *ipv4_);

    // required uint32 hops = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_hops());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TMEndpoint::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protocol.TMEndpoint)
  GOOGLE_DCHECK_NE(&from, this);
  const TMEndpoint* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<TMEndpoint>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protocol.TMEndpoint)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protocol.TMEndpoint)
    MergeFrom(*source);
  }
}

void TMEndpoint::MergeFrom(const TMEndpoint& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMEndpoint)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_ipv4()->::protocol::TMIPv4Endpoint::MergeFrom(from._internal_ipv4());
    }
    if (cached_has_bits & 0x00000002u) {
      hops_ = from.hops_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void TMEndpoint::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protocol.TMEndpoint)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMEndpoint::CopyFrom(const TMEndpoint& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMEndpoint)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMEndpoint::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (_internal_has_ipv4()) {
    if (!ipv4_->IsInitialized()) return false;
  }
  return true;
}

void TMEndpoint::InternalSwap(TMEndpoint* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TMEndpoint, hops_)
      + sizeof(TMEndpoint::hops_)
      - PROTOBUF_FIELD_OFFSET(TMEndpoint, ipv4_)>(
          reinterpret_cast<char*>(&ipv4_),
          reinterpret_cast<char*>(&other->ipv4_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TMEndpoint::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void TMEndpoints_TMEndpointv2::InitAsDefaultInstance() {
}
class TMEndpoints_TMEndpointv2::_Internal {
 public:
  using HasBits = decltype(std::declval<TMEndpoints_TMEndpointv2>()._has_bits_);
  static void set_has_endpoint(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_hops(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

TMEndpoints_TMEndpointv2::TMEndpoints_TMEndpointv2(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:protocol.TMEndpoints.TMEndpointv2)
}
TMEndpoints_TMEndpointv2::TMEndpoints_TMEndpointv2(const TMEndpoints_TMEndpointv2& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  endpoint_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_endpoint()) {
    endpoint_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_endpoint(),
      GetArena());
  }
  hops_ = from.hops_;
  // @@protoc_insertion_point(copy_constructor:protocol.TMEndpoints.TMEndpointv2)
}

void TMEndpoints_TMEndpointv2::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_TMEndpoints_TMEndpointv2_ripple_2eproto.base);
  endpoint_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  hops_ = 0u;
}

TMEndpoints_TMEndpointv2::~TMEndpoints_TMEndpointv2() {
  // @@protoc_insertion_point(destructor:protocol.TMEndpoints.TMEndpointv2)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void TMEndpoints_TMEndpointv2::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  endpoint_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void TMEndpoints_TMEndpointv2::ArenaDtor(void* object) {
  TMEndpoints_TMEndpointv2* _this = reinterpret_cast< TMEndpoints_TMEndpointv2* >(object);
  (void)_this;
}
void TMEndpoints_TMEndpointv2::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TMEndpoints_TMEndpointv2::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TMEndpoints_TMEndpointv2& TMEndpoints_TMEndpointv2::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TMEndpoints_TMEndpointv2_ripple_2eproto.base);
  return *internal_default_instance();
}


void TMEndpoints_TMEndpointv2::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMEndpoints.TMEndpointv2)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    endpoint_.ClearNonDefaultToEmpty();
  }
  hops_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TMEndpoints_TMEndpointv2::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required string endpoint = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_endpoint();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "protocol.TMEndpoints.TMEndpointv2.endpoint");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required uint32 hops = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_hops(&has_bits);
          hops_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* TMEndpoints_TMEndpointv2::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMEndpoints.TMEndpointv2)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string endpoint = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_endpoint().data(), static_cast<int>(this->_internal_endpoint().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "protocol.TMEndpoints.TMEndpointv2.endpoint");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_endpoint(), target);
  }

  // required uint32 hops = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_hops(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMEndpoints.TMEndpointv2)
  return target;
}

size_t TMEndpoints_TMEndpointv2::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:protocol.TMEndpoints.TMEndpointv2)
  size_t total_size = 0;

  if (_internal_has_endpoint()) {
    // required string endpoint = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_endpoint());
  }

  if (_internal_has_hops()) {
    // required uint32 hops = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_hops());
  }

  return total_size;
}
size_t TMEndpoints_TMEndpointv2::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMEndpoints.TMEndpointv2)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required string endpoint = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_endpoint());

    // required uint32 hops = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_hops());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TMEndpoints_TMEndpointv2::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protocol.TMEndpoints.TMEndpointv2)
  GOOGLE_DCHECK_NE(&from, this);
  const TMEndpoints_TMEndpointv2* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<TMEndpoints_TMEndpointv2>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protocol.TMEndpoints.TMEndpointv2)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protocol.TMEndpoints.TMEndpointv2)
    MergeFrom(*source);
  }
}

void TMEndpoints_TMEndpointv2::MergeFrom(const TMEndpoints_TMEndpointv2& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMEndpoints.TMEndpointv2)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_endpoint(from._internal_endpoint());
    }
    if (cached_has_bits & 0x00000002u) {
      hops_ = from.hops_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void TMEndpoints_TMEndpointv2::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protocol.TMEndpoints.TMEndpointv2)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMEndpoints_TMEndpointv2::CopyFrom(const TMEndpoints_TMEndpointv2& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMEndpoints.TMEndpointv2)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMEndpoints_TMEndpointv2::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void TMEndpoints_TMEndpointv2::InternalSwap(TMEndpoints_TMEndpointv2* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  endpoint_.Swap(&other->endpoint_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  swap(hops_, other->hops_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TMEndpoints_TMEndpointv2::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void TMEndpoints::InitAsDefaultInstance() {
}
class TMEndpoints::_Internal {
 public:
  using HasBits = decltype(std::declval<TMEndpoints>()._has_bits_);
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

TMEndpoints::TMEndpoints(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  endpoints_(arena),
  endpoints_v2_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:protocol.TMEndpoints)
}
TMEndpoints::TMEndpoints(const TMEndpoints& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      endpoints_(from.endpoints_),
      endpoints_v2_(from.endpoints_v2_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  version_ = from.version_;
  // @@protoc_insertion_point(copy_constructor:protocol.TMEndpoints)
}

void TMEndpoints::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_TMEndpoints_ripple_2eproto.base);
  version_ = 0u;
}

TMEndpoints::~TMEndpoints() {
  // @@protoc_insertion_point(destructor:protocol.TMEndpoints)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void TMEndpoints::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void TMEndpoints::ArenaDtor(void* object) {
  TMEndpoints* _this = reinterpret_cast< TMEndpoints* >(object);
  (void)_this;
}
void TMEndpoints::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TMEndpoints::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TMEndpoints& TMEndpoints::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TMEndpoints_ripple_2eproto.base);
  return *internal_default_instance();
}


void TMEndpoints::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMEndpoints)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  endpoints_.Clear();
  endpoints_v2_.Clear();
  version_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TMEndpoints::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required uint32 version = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_version(&has_bits);
          version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .protocol.TMEndpoint endpoints = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_endpoints(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else goto handle_unusual;
        continue;
      // repeated .protocol.TMEndpoints.TMEndpointv2 endpoints_v2 = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_endpoints_v2(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* TMEndpoints::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMEndpoints)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 version = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_version(), target);
  }

  // repeated .protocol.TMEndpoint endpoints = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_endpoints_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, this->_internal_endpoints(i), target, stream);
  }

  // repeated .protocol.TMEndpoints.TMEndpointv2 endpoints_v2 = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_endpoints_v2_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, this->_internal_endpoints_v2(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMEndpoints)
  return target;
}

size_t TMEndpoints::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMEndpoints)
  size_t total_size = 0;

  // required uint32 version = 1;
  if (_internal_has_version()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_version());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .protocol.TMEndpoint endpoints = 2;
  total_size += 1UL * this->_internal_endpoints_size();
  for (const auto& msg : this->endpoints_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .protocol.TMEndpoints.TMEndpointv2 endpoints_v2 = 3;
  total_size += 1UL * this->_internal_endpoints_v2_size();
  for (const auto& msg : this->endpoints_v2_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TMEndpoints::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protocol.TMEndpoints)
  GOOGLE_DCHECK_NE(&from, this);
  const TMEndpoints* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<TMEndpoints>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protocol.TMEndpoints)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protocol.TMEndpoints)
    MergeFrom(*source);
  }
}

void TMEndpoints::MergeFrom(const TMEndpoints& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMEndpoints)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  endpoints_.MergeFrom(from.endpoints_);
  endpoints_v2_.MergeFrom(from.endpoints_v2_);
  if (from._internal_has_version()) {
    _internal_set_version(from._internal_version());
  }
}

void TMEndpoints::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protocol.TMEndpoints)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMEndpoints::CopyFrom(const TMEndpoints& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMEndpoints)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMEndpoints::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(endpoints_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(endpoints_v2_)) return false;
  return true;
}

void TMEndpoints::InternalSwap(TMEndpoints* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  endpoints_.InternalSwap(&other->endpoints_);
  endpoints_v2_.InternalSwap(&other->endpoints_v2_);
  swap(version_, other->version_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TMEndpoints::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void TMIndexedObject::InitAsDefaultInstance() {
}
class TMIndexedObject::_Internal {
 public:
  using HasBits = decltype(std::declval<TMIndexedObject>()._has_bits_);
  static void set_has_hash(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_nodeid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_index(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_data(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_ledgerseq(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

TMIndexedObject::TMIndexedObject(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:protocol.TMIndexedObject)
}
TMIndexedObject::TMIndexedObject(const TMIndexedObject& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  hash_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_hash()) {
    hash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_hash(),
      GetArena());
  }
  nodeid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_nodeid()) {
    nodeid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_nodeid(),
      GetArena());
  }
  index_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_index()) {
    index_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_index(),
      GetArena());
  }
  data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_data()) {
    data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_data(),
      GetArena());
  }
  ledgerseq_ = from.ledgerseq_;
  // @@protoc_insertion_point(copy_constructor:protocol.TMIndexedObject)
}

void TMIndexedObject::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_TMIndexedObject_ripple_2eproto.base);
  hash_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  nodeid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  index_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ledgerseq_ = 0u;
}

TMIndexedObject::~TMIndexedObject() {
  // @@protoc_insertion_point(destructor:protocol.TMIndexedObject)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void TMIndexedObject::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  hash_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  nodeid_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  index_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  data_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void TMIndexedObject::ArenaDtor(void* object) {
  TMIndexedObject* _this = reinterpret_cast< TMIndexedObject* >(object);
  (void)_this;
}
void TMIndexedObject::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TMIndexedObject::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TMIndexedObject& TMIndexedObject::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TMIndexedObject_ripple_2eproto.base);
  return *internal_default_instance();
}


void TMIndexedObject::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMIndexedObject)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      hash_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      nodeid_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      index_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      data_.ClearNonDefaultToEmpty();
    }
  }
  ledgerseq_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TMIndexedObject::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional bytes hash = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_hash();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bytes nodeID = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_nodeid();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bytes index = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          auto str = _internal_mutable_index();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bytes data = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          auto str = _internal_mutable_data();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 ledgerSeq = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_ledgerseq(&has_bits);
          ledgerseq_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* TMIndexedObject::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMIndexedObject)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes hash = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_hash(), target);
  }

  // optional bytes nodeID = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_nodeid(), target);
  }

  // optional bytes index = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_index(), target);
  }

  // optional bytes data = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_data(), target);
  }

  // optional uint32 ledgerSeq = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(5, this->_internal_ledgerseq(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMIndexedObject)
  return target;
}

size_t TMIndexedObject::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMIndexedObject)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional bytes hash = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_hash());
    }

    // optional bytes nodeID = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_nodeid());
    }

    // optional bytes index = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_index());
    }

    // optional bytes data = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_data());
    }

    // optional uint32 ledgerSeq = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_ledgerseq());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TMIndexedObject::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protocol.TMIndexedObject)
  GOOGLE_DCHECK_NE(&from, this);
  const TMIndexedObject* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<TMIndexedObject>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protocol.TMIndexedObject)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protocol.TMIndexedObject)
    MergeFrom(*source);
  }
}

void TMIndexedObject::MergeFrom(const TMIndexedObject& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMIndexedObject)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_hash(from._internal_hash());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_nodeid(from._internal_nodeid());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_index(from._internal_index());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_data(from._internal_data());
    }
    if (cached_has_bits & 0x00000010u) {
      ledgerseq_ = from.ledgerseq_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void TMIndexedObject::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protocol.TMIndexedObject)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMIndexedObject::CopyFrom(const TMIndexedObject& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMIndexedObject)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMIndexedObject::IsInitialized() const {
  return true;
}

void TMIndexedObject::InternalSwap(TMIndexedObject* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  hash_.Swap(&other->hash_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  nodeid_.Swap(&other->nodeid_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  index_.Swap(&other->index_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  data_.Swap(&other->data_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  swap(ledgerseq_, other->ledgerseq_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TMIndexedObject::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void TMGetObjectByHash::InitAsDefaultInstance() {
}
class TMGetObjectByHash::_Internal {
 public:
  using HasBits = decltype(std::declval<TMGetObjectByHash>()._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_query(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_seq(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_ledgerhash(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_fat(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000a) ^ 0x0000000a) != 0;
  }
};

TMGetObjectByHash::TMGetObjectByHash(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  objects_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:protocol.TMGetObjectByHash)
}
TMGetObjectByHash::TMGetObjectByHash(const TMGetObjectByHash& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      objects_(from.objects_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ledgerhash_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_ledgerhash()) {
    ledgerhash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_ledgerhash(),
      GetArena());
  }
  ::memcpy(&type_, &from.type_,
    static_cast<size_t>(reinterpret_cast<char*>(&fat_) -
    reinterpret_cast<char*>(&type_)) + sizeof(fat_));
  // @@protoc_insertion_point(copy_constructor:protocol.TMGetObjectByHash)
}

void TMGetObjectByHash::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_TMGetObjectByHash_ripple_2eproto.base);
  ledgerhash_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&type_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&fat_) -
      reinterpret_cast<char*>(&type_)) + sizeof(fat_));
}

TMGetObjectByHash::~TMGetObjectByHash() {
  // @@protoc_insertion_point(destructor:protocol.TMGetObjectByHash)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void TMGetObjectByHash::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  ledgerhash_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void TMGetObjectByHash::ArenaDtor(void* object) {
  TMGetObjectByHash* _this = reinterpret_cast< TMGetObjectByHash* >(object);
  (void)_this;
}
void TMGetObjectByHash::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TMGetObjectByHash::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TMGetObjectByHash& TMGetObjectByHash::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TMGetObjectByHash_ripple_2eproto.base);
  return *internal_default_instance();
}


void TMGetObjectByHash::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMGetObjectByHash)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  objects_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ledgerhash_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000001eu) {
    ::memset(&type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&fat_) -
        reinterpret_cast<char*>(&type_)) + sizeof(fat_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TMGetObjectByHash::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required .protocol.TMGetObjectByHash.ObjectType type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::protocol::TMGetObjectByHash_ObjectType_IsValid(val))) {
            _internal_set_type(static_cast<::protocol::TMGetObjectByHash_ObjectType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // required bool query = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_query(&has_bits);
          query_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 seq = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_seq(&has_bits);
          seq_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bytes ledgerHash = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          auto str = _internal_mutable_ledgerhash();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool fat = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_fat(&has_bits);
          fat_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .protocol.TMIndexedObject objects = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_objects(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* TMGetObjectByHash::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMGetObjectByHash)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .protocol.TMGetObjectByHash.ObjectType type = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  // required bool query = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->_internal_query(), target);
  }

  // optional uint32 seq = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_seq(), target);
  }

  // optional bytes ledgerHash = 4;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_ledgerhash(), target);
  }

  // optional bool fat = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(5, this->_internal_fat(), target);
  }

  // repeated .protocol.TMIndexedObject objects = 6;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_objects_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, this->_internal_objects(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMGetObjectByHash)
  return target;
}

size_t TMGetObjectByHash::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:protocol.TMGetObjectByHash)
  size_t total_size = 0;

  if (_internal_has_type()) {
    // required .protocol.TMGetObjectByHash.ObjectType type = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_type());
  }

  if (_internal_has_query()) {
    // required bool query = 2;
    total_size += 1 + 1;
  }

  return total_size;
}
size_t TMGetObjectByHash::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMGetObjectByHash)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x0000000a) ^ 0x0000000a) == 0) {  // All required fields are present.
    // required .protocol.TMGetObjectByHash.ObjectType type = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_type());

    // required bool query = 2;
    total_size += 1 + 1;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .protocol.TMIndexedObject objects = 6;
  total_size += 1UL * this->_internal_objects_size();
  for (const auto& msg : this->objects_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional bytes ledgerHash = 4;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_ledgerhash());
  }

  // optional uint32 seq = 3;
  if (cached_has_bits & 0x00000004u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_seq());
  }

  // optional bool fat = 5;
  if (cached_has_bits & 0x00000010u) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TMGetObjectByHash::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protocol.TMGetObjectByHash)
  GOOGLE_DCHECK_NE(&from, this);
  const TMGetObjectByHash* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<TMGetObjectByHash>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protocol.TMGetObjectByHash)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protocol.TMGetObjectByHash)
    MergeFrom(*source);
  }
}

void TMGetObjectByHash::MergeFrom(const TMGetObjectByHash& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMGetObjectByHash)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  objects_.MergeFrom(from.objects_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_ledgerhash(from._internal_ledgerhash());
    }
    if (cached_has_bits & 0x00000002u) {
      type_ = from.type_;
    }
    if (cached_has_bits & 0x00000004u) {
      seq_ = from.seq_;
    }
    if (cached_has_bits & 0x00000008u) {
      query_ = from.query_;
    }
    if (cached_has_bits & 0x00000010u) {
      fat_ = from.fat_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void TMGetObjectByHash::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protocol.TMGetObjectByHash)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMGetObjectByHash::CopyFrom(const TMGetObjectByHash& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMGetObjectByHash)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMGetObjectByHash::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void TMGetObjectByHash::InternalSwap(TMGetObjectByHash* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  objects_.InternalSwap(&other->objects_);
  ledgerhash_.Swap(&other->ledgerhash_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TMGetObjectByHash, fat_)
      + sizeof(TMGetObjectByHash::fat_)
      - PROTOBUF_FIELD_OFFSET(TMGetObjectByHash, type_)>(
          reinterpret_cast<char*>(&type_),
          reinterpret_cast<char*>(&other->type_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TMGetObjectByHash::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void TMLedgerNode::InitAsDefaultInstance() {
}
class TMLedgerNode::_Internal {
 public:
  using HasBits = decltype(std::declval<TMLedgerNode>()._has_bits_);
  static void set_has_nodedata(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_nodeid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

TMLedgerNode::TMLedgerNode(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:protocol.TMLedgerNode)
}
TMLedgerNode::TMLedgerNode(const TMLedgerNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  nodedata_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_nodedata()) {
    nodedata_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_nodedata(),
      GetArena());
  }
  nodeid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_nodeid()) {
    nodeid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_nodeid(),
      GetArena());
  }
  // @@protoc_insertion_point(copy_constructor:protocol.TMLedgerNode)
}

void TMLedgerNode::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_TMLedgerNode_ripple_2eproto.base);
  nodedata_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  nodeid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

TMLedgerNode::~TMLedgerNode() {
  // @@protoc_insertion_point(destructor:protocol.TMLedgerNode)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void TMLedgerNode::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  nodedata_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  nodeid_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void TMLedgerNode::ArenaDtor(void* object) {
  TMLedgerNode* _this = reinterpret_cast< TMLedgerNode* >(object);
  (void)_this;
}
void TMLedgerNode::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TMLedgerNode::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TMLedgerNode& TMLedgerNode::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TMLedgerNode_ripple_2eproto.base);
  return *internal_default_instance();
}


void TMLedgerNode::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMLedgerNode)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      nodedata_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      nodeid_.ClearNonDefaultToEmpty();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TMLedgerNode::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required bytes nodedata = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_nodedata();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bytes nodeid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_nodeid();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* TMLedgerNode::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMLedgerNode)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required bytes nodedata = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_nodedata(), target);
  }

  // optional bytes nodeid = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_nodeid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMLedgerNode)
  return target;
}

size_t TMLedgerNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMLedgerNode)
  size_t total_size = 0;

  // required bytes nodedata = 1;
  if (_internal_has_nodedata()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_nodedata());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bytes nodeid = 2;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000002u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_nodeid());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TMLedgerNode::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protocol.TMLedgerNode)
  GOOGLE_DCHECK_NE(&from, this);
  const TMLedgerNode* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<TMLedgerNode>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protocol.TMLedgerNode)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protocol.TMLedgerNode)
    MergeFrom(*source);
  }
}

void TMLedgerNode::MergeFrom(const TMLedgerNode& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMLedgerNode)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_nodedata(from._internal_nodedata());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_nodeid(from._internal_nodeid());
    }
  }
}

void TMLedgerNode::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protocol.TMLedgerNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMLedgerNode::CopyFrom(const TMLedgerNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMLedgerNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMLedgerNode::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void TMLedgerNode::InternalSwap(TMLedgerNode* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  nodedata_.Swap(&other->nodedata_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  nodeid_.Swap(&other->nodeid_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}

::PROTOBUF_NAMESPACE_ID::Metadata TMLedgerNode::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void TMGetLedger::InitAsDefaultInstance() {
}
class TMGetLedger::_Internal {
 public:
  using HasBits = decltype(std::declval<TMGetLedger>()._has_bits_);
  static void set_has_itype(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_ltype(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_ledgerhash(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ledgerseq(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_requestcookie(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_querytype(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_querydepth(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000002) ^ 0x00000002) != 0;
  }
};

TMGetLedger::TMGetLedger(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  nodeids_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:protocol.TMGetLedger)
}
TMGetLedger::TMGetLedger(const TMGetLedger& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      nodeids_(from.nodeids_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ledgerhash_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_ledgerhash()) {
    ledgerhash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_ledgerhash(),
      GetArena());
  }
  ::memcpy(&itype_, &from.itype_,
    static_cast<size_t>(reinterpret_cast<char*>(&querydepth_) -
    reinterpret_cast<char*>(&itype_)) + sizeof(querydepth_));
  // @@protoc_insertion_point(copy_constructor:protocol.TMGetLedger)
}

void TMGetLedger::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_TMGetLedger_ripple_2eproto.base);
  ledgerhash_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&itype_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&querydepth_) -
      reinterpret_cast<char*>(&itype_)) + sizeof(querydepth_));
}

TMGetLedger::~TMGetLedger() {
  // @@protoc_insertion_point(destructor:protocol.TMGetLedger)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void TMGetLedger::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  ledgerhash_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void TMGetLedger::ArenaDtor(void* object) {
  TMGetLedger* _this = reinterpret_cast< TMGetLedger* >(object);
  (void)_this;
}
void TMGetLedger::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TMGetLedger::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TMGetLedger& TMGetLedger::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TMGetLedger_ripple_2eproto.base);
  return *internal_default_instance();
}


void TMGetLedger::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMGetLedger)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  nodeids_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ledgerhash_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000007eu) {
    ::memset(&itype_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&querydepth_) -
        reinterpret_cast<char*>(&itype_)) + sizeof(querydepth_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TMGetLedger::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required .protocol.TMLedgerInfoType itype = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::protocol::TMLedgerInfoType_IsValid(val))) {
            _internal_set_itype(static_cast<::protocol::TMLedgerInfoType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional .protocol.TMLedgerType ltype = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::protocol::TMLedgerType_IsValid(val))) {
            _internal_set_ltype(static_cast<::protocol::TMLedgerType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional bytes ledgerHash = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          auto str = _internal_mutable_ledgerhash();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 ledgerSeq = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_ledgerseq(&has_bits);
          ledgerseq_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated bytes nodeIDs = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_nodeids();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else goto handle_unusual;
        continue;
      // optional uint64 requestCookie = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_requestcookie(&has_bits);
          requestcookie_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .protocol.TMQueryType queryType = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::protocol::TMQueryType_IsValid(val))) {
            _internal_set_querytype(static_cast<::protocol::TMQueryType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(7, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional uint32 queryDepth = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 64)) {
          _Internal::set_has_querydepth(&has_bits);
          querydepth_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* TMGetLedger::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMGetLedger)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .protocol.TMLedgerInfoType itype = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_itype(), target);
  }

  // optional .protocol.TMLedgerType ltype = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_ltype(), target);
  }

  // optional bytes ledgerHash = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_ledgerhash(), target);
  }

  // optional uint32 ledgerSeq = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(4, this->_internal_ledgerseq(), target);
  }

  // repeated bytes nodeIDs = 5;
  for (int i = 0, n = this->_internal_nodeids_size(); i < n; i++) {
    const auto& s = this->_internal_nodeids(i);
    target = stream->WriteBytes(5, s, target);
  }

  // optional uint64 requestCookie = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(6, this->_internal_requestcookie(), target);
  }

  // optional .protocol.TMQueryType queryType = 7;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      7, this->_internal_querytype(), target);
  }

  // optional uint32 queryDepth = 8;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(8, this->_internal_querydepth(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMGetLedger)
  return target;
}

size_t TMGetLedger::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMGetLedger)
  size_t total_size = 0;

  // required .protocol.TMLedgerInfoType itype = 1;
  if (_internal_has_itype()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_itype());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated bytes nodeIDs = 5;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(nodeids_.size());
  for (int i = 0, n = nodeids_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
      nodeids_.Get(i));
  }

  // optional bytes ledgerHash = 3;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_ledgerhash());
  }

  if (cached_has_bits & 0x0000007cu) {
    // optional .protocol.TMLedgerType ltype = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_ltype());
    }

    // optional uint32 ledgerSeq = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_ledgerseq());
    }

    // optional .protocol.TMQueryType queryType = 7;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_querytype());
    }

    // optional uint64 requestCookie = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_requestcookie());
    }

    // optional uint32 queryDepth = 8;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_querydepth());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TMGetLedger::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protocol.TMGetLedger)
  GOOGLE_DCHECK_NE(&from, this);
  const TMGetLedger* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<TMGetLedger>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protocol.TMGetLedger)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protocol.TMGetLedger)
    MergeFrom(*source);
  }
}

void TMGetLedger::MergeFrom(const TMGetLedger& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMGetLedger)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  nodeids_.MergeFrom(from.nodeids_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_ledgerhash(from._internal_ledgerhash());
    }
    if (cached_has_bits & 0x00000002u) {
      itype_ = from.itype_;
    }
    if (cached_has_bits & 0x00000004u) {
      ltype_ = from.ltype_;
    }
    if (cached_has_bits & 0x00000008u) {
      ledgerseq_ = from.ledgerseq_;
    }
    if (cached_has_bits & 0x00000010u) {
      querytype_ = from.querytype_;
    }
    if (cached_has_bits & 0x00000020u) {
      requestcookie_ = from.requestcookie_;
    }
    if (cached_has_bits & 0x00000040u) {
      querydepth_ = from.querydepth_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void TMGetLedger::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protocol.TMGetLedger)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMGetLedger::CopyFrom(const TMGetLedger& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMGetLedger)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMGetLedger::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void TMGetLedger::InternalSwap(TMGetLedger* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  nodeids_.InternalSwap(&other->nodeids_);
  ledgerhash_.Swap(&other->ledgerhash_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TMGetLedger, querydepth_)
      + sizeof(TMGetLedger::querydepth_)
      - PROTOBUF_FIELD_OFFSET(TMGetLedger, itype_)>(
          reinterpret_cast<char*>(&itype_),
          reinterpret_cast<char*>(&other->itype_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TMGetLedger::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void TMLedgerData::InitAsDefaultInstance() {
}
class TMLedgerData::_Internal {
 public:
  using HasBits = decltype(std::declval<TMLedgerData>()._has_bits_);
  static void set_has_ledgerhash(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ledgerseq(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_requestcookie(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_error(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

TMLedgerData::TMLedgerData(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  nodes_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:protocol.TMLedgerData)
}
TMLedgerData::TMLedgerData(const TMLedgerData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      nodes_(from.nodes_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ledgerhash_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_ledgerhash()) {
    ledgerhash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_ledgerhash(),
      GetArena());
  }
  ::memcpy(&ledgerseq_, &from.ledgerseq_,
    static_cast<size_t>(reinterpret_cast<char*>(&error_) -
    reinterpret_cast<char*>(&ledgerseq_)) + sizeof(error_));
  // @@protoc_insertion_point(copy_constructor:protocol.TMLedgerData)
}

void TMLedgerData::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_TMLedgerData_ripple_2eproto.base);
  ledgerhash_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&ledgerseq_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&requestcookie_) -
      reinterpret_cast<char*>(&ledgerseq_)) + sizeof(requestcookie_));
  error_ = 1;
}

TMLedgerData::~TMLedgerData() {
  // @@protoc_insertion_point(destructor:protocol.TMLedgerData)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void TMLedgerData::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  ledgerhash_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void TMLedgerData::ArenaDtor(void* object) {
  TMLedgerData* _this = reinterpret_cast< TMLedgerData* >(object);
  (void)_this;
}
void TMLedgerData::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TMLedgerData::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TMLedgerData& TMLedgerData::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TMLedgerData_ripple_2eproto.base);
  return *internal_default_instance();
}


void TMLedgerData::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMLedgerData)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  nodes_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ledgerhash_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000001eu) {
    ::memset(&ledgerseq_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&requestcookie_) -
        reinterpret_cast<char*>(&ledgerseq_)) + sizeof(requestcookie_));
    error_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TMLedgerData::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required bytes ledgerHash = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_ledgerhash();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required uint32 ledgerSeq = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_ledgerseq(&has_bits);
          ledgerseq_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required .protocol.TMLedgerInfoType type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::protocol::TMLedgerInfoType_IsValid(val))) {
            _internal_set_type(static_cast<::protocol::TMLedgerInfoType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // repeated .protocol.TMLedgerNode nodes = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_nodes(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else goto handle_unusual;
        continue;
      // optional uint32 requestCookie = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_requestcookie(&has_bits);
          requestcookie_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .protocol.TMReplyError error = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::protocol::TMReplyError_IsValid(val))) {
            _internal_set_error(static_cast<::protocol::TMReplyError>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(6, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* TMLedgerData::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMLedgerData)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required bytes ledgerHash = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_ledgerhash(), target);
  }

  // required uint32 ledgerSeq = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_ledgerseq(), target);
  }

  // required .protocol.TMLedgerInfoType type = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      3, this->_internal_type(), target);
  }

  // repeated .protocol.TMLedgerNode nodes = 4;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_nodes_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, this->_internal_nodes(i), target, stream);
  }

  // optional uint32 requestCookie = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(5, this->_internal_requestcookie(), target);
  }

  // optional .protocol.TMReplyError error = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      6, this->_internal_error(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMLedgerData)
  return target;
}

size_t TMLedgerData::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:protocol.TMLedgerData)
  size_t total_size = 0;

  if (_internal_has_ledgerhash()) {
    // required bytes ledgerHash = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_ledgerhash());
  }

  if (_internal_has_ledgerseq()) {
    // required uint32 ledgerSeq = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_ledgerseq());
  }

  if (_internal_has_type()) {
    // required .protocol.TMLedgerInfoType type = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_type());
  }

  return total_size;
}
size_t TMLedgerData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMLedgerData)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required bytes ledgerHash = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_ledgerhash());

    // required uint32 ledgerSeq = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_ledgerseq());

    // required .protocol.TMLedgerInfoType type = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .protocol.TMLedgerNode nodes = 4;
  total_size += 1UL * this->_internal_nodes_size();
  for (const auto& msg : this->nodes_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000018u) {
    // optional uint32 requestCookie = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_requestcookie());
    }

    // optional .protocol.TMReplyError error = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_error());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TMLedgerData::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protocol.TMLedgerData)
  GOOGLE_DCHECK_NE(&from, this);
  const TMLedgerData* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<TMLedgerData>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protocol.TMLedgerData)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protocol.TMLedgerData)
    MergeFrom(*source);
  }
}

void TMLedgerData::MergeFrom(const TMLedgerData& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMLedgerData)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  nodes_.MergeFrom(from.nodes_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_ledgerhash(from._internal_ledgerhash());
    }
    if (cached_has_bits & 0x00000002u) {
      ledgerseq_ = from.ledgerseq_;
    }
    if (cached_has_bits & 0x00000004u) {
      type_ = from.type_;
    }
    if (cached_has_bits & 0x00000008u) {
      requestcookie_ = from.requestcookie_;
    }
    if (cached_has_bits & 0x00000010u) {
      error_ = from.error_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void TMLedgerData::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protocol.TMLedgerData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMLedgerData::CopyFrom(const TMLedgerData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMLedgerData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMLedgerData::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(nodes_)) return false;
  return true;
}

void TMLedgerData::InternalSwap(TMLedgerData* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  nodes_.InternalSwap(&other->nodes_);
  ledgerhash_.Swap(&other->ledgerhash_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TMLedgerData, requestcookie_)
      + sizeof(TMLedgerData::requestcookie_)
      - PROTOBUF_FIELD_OFFSET(TMLedgerData, ledgerseq_)>(
          reinterpret_cast<char*>(&ledgerseq_),
          reinterpret_cast<char*>(&other->ledgerseq_));
  swap(error_, other->error_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TMLedgerData::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void TMPing::InitAsDefaultInstance() {
}
class TMPing::_Internal {
 public:
  using HasBits = decltype(std::declval<TMPing>()._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_seq(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_pingtime(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_nettime(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

TMPing::TMPing(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:protocol.TMPing)
}
TMPing::TMPing(const TMPing& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&type_, &from.type_,
    static_cast<size_t>(reinterpret_cast<char*>(&nettime_) -
    reinterpret_cast<char*>(&type_)) + sizeof(nettime_));
  // @@protoc_insertion_point(copy_constructor:protocol.TMPing)
}

void TMPing::SharedCtor() {
  ::memset(&type_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&nettime_) -
      reinterpret_cast<char*>(&type_)) + sizeof(nettime_));
}

TMPing::~TMPing() {
  // @@protoc_insertion_point(destructor:protocol.TMPing)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void TMPing::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void TMPing::ArenaDtor(void* object) {
  TMPing* _this = reinterpret_cast< TMPing* >(object);
  (void)_this;
}
void TMPing::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void TMPing::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TMPing& TMPing::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TMPing_ripple_2eproto.base);
  return *internal_default_instance();
}


void TMPing::Clear() {
// @@protoc_insertion_point(message_clear_start:protocol.TMPing)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&nettime_) -
        reinterpret_cast<char*>(&type_)) + sizeof(nettime_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TMPing::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required .protocol.TMPing.pingType type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::protocol::TMPing_pingType_IsValid(val))) {
            _internal_set_type(static_cast<::protocol::TMPing_pingType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional uint32 seq = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_seq(&has_bits);
          seq_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 pingTime = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_pingtime(&has_bits);
          pingtime_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 netTime = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_nettime(&has_bits);
          nettime_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* TMPing::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:protocol.TMPing)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .protocol.TMPing.pingType type = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  // optional uint32 seq = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_seq(), target);
  }

  // optional uint64 pingTime = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(3, this->_internal_pingtime(), target);
  }

  // optional uint64 netTime = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(4, this->_internal_nettime(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:protocol.TMPing)
  return target;
}

size_t TMPing::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:protocol.TMPing)
  size_t total_size = 0;

  // required .protocol.TMPing.pingType type = 1;
  if (_internal_has_type()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_type());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000eu) {
    // optional uint32 seq = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_seq());
    }

    // optional uint64 pingTime = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_pingtime());
    }

    // optional uint64 netTime = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_nettime());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TMPing::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protocol.TMPing)
  GOOGLE_DCHECK_NE(&from, this);
  const TMPing* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<TMPing>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protocol.TMPing)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protocol.TMPing)
    MergeFrom(*source);
  }
}

void TMPing::MergeFrom(const TMPing& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protocol.TMPing)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      type_ = from.type_;
    }
    if (cached_has_bits & 0x00000002u) {
      seq_ = from.seq_;
    }
    if (cached_has_bits & 0x00000004u) {
      pingtime_ = from.pingtime_;
    }
    if (cached_has_bits & 0x00000008u) {
      nettime_ = from.nettime_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void TMPing::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protocol.TMPing)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TMPing::CopyFrom(const TMPing& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protocol.TMPing)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TMPing::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void TMPing::InternalSwap(TMPing* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TMPing, nettime_)
      + sizeof(TMPing::nettime_)
      - PROTOBUF_FIELD_OFFSET(TMPing, type_)>(
          reinterpret_cast<char*>(&type_),
          reinterpret_cast<char*>(&other->type_));
}

::PROTOBUF_NAMESPACE_ID::Metadata TMPing::GetMetadata() const {
  return GetMetadataStatic();
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace protocol
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::protocol::TMManifest* Arena::CreateMaybeMessage< ::protocol::TMManifest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::TMManifest >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMManifests* Arena::CreateMaybeMessage< ::protocol::TMManifests >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::TMManifests >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMClusterNode* Arena::CreateMaybeMessage< ::protocol::TMClusterNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::TMClusterNode >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMLoadSource* Arena::CreateMaybeMessage< ::protocol::TMLoadSource >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::TMLoadSource >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMCluster* Arena::CreateMaybeMessage< ::protocol::TMCluster >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::TMCluster >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMGetShardInfo* Arena::CreateMaybeMessage< ::protocol::TMGetShardInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::TMGetShardInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMShardInfo* Arena::CreateMaybeMessage< ::protocol::TMShardInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::TMShardInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMLink* Arena::CreateMaybeMessage< ::protocol::TMLink >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::TMLink >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMGetPeerShardInfo* Arena::CreateMaybeMessage< ::protocol::TMGetPeerShardInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::TMGetPeerShardInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMPeerShardInfo* Arena::CreateMaybeMessage< ::protocol::TMPeerShardInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::TMPeerShardInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMTransaction* Arena::CreateMaybeMessage< ::protocol::TMTransaction >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::TMTransaction >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMStatusChange* Arena::CreateMaybeMessage< ::protocol::TMStatusChange >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::TMStatusChange >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMProposeSet* Arena::CreateMaybeMessage< ::protocol::TMProposeSet >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::TMProposeSet >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMHaveTransactionSet* Arena::CreateMaybeMessage< ::protocol::TMHaveTransactionSet >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::TMHaveTransactionSet >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMValidatorList* Arena::CreateMaybeMessage< ::protocol::TMValidatorList >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::TMValidatorList >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMValidation* Arena::CreateMaybeMessage< ::protocol::TMValidation >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::TMValidation >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMIPv4Endpoint* Arena::CreateMaybeMessage< ::protocol::TMIPv4Endpoint >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::TMIPv4Endpoint >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMEndpoint* Arena::CreateMaybeMessage< ::protocol::TMEndpoint >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::TMEndpoint >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMEndpoints_TMEndpointv2* Arena::CreateMaybeMessage< ::protocol::TMEndpoints_TMEndpointv2 >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::TMEndpoints_TMEndpointv2 >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMEndpoints* Arena::CreateMaybeMessage< ::protocol::TMEndpoints >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::TMEndpoints >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMIndexedObject* Arena::CreateMaybeMessage< ::protocol::TMIndexedObject >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::TMIndexedObject >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMGetObjectByHash* Arena::CreateMaybeMessage< ::protocol::TMGetObjectByHash >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::TMGetObjectByHash >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMLedgerNode* Arena::CreateMaybeMessage< ::protocol::TMLedgerNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::TMLedgerNode >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMGetLedger* Arena::CreateMaybeMessage< ::protocol::TMGetLedger >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::TMGetLedger >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMLedgerData* Arena::CreateMaybeMessage< ::protocol::TMLedgerData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::TMLedgerData >(arena);
}
template<> PROTOBUF_NOINLINE ::protocol::TMPing* Arena::CreateMaybeMessage< ::protocol::TMPing >(Arena* arena) {
  return Arena::CreateMessageInternal< ::protocol::TMPing >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
