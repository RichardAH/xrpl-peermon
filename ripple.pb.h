// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ripple.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_ripple_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_ripple_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3012000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3012004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_ripple_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_ripple_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[35]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_ripple_2eproto;
namespace protocol {
class TMCluster;
class TMClusterDefaultTypeInternal;
extern TMClusterDefaultTypeInternal _TMCluster_default_instance_;
class TMClusterNode;
class TMClusterNodeDefaultTypeInternal;
extern TMClusterNodeDefaultTypeInternal _TMClusterNode_default_instance_;
class TMEndpoints;
class TMEndpointsDefaultTypeInternal;
extern TMEndpointsDefaultTypeInternal _TMEndpoints_default_instance_;
class TMEndpoints_TMEndpointv2;
class TMEndpoints_TMEndpointv2DefaultTypeInternal;
extern TMEndpoints_TMEndpointv2DefaultTypeInternal _TMEndpoints_TMEndpointv2_default_instance_;
class TMGetLedger;
class TMGetLedgerDefaultTypeInternal;
extern TMGetLedgerDefaultTypeInternal _TMGetLedger_default_instance_;
class TMGetObjectByHash;
class TMGetObjectByHashDefaultTypeInternal;
extern TMGetObjectByHashDefaultTypeInternal _TMGetObjectByHash_default_instance_;
class TMGetPeerShardInfo;
class TMGetPeerShardInfoDefaultTypeInternal;
extern TMGetPeerShardInfoDefaultTypeInternal _TMGetPeerShardInfo_default_instance_;
class TMGetPeerShardInfoV2;
class TMGetPeerShardInfoV2DefaultTypeInternal;
extern TMGetPeerShardInfoV2DefaultTypeInternal _TMGetPeerShardInfoV2_default_instance_;
class TMHaveTransactionSet;
class TMHaveTransactionSetDefaultTypeInternal;
extern TMHaveTransactionSetDefaultTypeInternal _TMHaveTransactionSet_default_instance_;
class TMHaveTransactions;
class TMHaveTransactionsDefaultTypeInternal;
extern TMHaveTransactionsDefaultTypeInternal _TMHaveTransactions_default_instance_;
class TMIndexedObject;
class TMIndexedObjectDefaultTypeInternal;
extern TMIndexedObjectDefaultTypeInternal _TMIndexedObject_default_instance_;
class TMLedgerData;
class TMLedgerDataDefaultTypeInternal;
extern TMLedgerDataDefaultTypeInternal _TMLedgerData_default_instance_;
class TMLedgerNode;
class TMLedgerNodeDefaultTypeInternal;
extern TMLedgerNodeDefaultTypeInternal _TMLedgerNode_default_instance_;
class TMLink;
class TMLinkDefaultTypeInternal;
extern TMLinkDefaultTypeInternal _TMLink_default_instance_;
class TMLoadSource;
class TMLoadSourceDefaultTypeInternal;
extern TMLoadSourceDefaultTypeInternal _TMLoadSource_default_instance_;
class TMManifest;
class TMManifestDefaultTypeInternal;
extern TMManifestDefaultTypeInternal _TMManifest_default_instance_;
class TMManifests;
class TMManifestsDefaultTypeInternal;
extern TMManifestsDefaultTypeInternal _TMManifests_default_instance_;
class TMPeerShardInfo;
class TMPeerShardInfoDefaultTypeInternal;
extern TMPeerShardInfoDefaultTypeInternal _TMPeerShardInfo_default_instance_;
class TMPeerShardInfoV2;
class TMPeerShardInfoV2DefaultTypeInternal;
extern TMPeerShardInfoV2DefaultTypeInternal _TMPeerShardInfoV2_default_instance_;
class TMPeerShardInfoV2_TMIncomplete;
class TMPeerShardInfoV2_TMIncompleteDefaultTypeInternal;
extern TMPeerShardInfoV2_TMIncompleteDefaultTypeInternal _TMPeerShardInfoV2_TMIncomplete_default_instance_;
class TMPing;
class TMPingDefaultTypeInternal;
extern TMPingDefaultTypeInternal _TMPing_default_instance_;
class TMProofPathRequest;
class TMProofPathRequestDefaultTypeInternal;
extern TMProofPathRequestDefaultTypeInternal _TMProofPathRequest_default_instance_;
class TMProofPathResponse;
class TMProofPathResponseDefaultTypeInternal;
extern TMProofPathResponseDefaultTypeInternal _TMProofPathResponse_default_instance_;
class TMProposeSet;
class TMProposeSetDefaultTypeInternal;
extern TMProposeSetDefaultTypeInternal _TMProposeSet_default_instance_;
class TMPublicKey;
class TMPublicKeyDefaultTypeInternal;
extern TMPublicKeyDefaultTypeInternal _TMPublicKey_default_instance_;
class TMReplayDeltaRequest;
class TMReplayDeltaRequestDefaultTypeInternal;
extern TMReplayDeltaRequestDefaultTypeInternal _TMReplayDeltaRequest_default_instance_;
class TMReplayDeltaResponse;
class TMReplayDeltaResponseDefaultTypeInternal;
extern TMReplayDeltaResponseDefaultTypeInternal _TMReplayDeltaResponse_default_instance_;
class TMSquelch;
class TMSquelchDefaultTypeInternal;
extern TMSquelchDefaultTypeInternal _TMSquelch_default_instance_;
class TMStatusChange;
class TMStatusChangeDefaultTypeInternal;
extern TMStatusChangeDefaultTypeInternal _TMStatusChange_default_instance_;
class TMTransaction;
class TMTransactionDefaultTypeInternal;
extern TMTransactionDefaultTypeInternal _TMTransaction_default_instance_;
class TMTransactions;
class TMTransactionsDefaultTypeInternal;
extern TMTransactionsDefaultTypeInternal _TMTransactions_default_instance_;
class TMValidation;
class TMValidationDefaultTypeInternal;
extern TMValidationDefaultTypeInternal _TMValidation_default_instance_;
class TMValidatorList;
class TMValidatorListDefaultTypeInternal;
extern TMValidatorListDefaultTypeInternal _TMValidatorList_default_instance_;
class TMValidatorListCollection;
class TMValidatorListCollectionDefaultTypeInternal;
extern TMValidatorListCollectionDefaultTypeInternal _TMValidatorListCollection_default_instance_;
class ValidatorBlobInfo;
class ValidatorBlobInfoDefaultTypeInternal;
extern ValidatorBlobInfoDefaultTypeInternal _ValidatorBlobInfo_default_instance_;
}  // namespace protocol
PROTOBUF_NAMESPACE_OPEN
template<> ::protocol::TMCluster* Arena::CreateMaybeMessage<::protocol::TMCluster>(Arena*);
template<> ::protocol::TMClusterNode* Arena::CreateMaybeMessage<::protocol::TMClusterNode>(Arena*);
template<> ::protocol::TMEndpoints* Arena::CreateMaybeMessage<::protocol::TMEndpoints>(Arena*);
template<> ::protocol::TMEndpoints_TMEndpointv2* Arena::CreateMaybeMessage<::protocol::TMEndpoints_TMEndpointv2>(Arena*);
template<> ::protocol::TMGetLedger* Arena::CreateMaybeMessage<::protocol::TMGetLedger>(Arena*);
template<> ::protocol::TMGetObjectByHash* Arena::CreateMaybeMessage<::protocol::TMGetObjectByHash>(Arena*);
template<> ::protocol::TMGetPeerShardInfo* Arena::CreateMaybeMessage<::protocol::TMGetPeerShardInfo>(Arena*);
template<> ::protocol::TMGetPeerShardInfoV2* Arena::CreateMaybeMessage<::protocol::TMGetPeerShardInfoV2>(Arena*);
template<> ::protocol::TMHaveTransactionSet* Arena::CreateMaybeMessage<::protocol::TMHaveTransactionSet>(Arena*);
template<> ::protocol::TMHaveTransactions* Arena::CreateMaybeMessage<::protocol::TMHaveTransactions>(Arena*);
template<> ::protocol::TMIndexedObject* Arena::CreateMaybeMessage<::protocol::TMIndexedObject>(Arena*);
template<> ::protocol::TMLedgerData* Arena::CreateMaybeMessage<::protocol::TMLedgerData>(Arena*);
template<> ::protocol::TMLedgerNode* Arena::CreateMaybeMessage<::protocol::TMLedgerNode>(Arena*);
template<> ::protocol::TMLink* Arena::CreateMaybeMessage<::protocol::TMLink>(Arena*);
template<> ::protocol::TMLoadSource* Arena::CreateMaybeMessage<::protocol::TMLoadSource>(Arena*);
template<> ::protocol::TMManifest* Arena::CreateMaybeMessage<::protocol::TMManifest>(Arena*);
template<> ::protocol::TMManifests* Arena::CreateMaybeMessage<::protocol::TMManifests>(Arena*);
template<> ::protocol::TMPeerShardInfo* Arena::CreateMaybeMessage<::protocol::TMPeerShardInfo>(Arena*);
template<> ::protocol::TMPeerShardInfoV2* Arena::CreateMaybeMessage<::protocol::TMPeerShardInfoV2>(Arena*);
template<> ::protocol::TMPeerShardInfoV2_TMIncomplete* Arena::CreateMaybeMessage<::protocol::TMPeerShardInfoV2_TMIncomplete>(Arena*);
template<> ::protocol::TMPing* Arena::CreateMaybeMessage<::protocol::TMPing>(Arena*);
template<> ::protocol::TMProofPathRequest* Arena::CreateMaybeMessage<::protocol::TMProofPathRequest>(Arena*);
template<> ::protocol::TMProofPathResponse* Arena::CreateMaybeMessage<::protocol::TMProofPathResponse>(Arena*);
template<> ::protocol::TMProposeSet* Arena::CreateMaybeMessage<::protocol::TMProposeSet>(Arena*);
template<> ::protocol::TMPublicKey* Arena::CreateMaybeMessage<::protocol::TMPublicKey>(Arena*);
template<> ::protocol::TMReplayDeltaRequest* Arena::CreateMaybeMessage<::protocol::TMReplayDeltaRequest>(Arena*);
template<> ::protocol::TMReplayDeltaResponse* Arena::CreateMaybeMessage<::protocol::TMReplayDeltaResponse>(Arena*);
template<> ::protocol::TMSquelch* Arena::CreateMaybeMessage<::protocol::TMSquelch>(Arena*);
template<> ::protocol::TMStatusChange* Arena::CreateMaybeMessage<::protocol::TMStatusChange>(Arena*);
template<> ::protocol::TMTransaction* Arena::CreateMaybeMessage<::protocol::TMTransaction>(Arena*);
template<> ::protocol::TMTransactions* Arena::CreateMaybeMessage<::protocol::TMTransactions>(Arena*);
template<> ::protocol::TMValidation* Arena::CreateMaybeMessage<::protocol::TMValidation>(Arena*);
template<> ::protocol::TMValidatorList* Arena::CreateMaybeMessage<::protocol::TMValidatorList>(Arena*);
template<> ::protocol::TMValidatorListCollection* Arena::CreateMaybeMessage<::protocol::TMValidatorListCollection>(Arena*);
template<> ::protocol::ValidatorBlobInfo* Arena::CreateMaybeMessage<::protocol::ValidatorBlobInfo>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace protocol {

enum TMGetObjectByHash_ObjectType : int {
  TMGetObjectByHash_ObjectType_otUNKNOWN = 0,
  TMGetObjectByHash_ObjectType_otLEDGER = 1,
  TMGetObjectByHash_ObjectType_otTRANSACTION = 2,
  TMGetObjectByHash_ObjectType_otTRANSACTION_NODE = 3,
  TMGetObjectByHash_ObjectType_otSTATE_NODE = 4,
  TMGetObjectByHash_ObjectType_otCAS_OBJECT = 5,
  TMGetObjectByHash_ObjectType_otFETCH_PACK = 6,
  TMGetObjectByHash_ObjectType_otTRANSACTIONS = 7
};
bool TMGetObjectByHash_ObjectType_IsValid(int value);
constexpr TMGetObjectByHash_ObjectType TMGetObjectByHash_ObjectType_ObjectType_MIN = TMGetObjectByHash_ObjectType_otUNKNOWN;
constexpr TMGetObjectByHash_ObjectType TMGetObjectByHash_ObjectType_ObjectType_MAX = TMGetObjectByHash_ObjectType_otTRANSACTIONS;
constexpr int TMGetObjectByHash_ObjectType_ObjectType_ARRAYSIZE = TMGetObjectByHash_ObjectType_ObjectType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TMGetObjectByHash_ObjectType_descriptor();
template<typename T>
inline const std::string& TMGetObjectByHash_ObjectType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TMGetObjectByHash_ObjectType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TMGetObjectByHash_ObjectType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TMGetObjectByHash_ObjectType_descriptor(), enum_t_value);
}
inline bool TMGetObjectByHash_ObjectType_Parse(
    const std::string& name, TMGetObjectByHash_ObjectType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TMGetObjectByHash_ObjectType>(
    TMGetObjectByHash_ObjectType_descriptor(), name, value);
}
enum TMPing_pingType : int {
  TMPing_pingType_ptPING = 0,
  TMPing_pingType_ptPONG = 1
};
bool TMPing_pingType_IsValid(int value);
constexpr TMPing_pingType TMPing_pingType_pingType_MIN = TMPing_pingType_ptPING;
constexpr TMPing_pingType TMPing_pingType_pingType_MAX = TMPing_pingType_ptPONG;
constexpr int TMPing_pingType_pingType_ARRAYSIZE = TMPing_pingType_pingType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TMPing_pingType_descriptor();
template<typename T>
inline const std::string& TMPing_pingType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TMPing_pingType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TMPing_pingType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TMPing_pingType_descriptor(), enum_t_value);
}
inline bool TMPing_pingType_Parse(
    const std::string& name, TMPing_pingType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TMPing_pingType>(
    TMPing_pingType_descriptor(), name, value);
}
enum MessageType : int {
  mtMANIFESTS = 2,
  mtPING = 3,
  mtCLUSTER = 5,
  mtENDPOINTS = 15,
  mtTRANSACTION = 30,
  mtGET_LEDGER = 31,
  mtLEDGER_DATA = 32,
  mtPROPOSE_LEDGER = 33,
  mtSTATUS_CHANGE = 34,
  mtHAVE_SET = 35,
  mtVALIDATION = 41,
  mtGET_OBJECTS = 42,
  mtGET_SHARD_INFO = 50,
  mtSHARD_INFO = 51,
  mtGET_PEER_SHARD_INFO = 52,
  mtPEER_SHARD_INFO = 53,
  mtVALIDATORLIST = 54,
  mtSQUELCH = 55,
  mtVALIDATORLISTCOLLECTION = 56,
  mtPROOF_PATH_REQ = 57,
  mtPROOF_PATH_RESPONSE = 58,
  mtREPLAY_DELTA_REQ = 59,
  mtREPLAY_DELTA_RESPONSE = 60,
  mtGET_PEER_SHARD_INFO_V2 = 61,
  mtPEER_SHARD_INFO_V2 = 62,
  mtHAVE_TRANSACTIONS = 63,
  mtTRANSACTIONS = 64
};
bool MessageType_IsValid(int value);
constexpr MessageType MessageType_MIN = mtMANIFESTS;
constexpr MessageType MessageType_MAX = mtTRANSACTIONS;
constexpr int MessageType_ARRAYSIZE = MessageType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MessageType_descriptor();
template<typename T>
inline const std::string& MessageType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MessageType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MessageType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MessageType_descriptor(), enum_t_value);
}
inline bool MessageType_Parse(
    const std::string& name, MessageType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MessageType>(
    MessageType_descriptor(), name, value);
}
enum TransactionStatus : int {
  tsNEW = 1,
  tsCURRENT = 2,
  tsCOMMITED = 3,
  tsREJECT_CONFLICT = 4,
  tsREJECT_INVALID = 5,
  tsREJECT_FUNDS = 6,
  tsHELD_SEQ = 7,
  tsHELD_LEDGER = 8
};
bool TransactionStatus_IsValid(int value);
constexpr TransactionStatus TransactionStatus_MIN = tsNEW;
constexpr TransactionStatus TransactionStatus_MAX = tsHELD_LEDGER;
constexpr int TransactionStatus_ARRAYSIZE = TransactionStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TransactionStatus_descriptor();
template<typename T>
inline const std::string& TransactionStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TransactionStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TransactionStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TransactionStatus_descriptor(), enum_t_value);
}
inline bool TransactionStatus_Parse(
    const std::string& name, TransactionStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TransactionStatus>(
    TransactionStatus_descriptor(), name, value);
}
enum NodeStatus : int {
  nsCONNECTING = 1,
  nsCONNECTED = 2,
  nsMONITORING = 3,
  nsVALIDATING = 4,
  nsSHUTTING = 5
};
bool NodeStatus_IsValid(int value);
constexpr NodeStatus NodeStatus_MIN = nsCONNECTING;
constexpr NodeStatus NodeStatus_MAX = nsSHUTTING;
constexpr int NodeStatus_ARRAYSIZE = NodeStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* NodeStatus_descriptor();
template<typename T>
inline const std::string& NodeStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, NodeStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function NodeStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    NodeStatus_descriptor(), enum_t_value);
}
inline bool NodeStatus_Parse(
    const std::string& name, NodeStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<NodeStatus>(
    NodeStatus_descriptor(), name, value);
}
enum NodeEvent : int {
  neCLOSING_LEDGER = 1,
  neACCEPTED_LEDGER = 2,
  neSWITCHED_LEDGER = 3,
  neLOST_SYNC = 4
};
bool NodeEvent_IsValid(int value);
constexpr NodeEvent NodeEvent_MIN = neCLOSING_LEDGER;
constexpr NodeEvent NodeEvent_MAX = neLOST_SYNC;
constexpr int NodeEvent_ARRAYSIZE = NodeEvent_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* NodeEvent_descriptor();
template<typename T>
inline const std::string& NodeEvent_Name(T enum_t_value) {
  static_assert(::std::is_same<T, NodeEvent>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function NodeEvent_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    NodeEvent_descriptor(), enum_t_value);
}
inline bool NodeEvent_Parse(
    const std::string& name, NodeEvent* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<NodeEvent>(
    NodeEvent_descriptor(), name, value);
}
enum TxSetStatus : int {
  tsHAVE = 1,
  tsCAN_GET = 2,
  tsNEED = 3
};
bool TxSetStatus_IsValid(int value);
constexpr TxSetStatus TxSetStatus_MIN = tsHAVE;
constexpr TxSetStatus TxSetStatus_MAX = tsNEED;
constexpr int TxSetStatus_ARRAYSIZE = TxSetStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TxSetStatus_descriptor();
template<typename T>
inline const std::string& TxSetStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TxSetStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TxSetStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TxSetStatus_descriptor(), enum_t_value);
}
inline bool TxSetStatus_Parse(
    const std::string& name, TxSetStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TxSetStatus>(
    TxSetStatus_descriptor(), name, value);
}
enum TMLedgerInfoType : int {
  liBASE = 0,
  liTX_NODE = 1,
  liAS_NODE = 2,
  liTS_CANDIDATE = 3
};
bool TMLedgerInfoType_IsValid(int value);
constexpr TMLedgerInfoType TMLedgerInfoType_MIN = liBASE;
constexpr TMLedgerInfoType TMLedgerInfoType_MAX = liTS_CANDIDATE;
constexpr int TMLedgerInfoType_ARRAYSIZE = TMLedgerInfoType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TMLedgerInfoType_descriptor();
template<typename T>
inline const std::string& TMLedgerInfoType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TMLedgerInfoType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TMLedgerInfoType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TMLedgerInfoType_descriptor(), enum_t_value);
}
inline bool TMLedgerInfoType_Parse(
    const std::string& name, TMLedgerInfoType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TMLedgerInfoType>(
    TMLedgerInfoType_descriptor(), name, value);
}
enum TMLedgerType : int {
  ltACCEPTED = 0,
  ltCURRENT = 1,
  ltCLOSED = 2
};
bool TMLedgerType_IsValid(int value);
constexpr TMLedgerType TMLedgerType_MIN = ltACCEPTED;
constexpr TMLedgerType TMLedgerType_MAX = ltCLOSED;
constexpr int TMLedgerType_ARRAYSIZE = TMLedgerType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TMLedgerType_descriptor();
template<typename T>
inline const std::string& TMLedgerType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TMLedgerType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TMLedgerType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TMLedgerType_descriptor(), enum_t_value);
}
inline bool TMLedgerType_Parse(
    const std::string& name, TMLedgerType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TMLedgerType>(
    TMLedgerType_descriptor(), name, value);
}
enum TMQueryType : int {
  qtINDIRECT = 0
};
bool TMQueryType_IsValid(int value);
constexpr TMQueryType TMQueryType_MIN = qtINDIRECT;
constexpr TMQueryType TMQueryType_MAX = qtINDIRECT;
constexpr int TMQueryType_ARRAYSIZE = TMQueryType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TMQueryType_descriptor();
template<typename T>
inline const std::string& TMQueryType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TMQueryType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TMQueryType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TMQueryType_descriptor(), enum_t_value);
}
inline bool TMQueryType_Parse(
    const std::string& name, TMQueryType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TMQueryType>(
    TMQueryType_descriptor(), name, value);
}
enum TMReplyError : int {
  reNO_LEDGER = 1,
  reNO_NODE = 2,
  reBAD_REQUEST = 3
};
bool TMReplyError_IsValid(int value);
constexpr TMReplyError TMReplyError_MIN = reNO_LEDGER;
constexpr TMReplyError TMReplyError_MAX = reBAD_REQUEST;
constexpr int TMReplyError_ARRAYSIZE = TMReplyError_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TMReplyError_descriptor();
template<typename T>
inline const std::string& TMReplyError_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TMReplyError>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TMReplyError_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TMReplyError_descriptor(), enum_t_value);
}
inline bool TMReplyError_Parse(
    const std::string& name, TMReplyError* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TMReplyError>(
    TMReplyError_descriptor(), name, value);
}
enum TMLedgerMapType : int {
  lmTRANASCTION = 1,
  lmACCOUNT_STATE = 2
};
bool TMLedgerMapType_IsValid(int value);
constexpr TMLedgerMapType TMLedgerMapType_MIN = lmTRANASCTION;
constexpr TMLedgerMapType TMLedgerMapType_MAX = lmACCOUNT_STATE;
constexpr int TMLedgerMapType_ARRAYSIZE = TMLedgerMapType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TMLedgerMapType_descriptor();
template<typename T>
inline const std::string& TMLedgerMapType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TMLedgerMapType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TMLedgerMapType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TMLedgerMapType_descriptor(), enum_t_value);
}
inline bool TMLedgerMapType_Parse(
    const std::string& name, TMLedgerMapType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TMLedgerMapType>(
    TMLedgerMapType_descriptor(), name, value);
}
// ===================================================================

class TMManifest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.TMManifest) */ {
 public:
  inline TMManifest() : TMManifest(nullptr) {};
  virtual ~TMManifest();

  TMManifest(const TMManifest& from);
  TMManifest(TMManifest&& from) noexcept
    : TMManifest() {
    *this = ::std::move(from);
  }

  inline TMManifest& operator=(const TMManifest& from) {
    CopyFrom(from);
    return *this;
  }
  inline TMManifest& operator=(TMManifest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TMManifest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TMManifest* internal_default_instance() {
    return reinterpret_cast<const TMManifest*>(
               &_TMManifest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(TMManifest& a, TMManifest& b) {
    a.Swap(&b);
  }
  inline void Swap(TMManifest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TMManifest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TMManifest* New() const final {
    return CreateMaybeMessage<TMManifest>(nullptr);
  }

  TMManifest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TMManifest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TMManifest& from);
  void MergeFrom(const TMManifest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TMManifest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.TMManifest";
  }
  protected:
  explicit TMManifest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ripple_2eproto);
    return ::descriptor_table_ripple_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStobjectFieldNumber = 1,
  };
  // required bytes stobject = 1;
  bool has_stobject() const;
  private:
  bool _internal_has_stobject() const;
  public:
  void clear_stobject();
  const std::string& stobject() const;
  void set_stobject(const std::string& value);
  void set_stobject(std::string&& value);
  void set_stobject(const char* value);
  void set_stobject(const void* value, size_t size);
  std::string* mutable_stobject();
  std::string* release_stobject();
  void set_allocated_stobject(std::string* stobject);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_stobject();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_stobject(
      std::string* stobject);
  private:
  const std::string& _internal_stobject() const;
  void _internal_set_stobject(const std::string& value);
  std::string* _internal_mutable_stobject();
  public:

  // @@protoc_insertion_point(class_scope:protocol.TMManifest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stobject_;
  friend struct ::TableStruct_ripple_2eproto;
};
// -------------------------------------------------------------------

class TMManifests PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.TMManifests) */ {
 public:
  inline TMManifests() : TMManifests(nullptr) {};
  virtual ~TMManifests();

  TMManifests(const TMManifests& from);
  TMManifests(TMManifests&& from) noexcept
    : TMManifests() {
    *this = ::std::move(from);
  }

  inline TMManifests& operator=(const TMManifests& from) {
    CopyFrom(from);
    return *this;
  }
  inline TMManifests& operator=(TMManifests&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TMManifests& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TMManifests* internal_default_instance() {
    return reinterpret_cast<const TMManifests*>(
               &_TMManifests_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(TMManifests& a, TMManifests& b) {
    a.Swap(&b);
  }
  inline void Swap(TMManifests* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TMManifests* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TMManifests* New() const final {
    return CreateMaybeMessage<TMManifests>(nullptr);
  }

  TMManifests* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TMManifests>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TMManifests& from);
  void MergeFrom(const TMManifests& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TMManifests* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.TMManifests";
  }
  protected:
  explicit TMManifests(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ripple_2eproto);
    return ::descriptor_table_ripple_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kListFieldNumber = 1,
    kHistoryFieldNumber = 2,
  };
  // repeated .protocol.TMManifest list = 1;
  int list_size() const;
  private:
  int _internal_list_size() const;
  public:
  void clear_list();
  ::protocol::TMManifest* mutable_list(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::TMManifest >*
      mutable_list();
  private:
  const ::protocol::TMManifest& _internal_list(int index) const;
  ::protocol::TMManifest* _internal_add_list();
  public:
  const ::protocol::TMManifest& list(int index) const;
  ::protocol::TMManifest* add_list();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::TMManifest >&
      list() const;

  // optional bool history = 2 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_history() const;
  private:
  bool _internal_has_history() const;
  public:
  PROTOBUF_DEPRECATED void clear_history();
  PROTOBUF_DEPRECATED bool history() const;
  PROTOBUF_DEPRECATED void set_history(bool value);
  private:
  bool _internal_history() const;
  void _internal_set_history(bool value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.TMManifests)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::TMManifest > list_;
  bool history_;
  friend struct ::TableStruct_ripple_2eproto;
};
// -------------------------------------------------------------------

class TMClusterNode PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.TMClusterNode) */ {
 public:
  inline TMClusterNode() : TMClusterNode(nullptr) {};
  virtual ~TMClusterNode();

  TMClusterNode(const TMClusterNode& from);
  TMClusterNode(TMClusterNode&& from) noexcept
    : TMClusterNode() {
    *this = ::std::move(from);
  }

  inline TMClusterNode& operator=(const TMClusterNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline TMClusterNode& operator=(TMClusterNode&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TMClusterNode& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TMClusterNode* internal_default_instance() {
    return reinterpret_cast<const TMClusterNode*>(
               &_TMClusterNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(TMClusterNode& a, TMClusterNode& b) {
    a.Swap(&b);
  }
  inline void Swap(TMClusterNode* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TMClusterNode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TMClusterNode* New() const final {
    return CreateMaybeMessage<TMClusterNode>(nullptr);
  }

  TMClusterNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TMClusterNode>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TMClusterNode& from);
  void MergeFrom(const TMClusterNode& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TMClusterNode* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.TMClusterNode";
  }
  protected:
  explicit TMClusterNode(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ripple_2eproto);
    return ::descriptor_table_ripple_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPublicKeyFieldNumber = 1,
    kNodeNameFieldNumber = 4,
    kAddressFieldNumber = 5,
    kReportTimeFieldNumber = 2,
    kNodeLoadFieldNumber = 3,
  };
  // required string publicKey = 1;
  bool has_publickey() const;
  private:
  bool _internal_has_publickey() const;
  public:
  void clear_publickey();
  const std::string& publickey() const;
  void set_publickey(const std::string& value);
  void set_publickey(std::string&& value);
  void set_publickey(const char* value);
  void set_publickey(const char* value, size_t size);
  std::string* mutable_publickey();
  std::string* release_publickey();
  void set_allocated_publickey(std::string* publickey);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_publickey();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_publickey(
      std::string* publickey);
  private:
  const std::string& _internal_publickey() const;
  void _internal_set_publickey(const std::string& value);
  std::string* _internal_mutable_publickey();
  public:

  // optional string nodeName = 4;
  bool has_nodename() const;
  private:
  bool _internal_has_nodename() const;
  public:
  void clear_nodename();
  const std::string& nodename() const;
  void set_nodename(const std::string& value);
  void set_nodename(std::string&& value);
  void set_nodename(const char* value);
  void set_nodename(const char* value, size_t size);
  std::string* mutable_nodename();
  std::string* release_nodename();
  void set_allocated_nodename(std::string* nodename);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_nodename();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_nodename(
      std::string* nodename);
  private:
  const std::string& _internal_nodename() const;
  void _internal_set_nodename(const std::string& value);
  std::string* _internal_mutable_nodename();
  public:

  // optional string address = 5;
  bool has_address() const;
  private:
  bool _internal_has_address() const;
  public:
  void clear_address();
  const std::string& address() const;
  void set_address(const std::string& value);
  void set_address(std::string&& value);
  void set_address(const char* value);
  void set_address(const char* value, size_t size);
  std::string* mutable_address();
  std::string* release_address();
  void set_allocated_address(std::string* address);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_address();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_address(
      std::string* address);
  private:
  const std::string& _internal_address() const;
  void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // required uint32 reportTime = 2;
  bool has_reporttime() const;
  private:
  bool _internal_has_reporttime() const;
  public:
  void clear_reporttime();
  ::PROTOBUF_NAMESPACE_ID::uint32 reporttime() const;
  void set_reporttime(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_reporttime() const;
  void _internal_set_reporttime(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // required uint32 nodeLoad = 3;
  bool has_nodeload() const;
  private:
  bool _internal_has_nodeload() const;
  public:
  void clear_nodeload();
  ::PROTOBUF_NAMESPACE_ID::uint32 nodeload() const;
  void set_nodeload(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_nodeload() const;
  void _internal_set_nodeload(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.TMClusterNode)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr publickey_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nodename_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
  ::PROTOBUF_NAMESPACE_ID::uint32 reporttime_;
  ::PROTOBUF_NAMESPACE_ID::uint32 nodeload_;
  friend struct ::TableStruct_ripple_2eproto;
};
// -------------------------------------------------------------------

class TMLoadSource PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.TMLoadSource) */ {
 public:
  inline TMLoadSource() : TMLoadSource(nullptr) {};
  virtual ~TMLoadSource();

  TMLoadSource(const TMLoadSource& from);
  TMLoadSource(TMLoadSource&& from) noexcept
    : TMLoadSource() {
    *this = ::std::move(from);
  }

  inline TMLoadSource& operator=(const TMLoadSource& from) {
    CopyFrom(from);
    return *this;
  }
  inline TMLoadSource& operator=(TMLoadSource&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TMLoadSource& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TMLoadSource* internal_default_instance() {
    return reinterpret_cast<const TMLoadSource*>(
               &_TMLoadSource_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(TMLoadSource& a, TMLoadSource& b) {
    a.Swap(&b);
  }
  inline void Swap(TMLoadSource* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TMLoadSource* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TMLoadSource* New() const final {
    return CreateMaybeMessage<TMLoadSource>(nullptr);
  }

  TMLoadSource* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TMLoadSource>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TMLoadSource& from);
  void MergeFrom(const TMLoadSource& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TMLoadSource* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.TMLoadSource";
  }
  protected:
  explicit TMLoadSource(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ripple_2eproto);
    return ::descriptor_table_ripple_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kCostFieldNumber = 2,
    kCountFieldNumber = 3,
  };
  // required string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_name(
      std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // required uint32 cost = 2;
  bool has_cost() const;
  private:
  bool _internal_has_cost() const;
  public:
  void clear_cost();
  ::PROTOBUF_NAMESPACE_ID::uint32 cost() const;
  void set_cost(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_cost() const;
  void _internal_set_cost(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint32 count = 3;
  bool has_count() const;
  private:
  bool _internal_has_count() const;
  public:
  void clear_count();
  ::PROTOBUF_NAMESPACE_ID::uint32 count() const;
  void set_count(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_count() const;
  void _internal_set_count(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.TMLoadSource)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::uint32 cost_;
  ::PROTOBUF_NAMESPACE_ID::uint32 count_;
  friend struct ::TableStruct_ripple_2eproto;
};
// -------------------------------------------------------------------

class TMCluster PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.TMCluster) */ {
 public:
  inline TMCluster() : TMCluster(nullptr) {};
  virtual ~TMCluster();

  TMCluster(const TMCluster& from);
  TMCluster(TMCluster&& from) noexcept
    : TMCluster() {
    *this = ::std::move(from);
  }

  inline TMCluster& operator=(const TMCluster& from) {
    CopyFrom(from);
    return *this;
  }
  inline TMCluster& operator=(TMCluster&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TMCluster& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TMCluster* internal_default_instance() {
    return reinterpret_cast<const TMCluster*>(
               &_TMCluster_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(TMCluster& a, TMCluster& b) {
    a.Swap(&b);
  }
  inline void Swap(TMCluster* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TMCluster* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TMCluster* New() const final {
    return CreateMaybeMessage<TMCluster>(nullptr);
  }

  TMCluster* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TMCluster>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TMCluster& from);
  void MergeFrom(const TMCluster& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TMCluster* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.TMCluster";
  }
  protected:
  explicit TMCluster(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ripple_2eproto);
    return ::descriptor_table_ripple_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClusterNodesFieldNumber = 1,
    kLoadSourcesFieldNumber = 2,
  };
  // repeated .protocol.TMClusterNode clusterNodes = 1;
  int clusternodes_size() const;
  private:
  int _internal_clusternodes_size() const;
  public:
  void clear_clusternodes();
  ::protocol::TMClusterNode* mutable_clusternodes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::TMClusterNode >*
      mutable_clusternodes();
  private:
  const ::protocol::TMClusterNode& _internal_clusternodes(int index) const;
  ::protocol::TMClusterNode* _internal_add_clusternodes();
  public:
  const ::protocol::TMClusterNode& clusternodes(int index) const;
  ::protocol::TMClusterNode* add_clusternodes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::TMClusterNode >&
      clusternodes() const;

  // repeated .protocol.TMLoadSource loadSources = 2;
  int loadsources_size() const;
  private:
  int _internal_loadsources_size() const;
  public:
  void clear_loadsources();
  ::protocol::TMLoadSource* mutable_loadsources(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::TMLoadSource >*
      mutable_loadsources();
  private:
  const ::protocol::TMLoadSource& _internal_loadsources(int index) const;
  ::protocol::TMLoadSource* _internal_add_loadsources();
  public:
  const ::protocol::TMLoadSource& loadsources(int index) const;
  ::protocol::TMLoadSource* add_loadsources();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::TMLoadSource >&
      loadsources() const;

  // @@protoc_insertion_point(class_scope:protocol.TMCluster)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::TMClusterNode > clusternodes_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::TMLoadSource > loadsources_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ripple_2eproto;
};
// -------------------------------------------------------------------

class TMLink PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.TMLink) */ {
 public:
  inline TMLink() : TMLink(nullptr) {};
  virtual ~TMLink();

  TMLink(const TMLink& from);
  TMLink(TMLink&& from) noexcept
    : TMLink() {
    *this = ::std::move(from);
  }

  inline TMLink& operator=(const TMLink& from) {
    CopyFrom(from);
    return *this;
  }
  inline TMLink& operator=(TMLink&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TMLink& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TMLink* internal_default_instance() {
    return reinterpret_cast<const TMLink*>(
               &_TMLink_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(TMLink& a, TMLink& b) {
    a.Swap(&b);
  }
  inline void Swap(TMLink* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TMLink* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TMLink* New() const final {
    return CreateMaybeMessage<TMLink>(nullptr);
  }

  TMLink* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TMLink>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TMLink& from);
  void MergeFrom(const TMLink& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TMLink* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.TMLink";
  }
  protected:
  explicit TMLink(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ripple_2eproto);
    return ::descriptor_table_ripple_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodePubKeyFieldNumber = 1,
  };
  // required bytes nodePubKey = 1 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_nodepubkey() const;
  private:
  bool _internal_has_nodepubkey() const;
  public:
  PROTOBUF_DEPRECATED void clear_nodepubkey();
  PROTOBUF_DEPRECATED const std::string& nodepubkey() const;
  PROTOBUF_DEPRECATED void set_nodepubkey(const std::string& value);
  PROTOBUF_DEPRECATED void set_nodepubkey(std::string&& value);
  PROTOBUF_DEPRECATED void set_nodepubkey(const char* value);
  PROTOBUF_DEPRECATED void set_nodepubkey(const void* value, size_t size);
  PROTOBUF_DEPRECATED std::string* mutable_nodepubkey();
  PROTOBUF_DEPRECATED std::string* release_nodepubkey();
  PROTOBUF_DEPRECATED void set_allocated_nodepubkey(std::string* nodepubkey);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_nodepubkey();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_nodepubkey(
      std::string* nodepubkey);
  private:
  const std::string& _internal_nodepubkey() const;
  void _internal_set_nodepubkey(const std::string& value);
  std::string* _internal_mutable_nodepubkey();
  public:

  // @@protoc_insertion_point(class_scope:protocol.TMLink)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nodepubkey_;
  friend struct ::TableStruct_ripple_2eproto;
};
// -------------------------------------------------------------------

class TMGetPeerShardInfo PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.TMGetPeerShardInfo) */ {
 public:
  inline TMGetPeerShardInfo() : TMGetPeerShardInfo(nullptr) {};
  virtual ~TMGetPeerShardInfo();

  TMGetPeerShardInfo(const TMGetPeerShardInfo& from);
  TMGetPeerShardInfo(TMGetPeerShardInfo&& from) noexcept
    : TMGetPeerShardInfo() {
    *this = ::std::move(from);
  }

  inline TMGetPeerShardInfo& operator=(const TMGetPeerShardInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline TMGetPeerShardInfo& operator=(TMGetPeerShardInfo&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TMGetPeerShardInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TMGetPeerShardInfo* internal_default_instance() {
    return reinterpret_cast<const TMGetPeerShardInfo*>(
               &_TMGetPeerShardInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(TMGetPeerShardInfo& a, TMGetPeerShardInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(TMGetPeerShardInfo* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TMGetPeerShardInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TMGetPeerShardInfo* New() const final {
    return CreateMaybeMessage<TMGetPeerShardInfo>(nullptr);
  }

  TMGetPeerShardInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TMGetPeerShardInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TMGetPeerShardInfo& from);
  void MergeFrom(const TMGetPeerShardInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TMGetPeerShardInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.TMGetPeerShardInfo";
  }
  protected:
  explicit TMGetPeerShardInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ripple_2eproto);
    return ::descriptor_table_ripple_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPeerChainFieldNumber = 3,
    kHopsFieldNumber = 1,
    kLastLinkFieldNumber = 2,
  };
  // repeated .protocol.TMLink peerChain = 3 [deprecated = true];
  PROTOBUF_DEPRECATED int peerchain_size() const;
  private:
  int _internal_peerchain_size() const;
  public:
  PROTOBUF_DEPRECATED void clear_peerchain();
  PROTOBUF_DEPRECATED ::protocol::TMLink* mutable_peerchain(int index);
  PROTOBUF_DEPRECATED ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::TMLink >*
      mutable_peerchain();
  private:
  const ::protocol::TMLink& _internal_peerchain(int index) const;
  ::protocol::TMLink* _internal_add_peerchain();
  public:
  PROTOBUF_DEPRECATED const ::protocol::TMLink& peerchain(int index) const;
  PROTOBUF_DEPRECATED ::protocol::TMLink* add_peerchain();
  PROTOBUF_DEPRECATED const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::TMLink >&
      peerchain() const;

  // required uint32 hops = 1 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_hops() const;
  private:
  bool _internal_has_hops() const;
  public:
  PROTOBUF_DEPRECATED void clear_hops();
  PROTOBUF_DEPRECATED ::PROTOBUF_NAMESPACE_ID::uint32 hops() const;
  PROTOBUF_DEPRECATED void set_hops(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_hops() const;
  void _internal_set_hops(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional bool lastLink = 2 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_lastlink() const;
  private:
  bool _internal_has_lastlink() const;
  public:
  PROTOBUF_DEPRECATED void clear_lastlink();
  PROTOBUF_DEPRECATED bool lastlink() const;
  PROTOBUF_DEPRECATED void set_lastlink(bool value);
  private:
  bool _internal_lastlink() const;
  void _internal_set_lastlink(bool value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.TMGetPeerShardInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::TMLink > peerchain_;
  ::PROTOBUF_NAMESPACE_ID::uint32 hops_;
  bool lastlink_;
  friend struct ::TableStruct_ripple_2eproto;
};
// -------------------------------------------------------------------

class TMPeerShardInfo PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.TMPeerShardInfo) */ {
 public:
  inline TMPeerShardInfo() : TMPeerShardInfo(nullptr) {};
  virtual ~TMPeerShardInfo();

  TMPeerShardInfo(const TMPeerShardInfo& from);
  TMPeerShardInfo(TMPeerShardInfo&& from) noexcept
    : TMPeerShardInfo() {
    *this = ::std::move(from);
  }

  inline TMPeerShardInfo& operator=(const TMPeerShardInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline TMPeerShardInfo& operator=(TMPeerShardInfo&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TMPeerShardInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TMPeerShardInfo* internal_default_instance() {
    return reinterpret_cast<const TMPeerShardInfo*>(
               &_TMPeerShardInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(TMPeerShardInfo& a, TMPeerShardInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(TMPeerShardInfo* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TMPeerShardInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TMPeerShardInfo* New() const final {
    return CreateMaybeMessage<TMPeerShardInfo>(nullptr);
  }

  TMPeerShardInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TMPeerShardInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TMPeerShardInfo& from);
  void MergeFrom(const TMPeerShardInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TMPeerShardInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.TMPeerShardInfo";
  }
  protected:
  explicit TMPeerShardInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ripple_2eproto);
    return ::descriptor_table_ripple_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPeerChainFieldNumber = 5,
    kShardIndexesFieldNumber = 1,
    kNodePubKeyFieldNumber = 2,
    kEndpointFieldNumber = 3,
    kLastLinkFieldNumber = 4,
  };
  // repeated .protocol.TMLink peerChain = 5 [deprecated = true];
  PROTOBUF_DEPRECATED int peerchain_size() const;
  private:
  int _internal_peerchain_size() const;
  public:
  PROTOBUF_DEPRECATED void clear_peerchain();
  PROTOBUF_DEPRECATED ::protocol::TMLink* mutable_peerchain(int index);
  PROTOBUF_DEPRECATED ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::TMLink >*
      mutable_peerchain();
  private:
  const ::protocol::TMLink& _internal_peerchain(int index) const;
  ::protocol::TMLink* _internal_add_peerchain();
  public:
  PROTOBUF_DEPRECATED const ::protocol::TMLink& peerchain(int index) const;
  PROTOBUF_DEPRECATED ::protocol::TMLink* add_peerchain();
  PROTOBUF_DEPRECATED const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::TMLink >&
      peerchain() const;

  // required string shardIndexes = 1 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_shardindexes() const;
  private:
  bool _internal_has_shardindexes() const;
  public:
  PROTOBUF_DEPRECATED void clear_shardindexes();
  PROTOBUF_DEPRECATED const std::string& shardindexes() const;
  PROTOBUF_DEPRECATED void set_shardindexes(const std::string& value);
  PROTOBUF_DEPRECATED void set_shardindexes(std::string&& value);
  PROTOBUF_DEPRECATED void set_shardindexes(const char* value);
  PROTOBUF_DEPRECATED void set_shardindexes(const char* value, size_t size);
  PROTOBUF_DEPRECATED std::string* mutable_shardindexes();
  PROTOBUF_DEPRECATED std::string* release_shardindexes();
  PROTOBUF_DEPRECATED void set_allocated_shardindexes(std::string* shardindexes);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_shardindexes();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_shardindexes(
      std::string* shardindexes);
  private:
  const std::string& _internal_shardindexes() const;
  void _internal_set_shardindexes(const std::string& value);
  std::string* _internal_mutable_shardindexes();
  public:

  // optional bytes nodePubKey = 2 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_nodepubkey() const;
  private:
  bool _internal_has_nodepubkey() const;
  public:
  PROTOBUF_DEPRECATED void clear_nodepubkey();
  PROTOBUF_DEPRECATED const std::string& nodepubkey() const;
  PROTOBUF_DEPRECATED void set_nodepubkey(const std::string& value);
  PROTOBUF_DEPRECATED void set_nodepubkey(std::string&& value);
  PROTOBUF_DEPRECATED void set_nodepubkey(const char* value);
  PROTOBUF_DEPRECATED void set_nodepubkey(const void* value, size_t size);
  PROTOBUF_DEPRECATED std::string* mutable_nodepubkey();
  PROTOBUF_DEPRECATED std::string* release_nodepubkey();
  PROTOBUF_DEPRECATED void set_allocated_nodepubkey(std::string* nodepubkey);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_nodepubkey();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_nodepubkey(
      std::string* nodepubkey);
  private:
  const std::string& _internal_nodepubkey() const;
  void _internal_set_nodepubkey(const std::string& value);
  std::string* _internal_mutable_nodepubkey();
  public:

  // optional string endpoint = 3 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_endpoint() const;
  private:
  bool _internal_has_endpoint() const;
  public:
  PROTOBUF_DEPRECATED void clear_endpoint();
  PROTOBUF_DEPRECATED const std::string& endpoint() const;
  PROTOBUF_DEPRECATED void set_endpoint(const std::string& value);
  PROTOBUF_DEPRECATED void set_endpoint(std::string&& value);
  PROTOBUF_DEPRECATED void set_endpoint(const char* value);
  PROTOBUF_DEPRECATED void set_endpoint(const char* value, size_t size);
  PROTOBUF_DEPRECATED std::string* mutable_endpoint();
  PROTOBUF_DEPRECATED std::string* release_endpoint();
  PROTOBUF_DEPRECATED void set_allocated_endpoint(std::string* endpoint);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_endpoint();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_endpoint(
      std::string* endpoint);
  private:
  const std::string& _internal_endpoint() const;
  void _internal_set_endpoint(const std::string& value);
  std::string* _internal_mutable_endpoint();
  public:

  // optional bool lastLink = 4 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_lastlink() const;
  private:
  bool _internal_has_lastlink() const;
  public:
  PROTOBUF_DEPRECATED void clear_lastlink();
  PROTOBUF_DEPRECATED bool lastlink() const;
  PROTOBUF_DEPRECATED void set_lastlink(bool value);
  private:
  bool _internal_lastlink() const;
  void _internal_set_lastlink(bool value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.TMPeerShardInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::TMLink > peerchain_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr shardindexes_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nodepubkey_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr endpoint_;
  bool lastlink_;
  friend struct ::TableStruct_ripple_2eproto;
};
// -------------------------------------------------------------------

class TMPublicKey PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.TMPublicKey) */ {
 public:
  inline TMPublicKey() : TMPublicKey(nullptr) {};
  virtual ~TMPublicKey();

  TMPublicKey(const TMPublicKey& from);
  TMPublicKey(TMPublicKey&& from) noexcept
    : TMPublicKey() {
    *this = ::std::move(from);
  }

  inline TMPublicKey& operator=(const TMPublicKey& from) {
    CopyFrom(from);
    return *this;
  }
  inline TMPublicKey& operator=(TMPublicKey&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TMPublicKey& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TMPublicKey* internal_default_instance() {
    return reinterpret_cast<const TMPublicKey*>(
               &_TMPublicKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(TMPublicKey& a, TMPublicKey& b) {
    a.Swap(&b);
  }
  inline void Swap(TMPublicKey* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TMPublicKey* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TMPublicKey* New() const final {
    return CreateMaybeMessage<TMPublicKey>(nullptr);
  }

  TMPublicKey* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TMPublicKey>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TMPublicKey& from);
  void MergeFrom(const TMPublicKey& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TMPublicKey* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.TMPublicKey";
  }
  protected:
  explicit TMPublicKey(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ripple_2eproto);
    return ::descriptor_table_ripple_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPublicKeyFieldNumber = 1,
  };
  // required bytes publicKey = 1;
  bool has_publickey() const;
  private:
  bool _internal_has_publickey() const;
  public:
  void clear_publickey();
  const std::string& publickey() const;
  void set_publickey(const std::string& value);
  void set_publickey(std::string&& value);
  void set_publickey(const char* value);
  void set_publickey(const void* value, size_t size);
  std::string* mutable_publickey();
  std::string* release_publickey();
  void set_allocated_publickey(std::string* publickey);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_publickey();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_publickey(
      std::string* publickey);
  private:
  const std::string& _internal_publickey() const;
  void _internal_set_publickey(const std::string& value);
  std::string* _internal_mutable_publickey();
  public:

  // @@protoc_insertion_point(class_scope:protocol.TMPublicKey)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr publickey_;
  friend struct ::TableStruct_ripple_2eproto;
};
// -------------------------------------------------------------------

class TMGetPeerShardInfoV2 PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.TMGetPeerShardInfoV2) */ {
 public:
  inline TMGetPeerShardInfoV2() : TMGetPeerShardInfoV2(nullptr) {};
  virtual ~TMGetPeerShardInfoV2();

  TMGetPeerShardInfoV2(const TMGetPeerShardInfoV2& from);
  TMGetPeerShardInfoV2(TMGetPeerShardInfoV2&& from) noexcept
    : TMGetPeerShardInfoV2() {
    *this = ::std::move(from);
  }

  inline TMGetPeerShardInfoV2& operator=(const TMGetPeerShardInfoV2& from) {
    CopyFrom(from);
    return *this;
  }
  inline TMGetPeerShardInfoV2& operator=(TMGetPeerShardInfoV2&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TMGetPeerShardInfoV2& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TMGetPeerShardInfoV2* internal_default_instance() {
    return reinterpret_cast<const TMGetPeerShardInfoV2*>(
               &_TMGetPeerShardInfoV2_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(TMGetPeerShardInfoV2& a, TMGetPeerShardInfoV2& b) {
    a.Swap(&b);
  }
  inline void Swap(TMGetPeerShardInfoV2* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TMGetPeerShardInfoV2* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TMGetPeerShardInfoV2* New() const final {
    return CreateMaybeMessage<TMGetPeerShardInfoV2>(nullptr);
  }

  TMGetPeerShardInfoV2* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TMGetPeerShardInfoV2>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TMGetPeerShardInfoV2& from);
  void MergeFrom(const TMGetPeerShardInfoV2& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TMGetPeerShardInfoV2* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.TMGetPeerShardInfoV2";
  }
  protected:
  explicit TMGetPeerShardInfoV2(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ripple_2eproto);
    return ::descriptor_table_ripple_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPeerChainFieldNumber = 1,
    kRelaysFieldNumber = 2,
  };
  // repeated .protocol.TMPublicKey peerChain = 1;
  int peerchain_size() const;
  private:
  int _internal_peerchain_size() const;
  public:
  void clear_peerchain();
  ::protocol::TMPublicKey* mutable_peerchain(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::TMPublicKey >*
      mutable_peerchain();
  private:
  const ::protocol::TMPublicKey& _internal_peerchain(int index) const;
  ::protocol::TMPublicKey* _internal_add_peerchain();
  public:
  const ::protocol::TMPublicKey& peerchain(int index) const;
  ::protocol::TMPublicKey* add_peerchain();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::TMPublicKey >&
      peerchain() const;

  // required uint32 relays = 2;
  bool has_relays() const;
  private:
  bool _internal_has_relays() const;
  public:
  void clear_relays();
  ::PROTOBUF_NAMESPACE_ID::uint32 relays() const;
  void set_relays(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_relays() const;
  void _internal_set_relays(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.TMGetPeerShardInfoV2)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::TMPublicKey > peerchain_;
  ::PROTOBUF_NAMESPACE_ID::uint32 relays_;
  friend struct ::TableStruct_ripple_2eproto;
};
// -------------------------------------------------------------------

class TMPeerShardInfoV2_TMIncomplete PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.TMPeerShardInfoV2.TMIncomplete) */ {
 public:
  inline TMPeerShardInfoV2_TMIncomplete() : TMPeerShardInfoV2_TMIncomplete(nullptr) {};
  virtual ~TMPeerShardInfoV2_TMIncomplete();

  TMPeerShardInfoV2_TMIncomplete(const TMPeerShardInfoV2_TMIncomplete& from);
  TMPeerShardInfoV2_TMIncomplete(TMPeerShardInfoV2_TMIncomplete&& from) noexcept
    : TMPeerShardInfoV2_TMIncomplete() {
    *this = ::std::move(from);
  }

  inline TMPeerShardInfoV2_TMIncomplete& operator=(const TMPeerShardInfoV2_TMIncomplete& from) {
    CopyFrom(from);
    return *this;
  }
  inline TMPeerShardInfoV2_TMIncomplete& operator=(TMPeerShardInfoV2_TMIncomplete&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TMPeerShardInfoV2_TMIncomplete& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TMPeerShardInfoV2_TMIncomplete* internal_default_instance() {
    return reinterpret_cast<const TMPeerShardInfoV2_TMIncomplete*>(
               &_TMPeerShardInfoV2_TMIncomplete_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(TMPeerShardInfoV2_TMIncomplete& a, TMPeerShardInfoV2_TMIncomplete& b) {
    a.Swap(&b);
  }
  inline void Swap(TMPeerShardInfoV2_TMIncomplete* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TMPeerShardInfoV2_TMIncomplete* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TMPeerShardInfoV2_TMIncomplete* New() const final {
    return CreateMaybeMessage<TMPeerShardInfoV2_TMIncomplete>(nullptr);
  }

  TMPeerShardInfoV2_TMIncomplete* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TMPeerShardInfoV2_TMIncomplete>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TMPeerShardInfoV2_TMIncomplete& from);
  void MergeFrom(const TMPeerShardInfoV2_TMIncomplete& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TMPeerShardInfoV2_TMIncomplete* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.TMPeerShardInfoV2.TMIncomplete";
  }
  protected:
  explicit TMPeerShardInfoV2_TMIncomplete(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ripple_2eproto);
    return ::descriptor_table_ripple_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kShardIndexFieldNumber = 1,
    kStateFieldNumber = 2,
    kProgressFieldNumber = 3,
  };
  // required uint32 shardIndex = 1;
  bool has_shardindex() const;
  private:
  bool _internal_has_shardindex() const;
  public:
  void clear_shardindex();
  ::PROTOBUF_NAMESPACE_ID::uint32 shardindex() const;
  void set_shardindex(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_shardindex() const;
  void _internal_set_shardindex(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // required uint32 state = 2;
  bool has_state() const;
  private:
  bool _internal_has_state() const;
  public:
  void clear_state();
  ::PROTOBUF_NAMESPACE_ID::uint32 state() const;
  void set_state(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_state() const;
  void _internal_set_state(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint32 progress = 3;
  bool has_progress() const;
  private:
  bool _internal_has_progress() const;
  public:
  void clear_progress();
  ::PROTOBUF_NAMESPACE_ID::uint32 progress() const;
  void set_progress(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_progress() const;
  void _internal_set_progress(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.TMPeerShardInfoV2.TMIncomplete)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 shardindex_;
  ::PROTOBUF_NAMESPACE_ID::uint32 state_;
  ::PROTOBUF_NAMESPACE_ID::uint32 progress_;
  friend struct ::TableStruct_ripple_2eproto;
};
// -------------------------------------------------------------------

class TMPeerShardInfoV2 PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.TMPeerShardInfoV2) */ {
 public:
  inline TMPeerShardInfoV2() : TMPeerShardInfoV2(nullptr) {};
  virtual ~TMPeerShardInfoV2();

  TMPeerShardInfoV2(const TMPeerShardInfoV2& from);
  TMPeerShardInfoV2(TMPeerShardInfoV2&& from) noexcept
    : TMPeerShardInfoV2() {
    *this = ::std::move(from);
  }

  inline TMPeerShardInfoV2& operator=(const TMPeerShardInfoV2& from) {
    CopyFrom(from);
    return *this;
  }
  inline TMPeerShardInfoV2& operator=(TMPeerShardInfoV2&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TMPeerShardInfoV2& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TMPeerShardInfoV2* internal_default_instance() {
    return reinterpret_cast<const TMPeerShardInfoV2*>(
               &_TMPeerShardInfoV2_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(TMPeerShardInfoV2& a, TMPeerShardInfoV2& b) {
    a.Swap(&b);
  }
  inline void Swap(TMPeerShardInfoV2* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TMPeerShardInfoV2* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TMPeerShardInfoV2* New() const final {
    return CreateMaybeMessage<TMPeerShardInfoV2>(nullptr);
  }

  TMPeerShardInfoV2* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TMPeerShardInfoV2>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TMPeerShardInfoV2& from);
  void MergeFrom(const TMPeerShardInfoV2& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TMPeerShardInfoV2* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.TMPeerShardInfoV2";
  }
  protected:
  explicit TMPeerShardInfoV2(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ripple_2eproto);
    return ::descriptor_table_ripple_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef TMPeerShardInfoV2_TMIncomplete TMIncomplete;

  // accessors -------------------------------------------------------

  enum : int {
    kIncompleteFieldNumber = 2,
    kPeerChainFieldNumber = 6,
    kFinalizedFieldNumber = 3,
    kPublicKeyFieldNumber = 4,
    kSignatureFieldNumber = 5,
    kTimestampFieldNumber = 1,
  };
  // repeated .protocol.TMPeerShardInfoV2.TMIncomplete incomplete = 2;
  int incomplete_size() const;
  private:
  int _internal_incomplete_size() const;
  public:
  void clear_incomplete();
  ::protocol::TMPeerShardInfoV2_TMIncomplete* mutable_incomplete(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::TMPeerShardInfoV2_TMIncomplete >*
      mutable_incomplete();
  private:
  const ::protocol::TMPeerShardInfoV2_TMIncomplete& _internal_incomplete(int index) const;
  ::protocol::TMPeerShardInfoV2_TMIncomplete* _internal_add_incomplete();
  public:
  const ::protocol::TMPeerShardInfoV2_TMIncomplete& incomplete(int index) const;
  ::protocol::TMPeerShardInfoV2_TMIncomplete* add_incomplete();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::TMPeerShardInfoV2_TMIncomplete >&
      incomplete() const;

  // repeated .protocol.TMPublicKey peerChain = 6;
  int peerchain_size() const;
  private:
  int _internal_peerchain_size() const;
  public:
  void clear_peerchain();
  ::protocol::TMPublicKey* mutable_peerchain(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::TMPublicKey >*
      mutable_peerchain();
  private:
  const ::protocol::TMPublicKey& _internal_peerchain(int index) const;
  ::protocol::TMPublicKey* _internal_add_peerchain();
  public:
  const ::protocol::TMPublicKey& peerchain(int index) const;
  ::protocol::TMPublicKey* add_peerchain();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::TMPublicKey >&
      peerchain() const;

  // optional string finalized = 3;
  bool has_finalized() const;
  private:
  bool _internal_has_finalized() const;
  public:
  void clear_finalized();
  const std::string& finalized() const;
  void set_finalized(const std::string& value);
  void set_finalized(std::string&& value);
  void set_finalized(const char* value);
  void set_finalized(const char* value, size_t size);
  std::string* mutable_finalized();
  std::string* release_finalized();
  void set_allocated_finalized(std::string* finalized);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_finalized();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_finalized(
      std::string* finalized);
  private:
  const std::string& _internal_finalized() const;
  void _internal_set_finalized(const std::string& value);
  std::string* _internal_mutable_finalized();
  public:

  // required bytes publicKey = 4;
  bool has_publickey() const;
  private:
  bool _internal_has_publickey() const;
  public:
  void clear_publickey();
  const std::string& publickey() const;
  void set_publickey(const std::string& value);
  void set_publickey(std::string&& value);
  void set_publickey(const char* value);
  void set_publickey(const void* value, size_t size);
  std::string* mutable_publickey();
  std::string* release_publickey();
  void set_allocated_publickey(std::string* publickey);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_publickey();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_publickey(
      std::string* publickey);
  private:
  const std::string& _internal_publickey() const;
  void _internal_set_publickey(const std::string& value);
  std::string* _internal_mutable_publickey();
  public:

  // required bytes signature = 5;
  bool has_signature() const;
  private:
  bool _internal_has_signature() const;
  public:
  void clear_signature();
  const std::string& signature() const;
  void set_signature(const std::string& value);
  void set_signature(std::string&& value);
  void set_signature(const char* value);
  void set_signature(const void* value, size_t size);
  std::string* mutable_signature();
  std::string* release_signature();
  void set_allocated_signature(std::string* signature);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_signature();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_signature(
      std::string* signature);
  private:
  const std::string& _internal_signature() const;
  void _internal_set_signature(const std::string& value);
  std::string* _internal_mutable_signature();
  public:

  // required uint32 timestamp = 1;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  ::PROTOBUF_NAMESPACE_ID::uint32 timestamp() const;
  void set_timestamp(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_timestamp() const;
  void _internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.TMPeerShardInfoV2)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::TMPeerShardInfoV2_TMIncomplete > incomplete_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::TMPublicKey > peerchain_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr finalized_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr publickey_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signature_;
  ::PROTOBUF_NAMESPACE_ID::uint32 timestamp_;
  friend struct ::TableStruct_ripple_2eproto;
};
// -------------------------------------------------------------------

class TMTransaction PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.TMTransaction) */ {
 public:
  inline TMTransaction() : TMTransaction(nullptr) {};
  virtual ~TMTransaction();

  TMTransaction(const TMTransaction& from);
  TMTransaction(TMTransaction&& from) noexcept
    : TMTransaction() {
    *this = ::std::move(from);
  }

  inline TMTransaction& operator=(const TMTransaction& from) {
    CopyFrom(from);
    return *this;
  }
  inline TMTransaction& operator=(TMTransaction&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TMTransaction& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TMTransaction* internal_default_instance() {
    return reinterpret_cast<const TMTransaction*>(
               &_TMTransaction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(TMTransaction& a, TMTransaction& b) {
    a.Swap(&b);
  }
  inline void Swap(TMTransaction* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TMTransaction* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TMTransaction* New() const final {
    return CreateMaybeMessage<TMTransaction>(nullptr);
  }

  TMTransaction* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TMTransaction>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TMTransaction& from);
  void MergeFrom(const TMTransaction& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TMTransaction* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.TMTransaction";
  }
  protected:
  explicit TMTransaction(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ripple_2eproto);
    return ::descriptor_table_ripple_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRawTransactionFieldNumber = 1,
    kReceiveTimestampFieldNumber = 3,
    kDeferredFieldNumber = 4,
    kStatusFieldNumber = 2,
  };
  // required bytes rawTransaction = 1;
  bool has_rawtransaction() const;
  private:
  bool _internal_has_rawtransaction() const;
  public:
  void clear_rawtransaction();
  const std::string& rawtransaction() const;
  void set_rawtransaction(const std::string& value);
  void set_rawtransaction(std::string&& value);
  void set_rawtransaction(const char* value);
  void set_rawtransaction(const void* value, size_t size);
  std::string* mutable_rawtransaction();
  std::string* release_rawtransaction();
  void set_allocated_rawtransaction(std::string* rawtransaction);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_rawtransaction();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_rawtransaction(
      std::string* rawtransaction);
  private:
  const std::string& _internal_rawtransaction() const;
  void _internal_set_rawtransaction(const std::string& value);
  std::string* _internal_mutable_rawtransaction();
  public:

  // optional uint64 receiveTimestamp = 3;
  bool has_receivetimestamp() const;
  private:
  bool _internal_has_receivetimestamp() const;
  public:
  void clear_receivetimestamp();
  ::PROTOBUF_NAMESPACE_ID::uint64 receivetimestamp() const;
  void set_receivetimestamp(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_receivetimestamp() const;
  void _internal_set_receivetimestamp(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional bool deferred = 4;
  bool has_deferred() const;
  private:
  bool _internal_has_deferred() const;
  public:
  void clear_deferred();
  bool deferred() const;
  void set_deferred(bool value);
  private:
  bool _internal_deferred() const;
  void _internal_set_deferred(bool value);
  public:

  // required .protocol.TransactionStatus status = 2;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  ::protocol::TransactionStatus status() const;
  void set_status(::protocol::TransactionStatus value);
  private:
  ::protocol::TransactionStatus _internal_status() const;
  void _internal_set_status(::protocol::TransactionStatus value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.TMTransaction)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rawtransaction_;
  ::PROTOBUF_NAMESPACE_ID::uint64 receivetimestamp_;
  bool deferred_;
  int status_;
  friend struct ::TableStruct_ripple_2eproto;
};
// -------------------------------------------------------------------

class TMTransactions PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.TMTransactions) */ {
 public:
  inline TMTransactions() : TMTransactions(nullptr) {};
  virtual ~TMTransactions();

  TMTransactions(const TMTransactions& from);
  TMTransactions(TMTransactions&& from) noexcept
    : TMTransactions() {
    *this = ::std::move(from);
  }

  inline TMTransactions& operator=(const TMTransactions& from) {
    CopyFrom(from);
    return *this;
  }
  inline TMTransactions& operator=(TMTransactions&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TMTransactions& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TMTransactions* internal_default_instance() {
    return reinterpret_cast<const TMTransactions*>(
               &_TMTransactions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(TMTransactions& a, TMTransactions& b) {
    a.Swap(&b);
  }
  inline void Swap(TMTransactions* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TMTransactions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TMTransactions* New() const final {
    return CreateMaybeMessage<TMTransactions>(nullptr);
  }

  TMTransactions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TMTransactions>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TMTransactions& from);
  void MergeFrom(const TMTransactions& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TMTransactions* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.TMTransactions";
  }
  protected:
  explicit TMTransactions(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ripple_2eproto);
    return ::descriptor_table_ripple_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTransactionsFieldNumber = 1,
  };
  // repeated .protocol.TMTransaction transactions = 1;
  int transactions_size() const;
  private:
  int _internal_transactions_size() const;
  public:
  void clear_transactions();
  ::protocol::TMTransaction* mutable_transactions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::TMTransaction >*
      mutable_transactions();
  private:
  const ::protocol::TMTransaction& _internal_transactions(int index) const;
  ::protocol::TMTransaction* _internal_add_transactions();
  public:
  const ::protocol::TMTransaction& transactions(int index) const;
  ::protocol::TMTransaction* add_transactions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::TMTransaction >&
      transactions() const;

  // @@protoc_insertion_point(class_scope:protocol.TMTransactions)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::TMTransaction > transactions_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ripple_2eproto;
};
// -------------------------------------------------------------------

class TMStatusChange PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.TMStatusChange) */ {
 public:
  inline TMStatusChange() : TMStatusChange(nullptr) {};
  virtual ~TMStatusChange();

  TMStatusChange(const TMStatusChange& from);
  TMStatusChange(TMStatusChange&& from) noexcept
    : TMStatusChange() {
    *this = ::std::move(from);
  }

  inline TMStatusChange& operator=(const TMStatusChange& from) {
    CopyFrom(from);
    return *this;
  }
  inline TMStatusChange& operator=(TMStatusChange&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TMStatusChange& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TMStatusChange* internal_default_instance() {
    return reinterpret_cast<const TMStatusChange*>(
               &_TMStatusChange_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(TMStatusChange& a, TMStatusChange& b) {
    a.Swap(&b);
  }
  inline void Swap(TMStatusChange* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TMStatusChange* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TMStatusChange* New() const final {
    return CreateMaybeMessage<TMStatusChange>(nullptr);
  }

  TMStatusChange* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TMStatusChange>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TMStatusChange& from);
  void MergeFrom(const TMStatusChange& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TMStatusChange* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.TMStatusChange";
  }
  protected:
  explicit TMStatusChange(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ripple_2eproto);
    return ::descriptor_table_ripple_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLedgerHashFieldNumber = 4,
    kLedgerHashPreviousFieldNumber = 5,
    kLedgerSeqFieldNumber = 3,
    kFirstSeqFieldNumber = 7,
    kNetworkTimeFieldNumber = 6,
    kLastSeqFieldNumber = 8,
    kNewStatusFieldNumber = 1,
    kNewEventFieldNumber = 2,
  };
  // optional bytes ledgerHash = 4;
  bool has_ledgerhash() const;
  private:
  bool _internal_has_ledgerhash() const;
  public:
  void clear_ledgerhash();
  const std::string& ledgerhash() const;
  void set_ledgerhash(const std::string& value);
  void set_ledgerhash(std::string&& value);
  void set_ledgerhash(const char* value);
  void set_ledgerhash(const void* value, size_t size);
  std::string* mutable_ledgerhash();
  std::string* release_ledgerhash();
  void set_allocated_ledgerhash(std::string* ledgerhash);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_ledgerhash();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_ledgerhash(
      std::string* ledgerhash);
  private:
  const std::string& _internal_ledgerhash() const;
  void _internal_set_ledgerhash(const std::string& value);
  std::string* _internal_mutable_ledgerhash();
  public:

  // optional bytes ledgerHashPrevious = 5;
  bool has_ledgerhashprevious() const;
  private:
  bool _internal_has_ledgerhashprevious() const;
  public:
  void clear_ledgerhashprevious();
  const std::string& ledgerhashprevious() const;
  void set_ledgerhashprevious(const std::string& value);
  void set_ledgerhashprevious(std::string&& value);
  void set_ledgerhashprevious(const char* value);
  void set_ledgerhashprevious(const void* value, size_t size);
  std::string* mutable_ledgerhashprevious();
  std::string* release_ledgerhashprevious();
  void set_allocated_ledgerhashprevious(std::string* ledgerhashprevious);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_ledgerhashprevious();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_ledgerhashprevious(
      std::string* ledgerhashprevious);
  private:
  const std::string& _internal_ledgerhashprevious() const;
  void _internal_set_ledgerhashprevious(const std::string& value);
  std::string* _internal_mutable_ledgerhashprevious();
  public:

  // optional uint32 ledgerSeq = 3;
  bool has_ledgerseq() const;
  private:
  bool _internal_has_ledgerseq() const;
  public:
  void clear_ledgerseq();
  ::PROTOBUF_NAMESPACE_ID::uint32 ledgerseq() const;
  void set_ledgerseq(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_ledgerseq() const;
  void _internal_set_ledgerseq(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint32 firstSeq = 7;
  bool has_firstseq() const;
  private:
  bool _internal_has_firstseq() const;
  public:
  void clear_firstseq();
  ::PROTOBUF_NAMESPACE_ID::uint32 firstseq() const;
  void set_firstseq(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_firstseq() const;
  void _internal_set_firstseq(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint64 networkTime = 6;
  bool has_networktime() const;
  private:
  bool _internal_has_networktime() const;
  public:
  void clear_networktime();
  ::PROTOBUF_NAMESPACE_ID::uint64 networktime() const;
  void set_networktime(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_networktime() const;
  void _internal_set_networktime(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional uint32 lastSeq = 8;
  bool has_lastseq() const;
  private:
  bool _internal_has_lastseq() const;
  public:
  void clear_lastseq();
  ::PROTOBUF_NAMESPACE_ID::uint32 lastseq() const;
  void set_lastseq(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_lastseq() const;
  void _internal_set_lastseq(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional .protocol.NodeStatus newStatus = 1;
  bool has_newstatus() const;
  private:
  bool _internal_has_newstatus() const;
  public:
  void clear_newstatus();
  ::protocol::NodeStatus newstatus() const;
  void set_newstatus(::protocol::NodeStatus value);
  private:
  ::protocol::NodeStatus _internal_newstatus() const;
  void _internal_set_newstatus(::protocol::NodeStatus value);
  public:

  // optional .protocol.NodeEvent newEvent = 2;
  bool has_newevent() const;
  private:
  bool _internal_has_newevent() const;
  public:
  void clear_newevent();
  ::protocol::NodeEvent newevent() const;
  void set_newevent(::protocol::NodeEvent value);
  private:
  ::protocol::NodeEvent _internal_newevent() const;
  void _internal_set_newevent(::protocol::NodeEvent value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.TMStatusChange)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ledgerhash_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ledgerhashprevious_;
  ::PROTOBUF_NAMESPACE_ID::uint32 ledgerseq_;
  ::PROTOBUF_NAMESPACE_ID::uint32 firstseq_;
  ::PROTOBUF_NAMESPACE_ID::uint64 networktime_;
  ::PROTOBUF_NAMESPACE_ID::uint32 lastseq_;
  int newstatus_;
  int newevent_;
  friend struct ::TableStruct_ripple_2eproto;
};
// -------------------------------------------------------------------

class TMProposeSet PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.TMProposeSet) */ {
 public:
  inline TMProposeSet() : TMProposeSet(nullptr) {};
  virtual ~TMProposeSet();

  TMProposeSet(const TMProposeSet& from);
  TMProposeSet(TMProposeSet&& from) noexcept
    : TMProposeSet() {
    *this = ::std::move(from);
  }

  inline TMProposeSet& operator=(const TMProposeSet& from) {
    CopyFrom(from);
    return *this;
  }
  inline TMProposeSet& operator=(TMProposeSet&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TMProposeSet& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TMProposeSet* internal_default_instance() {
    return reinterpret_cast<const TMProposeSet*>(
               &_TMProposeSet_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(TMProposeSet& a, TMProposeSet& b) {
    a.Swap(&b);
  }
  inline void Swap(TMProposeSet* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TMProposeSet* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TMProposeSet* New() const final {
    return CreateMaybeMessage<TMProposeSet>(nullptr);
  }

  TMProposeSet* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TMProposeSet>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TMProposeSet& from);
  void MergeFrom(const TMProposeSet& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TMProposeSet* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.TMProposeSet";
  }
  protected:
  explicit TMProposeSet(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ripple_2eproto);
    return ::descriptor_table_ripple_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddedTransactionsFieldNumber = 10,
    kRemovedTransactionsFieldNumber = 11,
    kCurrentTxHashFieldNumber = 2,
    kNodePubKeyFieldNumber = 3,
    kSignatureFieldNumber = 5,
    kPreviousledgerFieldNumber = 6,
    kProposeSeqFieldNumber = 1,
    kCloseTimeFieldNumber = 4,
    kCheckedSignatureFieldNumber = 7,
    kHopsFieldNumber = 12,
  };
  // repeated bytes addedTransactions = 10;
  int addedtransactions_size() const;
  private:
  int _internal_addedtransactions_size() const;
  public:
  void clear_addedtransactions();
  const std::string& addedtransactions(int index) const;
  std::string* mutable_addedtransactions(int index);
  void set_addedtransactions(int index, const std::string& value);
  void set_addedtransactions(int index, std::string&& value);
  void set_addedtransactions(int index, const char* value);
  void set_addedtransactions(int index, const void* value, size_t size);
  std::string* add_addedtransactions();
  void add_addedtransactions(const std::string& value);
  void add_addedtransactions(std::string&& value);
  void add_addedtransactions(const char* value);
  void add_addedtransactions(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& addedtransactions() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_addedtransactions();
  private:
  const std::string& _internal_addedtransactions(int index) const;
  std::string* _internal_add_addedtransactions();
  public:

  // repeated bytes removedTransactions = 11;
  int removedtransactions_size() const;
  private:
  int _internal_removedtransactions_size() const;
  public:
  void clear_removedtransactions();
  const std::string& removedtransactions(int index) const;
  std::string* mutable_removedtransactions(int index);
  void set_removedtransactions(int index, const std::string& value);
  void set_removedtransactions(int index, std::string&& value);
  void set_removedtransactions(int index, const char* value);
  void set_removedtransactions(int index, const void* value, size_t size);
  std::string* add_removedtransactions();
  void add_removedtransactions(const std::string& value);
  void add_removedtransactions(std::string&& value);
  void add_removedtransactions(const char* value);
  void add_removedtransactions(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& removedtransactions() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_removedtransactions();
  private:
  const std::string& _internal_removedtransactions(int index) const;
  std::string* _internal_add_removedtransactions();
  public:

  // required bytes currentTxHash = 2;
  bool has_currenttxhash() const;
  private:
  bool _internal_has_currenttxhash() const;
  public:
  void clear_currenttxhash();
  const std::string& currenttxhash() const;
  void set_currenttxhash(const std::string& value);
  void set_currenttxhash(std::string&& value);
  void set_currenttxhash(const char* value);
  void set_currenttxhash(const void* value, size_t size);
  std::string* mutable_currenttxhash();
  std::string* release_currenttxhash();
  void set_allocated_currenttxhash(std::string* currenttxhash);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_currenttxhash();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_currenttxhash(
      std::string* currenttxhash);
  private:
  const std::string& _internal_currenttxhash() const;
  void _internal_set_currenttxhash(const std::string& value);
  std::string* _internal_mutable_currenttxhash();
  public:

  // required bytes nodePubKey = 3;
  bool has_nodepubkey() const;
  private:
  bool _internal_has_nodepubkey() const;
  public:
  void clear_nodepubkey();
  const std::string& nodepubkey() const;
  void set_nodepubkey(const std::string& value);
  void set_nodepubkey(std::string&& value);
  void set_nodepubkey(const char* value);
  void set_nodepubkey(const void* value, size_t size);
  std::string* mutable_nodepubkey();
  std::string* release_nodepubkey();
  void set_allocated_nodepubkey(std::string* nodepubkey);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_nodepubkey();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_nodepubkey(
      std::string* nodepubkey);
  private:
  const std::string& _internal_nodepubkey() const;
  void _internal_set_nodepubkey(const std::string& value);
  std::string* _internal_mutable_nodepubkey();
  public:

  // required bytes signature = 5;
  bool has_signature() const;
  private:
  bool _internal_has_signature() const;
  public:
  void clear_signature();
  const std::string& signature() const;
  void set_signature(const std::string& value);
  void set_signature(std::string&& value);
  void set_signature(const char* value);
  void set_signature(const void* value, size_t size);
  std::string* mutable_signature();
  std::string* release_signature();
  void set_allocated_signature(std::string* signature);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_signature();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_signature(
      std::string* signature);
  private:
  const std::string& _internal_signature() const;
  void _internal_set_signature(const std::string& value);
  std::string* _internal_mutable_signature();
  public:

  // required bytes previousledger = 6;
  bool has_previousledger() const;
  private:
  bool _internal_has_previousledger() const;
  public:
  void clear_previousledger();
  const std::string& previousledger() const;
  void set_previousledger(const std::string& value);
  void set_previousledger(std::string&& value);
  void set_previousledger(const char* value);
  void set_previousledger(const void* value, size_t size);
  std::string* mutable_previousledger();
  std::string* release_previousledger();
  void set_allocated_previousledger(std::string* previousledger);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_previousledger();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_previousledger(
      std::string* previousledger);
  private:
  const std::string& _internal_previousledger() const;
  void _internal_set_previousledger(const std::string& value);
  std::string* _internal_mutable_previousledger();
  public:

  // required uint32 proposeSeq = 1;
  bool has_proposeseq() const;
  private:
  bool _internal_has_proposeseq() const;
  public:
  void clear_proposeseq();
  ::PROTOBUF_NAMESPACE_ID::uint32 proposeseq() const;
  void set_proposeseq(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_proposeseq() const;
  void _internal_set_proposeseq(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // required uint32 closeTime = 4;
  bool has_closetime() const;
  private:
  bool _internal_has_closetime() const;
  public:
  void clear_closetime();
  ::PROTOBUF_NAMESPACE_ID::uint32 closetime() const;
  void set_closetime(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_closetime() const;
  void _internal_set_closetime(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional bool checkedSignature = 7 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_checkedsignature() const;
  private:
  bool _internal_has_checkedsignature() const;
  public:
  PROTOBUF_DEPRECATED void clear_checkedsignature();
  PROTOBUF_DEPRECATED bool checkedsignature() const;
  PROTOBUF_DEPRECATED void set_checkedsignature(bool value);
  private:
  bool _internal_checkedsignature() const;
  void _internal_set_checkedsignature(bool value);
  public:

  // optional uint32 hops = 12 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_hops() const;
  private:
  bool _internal_has_hops() const;
  public:
  PROTOBUF_DEPRECATED void clear_hops();
  PROTOBUF_DEPRECATED ::PROTOBUF_NAMESPACE_ID::uint32 hops() const;
  PROTOBUF_DEPRECATED void set_hops(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_hops() const;
  void _internal_set_hops(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.TMProposeSet)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> addedtransactions_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> removedtransactions_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr currenttxhash_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nodepubkey_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signature_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr previousledger_;
  ::PROTOBUF_NAMESPACE_ID::uint32 proposeseq_;
  ::PROTOBUF_NAMESPACE_ID::uint32 closetime_;
  bool checkedsignature_;
  ::PROTOBUF_NAMESPACE_ID::uint32 hops_;
  friend struct ::TableStruct_ripple_2eproto;
};
// -------------------------------------------------------------------

class TMHaveTransactionSet PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.TMHaveTransactionSet) */ {
 public:
  inline TMHaveTransactionSet() : TMHaveTransactionSet(nullptr) {};
  virtual ~TMHaveTransactionSet();

  TMHaveTransactionSet(const TMHaveTransactionSet& from);
  TMHaveTransactionSet(TMHaveTransactionSet&& from) noexcept
    : TMHaveTransactionSet() {
    *this = ::std::move(from);
  }

  inline TMHaveTransactionSet& operator=(const TMHaveTransactionSet& from) {
    CopyFrom(from);
    return *this;
  }
  inline TMHaveTransactionSet& operator=(TMHaveTransactionSet&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TMHaveTransactionSet& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TMHaveTransactionSet* internal_default_instance() {
    return reinterpret_cast<const TMHaveTransactionSet*>(
               &_TMHaveTransactionSet_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(TMHaveTransactionSet& a, TMHaveTransactionSet& b) {
    a.Swap(&b);
  }
  inline void Swap(TMHaveTransactionSet* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TMHaveTransactionSet* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TMHaveTransactionSet* New() const final {
    return CreateMaybeMessage<TMHaveTransactionSet>(nullptr);
  }

  TMHaveTransactionSet* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TMHaveTransactionSet>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TMHaveTransactionSet& from);
  void MergeFrom(const TMHaveTransactionSet& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TMHaveTransactionSet* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.TMHaveTransactionSet";
  }
  protected:
  explicit TMHaveTransactionSet(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ripple_2eproto);
    return ::descriptor_table_ripple_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHashFieldNumber = 2,
    kStatusFieldNumber = 1,
  };
  // required bytes hash = 2;
  bool has_hash() const;
  private:
  bool _internal_has_hash() const;
  public:
  void clear_hash();
  const std::string& hash() const;
  void set_hash(const std::string& value);
  void set_hash(std::string&& value);
  void set_hash(const char* value);
  void set_hash(const void* value, size_t size);
  std::string* mutable_hash();
  std::string* release_hash();
  void set_allocated_hash(std::string* hash);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_hash();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_hash(
      std::string* hash);
  private:
  const std::string& _internal_hash() const;
  void _internal_set_hash(const std::string& value);
  std::string* _internal_mutable_hash();
  public:

  // required .protocol.TxSetStatus status = 1;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  ::protocol::TxSetStatus status() const;
  void set_status(::protocol::TxSetStatus value);
  private:
  ::protocol::TxSetStatus _internal_status() const;
  void _internal_set_status(::protocol::TxSetStatus value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.TMHaveTransactionSet)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hash_;
  int status_;
  friend struct ::TableStruct_ripple_2eproto;
};
// -------------------------------------------------------------------

class TMValidatorList PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.TMValidatorList) */ {
 public:
  inline TMValidatorList() : TMValidatorList(nullptr) {};
  virtual ~TMValidatorList();

  TMValidatorList(const TMValidatorList& from);
  TMValidatorList(TMValidatorList&& from) noexcept
    : TMValidatorList() {
    *this = ::std::move(from);
  }

  inline TMValidatorList& operator=(const TMValidatorList& from) {
    CopyFrom(from);
    return *this;
  }
  inline TMValidatorList& operator=(TMValidatorList&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TMValidatorList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TMValidatorList* internal_default_instance() {
    return reinterpret_cast<const TMValidatorList*>(
               &_TMValidatorList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(TMValidatorList& a, TMValidatorList& b) {
    a.Swap(&b);
  }
  inline void Swap(TMValidatorList* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TMValidatorList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TMValidatorList* New() const final {
    return CreateMaybeMessage<TMValidatorList>(nullptr);
  }

  TMValidatorList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TMValidatorList>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TMValidatorList& from);
  void MergeFrom(const TMValidatorList& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TMValidatorList* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.TMValidatorList";
  }
  protected:
  explicit TMValidatorList(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ripple_2eproto);
    return ::descriptor_table_ripple_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kManifestFieldNumber = 1,
    kBlobFieldNumber = 2,
    kSignatureFieldNumber = 3,
    kVersionFieldNumber = 4,
  };
  // required bytes manifest = 1;
  bool has_manifest() const;
  private:
  bool _internal_has_manifest() const;
  public:
  void clear_manifest();
  const std::string& manifest() const;
  void set_manifest(const std::string& value);
  void set_manifest(std::string&& value);
  void set_manifest(const char* value);
  void set_manifest(const void* value, size_t size);
  std::string* mutable_manifest();
  std::string* release_manifest();
  void set_allocated_manifest(std::string* manifest);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_manifest();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_manifest(
      std::string* manifest);
  private:
  const std::string& _internal_manifest() const;
  void _internal_set_manifest(const std::string& value);
  std::string* _internal_mutable_manifest();
  public:

  // required bytes blob = 2;
  bool has_blob() const;
  private:
  bool _internal_has_blob() const;
  public:
  void clear_blob();
  const std::string& blob() const;
  void set_blob(const std::string& value);
  void set_blob(std::string&& value);
  void set_blob(const char* value);
  void set_blob(const void* value, size_t size);
  std::string* mutable_blob();
  std::string* release_blob();
  void set_allocated_blob(std::string* blob);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_blob();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_blob(
      std::string* blob);
  private:
  const std::string& _internal_blob() const;
  void _internal_set_blob(const std::string& value);
  std::string* _internal_mutable_blob();
  public:

  // required bytes signature = 3;
  bool has_signature() const;
  private:
  bool _internal_has_signature() const;
  public:
  void clear_signature();
  const std::string& signature() const;
  void set_signature(const std::string& value);
  void set_signature(std::string&& value);
  void set_signature(const char* value);
  void set_signature(const void* value, size_t size);
  std::string* mutable_signature();
  std::string* release_signature();
  void set_allocated_signature(std::string* signature);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_signature();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_signature(
      std::string* signature);
  private:
  const std::string& _internal_signature() const;
  void _internal_set_signature(const std::string& value);
  std::string* _internal_mutable_signature();
  public:

  // required uint32 version = 4;
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  ::PROTOBUF_NAMESPACE_ID::uint32 version() const;
  void set_version(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_version() const;
  void _internal_set_version(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.TMValidatorList)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr manifest_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr blob_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signature_;
  ::PROTOBUF_NAMESPACE_ID::uint32 version_;
  friend struct ::TableStruct_ripple_2eproto;
};
// -------------------------------------------------------------------

class ValidatorBlobInfo PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.ValidatorBlobInfo) */ {
 public:
  inline ValidatorBlobInfo() : ValidatorBlobInfo(nullptr) {};
  virtual ~ValidatorBlobInfo();

  ValidatorBlobInfo(const ValidatorBlobInfo& from);
  ValidatorBlobInfo(ValidatorBlobInfo&& from) noexcept
    : ValidatorBlobInfo() {
    *this = ::std::move(from);
  }

  inline ValidatorBlobInfo& operator=(const ValidatorBlobInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ValidatorBlobInfo& operator=(ValidatorBlobInfo&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ValidatorBlobInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ValidatorBlobInfo* internal_default_instance() {
    return reinterpret_cast<const ValidatorBlobInfo*>(
               &_ValidatorBlobInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(ValidatorBlobInfo& a, ValidatorBlobInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ValidatorBlobInfo* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ValidatorBlobInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ValidatorBlobInfo* New() const final {
    return CreateMaybeMessage<ValidatorBlobInfo>(nullptr);
  }

  ValidatorBlobInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ValidatorBlobInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ValidatorBlobInfo& from);
  void MergeFrom(const ValidatorBlobInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ValidatorBlobInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.ValidatorBlobInfo";
  }
  protected:
  explicit ValidatorBlobInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ripple_2eproto);
    return ::descriptor_table_ripple_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kManifestFieldNumber = 1,
    kBlobFieldNumber = 2,
    kSignatureFieldNumber = 3,
  };
  // optional bytes manifest = 1;
  bool has_manifest() const;
  private:
  bool _internal_has_manifest() const;
  public:
  void clear_manifest();
  const std::string& manifest() const;
  void set_manifest(const std::string& value);
  void set_manifest(std::string&& value);
  void set_manifest(const char* value);
  void set_manifest(const void* value, size_t size);
  std::string* mutable_manifest();
  std::string* release_manifest();
  void set_allocated_manifest(std::string* manifest);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_manifest();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_manifest(
      std::string* manifest);
  private:
  const std::string& _internal_manifest() const;
  void _internal_set_manifest(const std::string& value);
  std::string* _internal_mutable_manifest();
  public:

  // required bytes blob = 2;
  bool has_blob() const;
  private:
  bool _internal_has_blob() const;
  public:
  void clear_blob();
  const std::string& blob() const;
  void set_blob(const std::string& value);
  void set_blob(std::string&& value);
  void set_blob(const char* value);
  void set_blob(const void* value, size_t size);
  std::string* mutable_blob();
  std::string* release_blob();
  void set_allocated_blob(std::string* blob);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_blob();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_blob(
      std::string* blob);
  private:
  const std::string& _internal_blob() const;
  void _internal_set_blob(const std::string& value);
  std::string* _internal_mutable_blob();
  public:

  // required bytes signature = 3;
  bool has_signature() const;
  private:
  bool _internal_has_signature() const;
  public:
  void clear_signature();
  const std::string& signature() const;
  void set_signature(const std::string& value);
  void set_signature(std::string&& value);
  void set_signature(const char* value);
  void set_signature(const void* value, size_t size);
  std::string* mutable_signature();
  std::string* release_signature();
  void set_allocated_signature(std::string* signature);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_signature();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_signature(
      std::string* signature);
  private:
  const std::string& _internal_signature() const;
  void _internal_set_signature(const std::string& value);
  std::string* _internal_mutable_signature();
  public:

  // @@protoc_insertion_point(class_scope:protocol.ValidatorBlobInfo)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr manifest_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr blob_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signature_;
  friend struct ::TableStruct_ripple_2eproto;
};
// -------------------------------------------------------------------

class TMValidatorListCollection PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.TMValidatorListCollection) */ {
 public:
  inline TMValidatorListCollection() : TMValidatorListCollection(nullptr) {};
  virtual ~TMValidatorListCollection();

  TMValidatorListCollection(const TMValidatorListCollection& from);
  TMValidatorListCollection(TMValidatorListCollection&& from) noexcept
    : TMValidatorListCollection() {
    *this = ::std::move(from);
  }

  inline TMValidatorListCollection& operator=(const TMValidatorListCollection& from) {
    CopyFrom(from);
    return *this;
  }
  inline TMValidatorListCollection& operator=(TMValidatorListCollection&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TMValidatorListCollection& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TMValidatorListCollection* internal_default_instance() {
    return reinterpret_cast<const TMValidatorListCollection*>(
               &_TMValidatorListCollection_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(TMValidatorListCollection& a, TMValidatorListCollection& b) {
    a.Swap(&b);
  }
  inline void Swap(TMValidatorListCollection* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TMValidatorListCollection* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TMValidatorListCollection* New() const final {
    return CreateMaybeMessage<TMValidatorListCollection>(nullptr);
  }

  TMValidatorListCollection* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TMValidatorListCollection>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TMValidatorListCollection& from);
  void MergeFrom(const TMValidatorListCollection& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TMValidatorListCollection* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.TMValidatorListCollection";
  }
  protected:
  explicit TMValidatorListCollection(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ripple_2eproto);
    return ::descriptor_table_ripple_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlobsFieldNumber = 3,
    kManifestFieldNumber = 2,
    kVersionFieldNumber = 1,
  };
  // repeated .protocol.ValidatorBlobInfo blobs = 3;
  int blobs_size() const;
  private:
  int _internal_blobs_size() const;
  public:
  void clear_blobs();
  ::protocol::ValidatorBlobInfo* mutable_blobs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::ValidatorBlobInfo >*
      mutable_blobs();
  private:
  const ::protocol::ValidatorBlobInfo& _internal_blobs(int index) const;
  ::protocol::ValidatorBlobInfo* _internal_add_blobs();
  public:
  const ::protocol::ValidatorBlobInfo& blobs(int index) const;
  ::protocol::ValidatorBlobInfo* add_blobs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::ValidatorBlobInfo >&
      blobs() const;

  // required bytes manifest = 2;
  bool has_manifest() const;
  private:
  bool _internal_has_manifest() const;
  public:
  void clear_manifest();
  const std::string& manifest() const;
  void set_manifest(const std::string& value);
  void set_manifest(std::string&& value);
  void set_manifest(const char* value);
  void set_manifest(const void* value, size_t size);
  std::string* mutable_manifest();
  std::string* release_manifest();
  void set_allocated_manifest(std::string* manifest);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_manifest();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_manifest(
      std::string* manifest);
  private:
  const std::string& _internal_manifest() const;
  void _internal_set_manifest(const std::string& value);
  std::string* _internal_mutable_manifest();
  public:

  // required uint32 version = 1;
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  ::PROTOBUF_NAMESPACE_ID::uint32 version() const;
  void set_version(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_version() const;
  void _internal_set_version(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.TMValidatorListCollection)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::ValidatorBlobInfo > blobs_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr manifest_;
  ::PROTOBUF_NAMESPACE_ID::uint32 version_;
  friend struct ::TableStruct_ripple_2eproto;
};
// -------------------------------------------------------------------

class TMValidation PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.TMValidation) */ {
 public:
  inline TMValidation() : TMValidation(nullptr) {};
  virtual ~TMValidation();

  TMValidation(const TMValidation& from);
  TMValidation(TMValidation&& from) noexcept
    : TMValidation() {
    *this = ::std::move(from);
  }

  inline TMValidation& operator=(const TMValidation& from) {
    CopyFrom(from);
    return *this;
  }
  inline TMValidation& operator=(TMValidation&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TMValidation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TMValidation* internal_default_instance() {
    return reinterpret_cast<const TMValidation*>(
               &_TMValidation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(TMValidation& a, TMValidation& b) {
    a.Swap(&b);
  }
  inline void Swap(TMValidation* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TMValidation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TMValidation* New() const final {
    return CreateMaybeMessage<TMValidation>(nullptr);
  }

  TMValidation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TMValidation>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TMValidation& from);
  void MergeFrom(const TMValidation& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TMValidation* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.TMValidation";
  }
  protected:
  explicit TMValidation(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ripple_2eproto);
    return ::descriptor_table_ripple_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValidationFieldNumber = 1,
    kCheckedSignatureFieldNumber = 2,
    kHopsFieldNumber = 3,
  };
  // required bytes validation = 1;
  bool has_validation() const;
  private:
  bool _internal_has_validation() const;
  public:
  void clear_validation();
  const std::string& validation() const;
  void set_validation(const std::string& value);
  void set_validation(std::string&& value);
  void set_validation(const char* value);
  void set_validation(const void* value, size_t size);
  std::string* mutable_validation();
  std::string* release_validation();
  void set_allocated_validation(std::string* validation);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_validation();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_validation(
      std::string* validation);
  private:
  const std::string& _internal_validation() const;
  void _internal_set_validation(const std::string& value);
  std::string* _internal_mutable_validation();
  public:

  // optional bool checkedSignature = 2 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_checkedsignature() const;
  private:
  bool _internal_has_checkedsignature() const;
  public:
  PROTOBUF_DEPRECATED void clear_checkedsignature();
  PROTOBUF_DEPRECATED bool checkedsignature() const;
  PROTOBUF_DEPRECATED void set_checkedsignature(bool value);
  private:
  bool _internal_checkedsignature() const;
  void _internal_set_checkedsignature(bool value);
  public:

  // optional uint32 hops = 3 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_hops() const;
  private:
  bool _internal_has_hops() const;
  public:
  PROTOBUF_DEPRECATED void clear_hops();
  PROTOBUF_DEPRECATED ::PROTOBUF_NAMESPACE_ID::uint32 hops() const;
  PROTOBUF_DEPRECATED void set_hops(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_hops() const;
  void _internal_set_hops(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.TMValidation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr validation_;
  bool checkedsignature_;
  ::PROTOBUF_NAMESPACE_ID::uint32 hops_;
  friend struct ::TableStruct_ripple_2eproto;
};
// -------------------------------------------------------------------

class TMEndpoints_TMEndpointv2 PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.TMEndpoints.TMEndpointv2) */ {
 public:
  inline TMEndpoints_TMEndpointv2() : TMEndpoints_TMEndpointv2(nullptr) {};
  virtual ~TMEndpoints_TMEndpointv2();

  TMEndpoints_TMEndpointv2(const TMEndpoints_TMEndpointv2& from);
  TMEndpoints_TMEndpointv2(TMEndpoints_TMEndpointv2&& from) noexcept
    : TMEndpoints_TMEndpointv2() {
    *this = ::std::move(from);
  }

  inline TMEndpoints_TMEndpointv2& operator=(const TMEndpoints_TMEndpointv2& from) {
    CopyFrom(from);
    return *this;
  }
  inline TMEndpoints_TMEndpointv2& operator=(TMEndpoints_TMEndpointv2&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TMEndpoints_TMEndpointv2& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TMEndpoints_TMEndpointv2* internal_default_instance() {
    return reinterpret_cast<const TMEndpoints_TMEndpointv2*>(
               &_TMEndpoints_TMEndpointv2_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(TMEndpoints_TMEndpointv2& a, TMEndpoints_TMEndpointv2& b) {
    a.Swap(&b);
  }
  inline void Swap(TMEndpoints_TMEndpointv2* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TMEndpoints_TMEndpointv2* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TMEndpoints_TMEndpointv2* New() const final {
    return CreateMaybeMessage<TMEndpoints_TMEndpointv2>(nullptr);
  }

  TMEndpoints_TMEndpointv2* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TMEndpoints_TMEndpointv2>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TMEndpoints_TMEndpointv2& from);
  void MergeFrom(const TMEndpoints_TMEndpointv2& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TMEndpoints_TMEndpointv2* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.TMEndpoints.TMEndpointv2";
  }
  protected:
  explicit TMEndpoints_TMEndpointv2(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ripple_2eproto);
    return ::descriptor_table_ripple_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEndpointFieldNumber = 1,
    kHopsFieldNumber = 2,
  };
  // required string endpoint = 1;
  bool has_endpoint() const;
  private:
  bool _internal_has_endpoint() const;
  public:
  void clear_endpoint();
  const std::string& endpoint() const;
  void set_endpoint(const std::string& value);
  void set_endpoint(std::string&& value);
  void set_endpoint(const char* value);
  void set_endpoint(const char* value, size_t size);
  std::string* mutable_endpoint();
  std::string* release_endpoint();
  void set_allocated_endpoint(std::string* endpoint);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_endpoint();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_endpoint(
      std::string* endpoint);
  private:
  const std::string& _internal_endpoint() const;
  void _internal_set_endpoint(const std::string& value);
  std::string* _internal_mutable_endpoint();
  public:

  // required uint32 hops = 2;
  bool has_hops() const;
  private:
  bool _internal_has_hops() const;
  public:
  void clear_hops();
  ::PROTOBUF_NAMESPACE_ID::uint32 hops() const;
  void set_hops(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_hops() const;
  void _internal_set_hops(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.TMEndpoints.TMEndpointv2)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr endpoint_;
  ::PROTOBUF_NAMESPACE_ID::uint32 hops_;
  friend struct ::TableStruct_ripple_2eproto;
};
// -------------------------------------------------------------------

class TMEndpoints PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.TMEndpoints) */ {
 public:
  inline TMEndpoints() : TMEndpoints(nullptr) {};
  virtual ~TMEndpoints();

  TMEndpoints(const TMEndpoints& from);
  TMEndpoints(TMEndpoints&& from) noexcept
    : TMEndpoints() {
    *this = ::std::move(from);
  }

  inline TMEndpoints& operator=(const TMEndpoints& from) {
    CopyFrom(from);
    return *this;
  }
  inline TMEndpoints& operator=(TMEndpoints&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TMEndpoints& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TMEndpoints* internal_default_instance() {
    return reinterpret_cast<const TMEndpoints*>(
               &_TMEndpoints_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(TMEndpoints& a, TMEndpoints& b) {
    a.Swap(&b);
  }
  inline void Swap(TMEndpoints* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TMEndpoints* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TMEndpoints* New() const final {
    return CreateMaybeMessage<TMEndpoints>(nullptr);
  }

  TMEndpoints* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TMEndpoints>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TMEndpoints& from);
  void MergeFrom(const TMEndpoints& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TMEndpoints* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.TMEndpoints";
  }
  protected:
  explicit TMEndpoints(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ripple_2eproto);
    return ::descriptor_table_ripple_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef TMEndpoints_TMEndpointv2 TMEndpointv2;

  // accessors -------------------------------------------------------

  enum : int {
    kEndpointsV2FieldNumber = 3,
    kVersionFieldNumber = 1,
  };
  // repeated .protocol.TMEndpoints.TMEndpointv2 endpoints_v2 = 3;
  int endpoints_v2_size() const;
  private:
  int _internal_endpoints_v2_size() const;
  public:
  void clear_endpoints_v2();
  ::protocol::TMEndpoints_TMEndpointv2* mutable_endpoints_v2(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::TMEndpoints_TMEndpointv2 >*
      mutable_endpoints_v2();
  private:
  const ::protocol::TMEndpoints_TMEndpointv2& _internal_endpoints_v2(int index) const;
  ::protocol::TMEndpoints_TMEndpointv2* _internal_add_endpoints_v2();
  public:
  const ::protocol::TMEndpoints_TMEndpointv2& endpoints_v2(int index) const;
  ::protocol::TMEndpoints_TMEndpointv2* add_endpoints_v2();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::TMEndpoints_TMEndpointv2 >&
      endpoints_v2() const;

  // required uint32 version = 1;
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  ::PROTOBUF_NAMESPACE_ID::uint32 version() const;
  void set_version(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_version() const;
  void _internal_set_version(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.TMEndpoints)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::TMEndpoints_TMEndpointv2 > endpoints_v2_;
  ::PROTOBUF_NAMESPACE_ID::uint32 version_;
  friend struct ::TableStruct_ripple_2eproto;
};
// -------------------------------------------------------------------

class TMIndexedObject PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.TMIndexedObject) */ {
 public:
  inline TMIndexedObject() : TMIndexedObject(nullptr) {};
  virtual ~TMIndexedObject();

  TMIndexedObject(const TMIndexedObject& from);
  TMIndexedObject(TMIndexedObject&& from) noexcept
    : TMIndexedObject() {
    *this = ::std::move(from);
  }

  inline TMIndexedObject& operator=(const TMIndexedObject& from) {
    CopyFrom(from);
    return *this;
  }
  inline TMIndexedObject& operator=(TMIndexedObject&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TMIndexedObject& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TMIndexedObject* internal_default_instance() {
    return reinterpret_cast<const TMIndexedObject*>(
               &_TMIndexedObject_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(TMIndexedObject& a, TMIndexedObject& b) {
    a.Swap(&b);
  }
  inline void Swap(TMIndexedObject* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TMIndexedObject* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TMIndexedObject* New() const final {
    return CreateMaybeMessage<TMIndexedObject>(nullptr);
  }

  TMIndexedObject* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TMIndexedObject>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TMIndexedObject& from);
  void MergeFrom(const TMIndexedObject& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TMIndexedObject* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.TMIndexedObject";
  }
  protected:
  explicit TMIndexedObject(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ripple_2eproto);
    return ::descriptor_table_ripple_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHashFieldNumber = 1,
    kNodeIDFieldNumber = 2,
    kIndexFieldNumber = 3,
    kDataFieldNumber = 4,
    kLedgerSeqFieldNumber = 5,
  };
  // optional bytes hash = 1;
  bool has_hash() const;
  private:
  bool _internal_has_hash() const;
  public:
  void clear_hash();
  const std::string& hash() const;
  void set_hash(const std::string& value);
  void set_hash(std::string&& value);
  void set_hash(const char* value);
  void set_hash(const void* value, size_t size);
  std::string* mutable_hash();
  std::string* release_hash();
  void set_allocated_hash(std::string* hash);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_hash();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_hash(
      std::string* hash);
  private:
  const std::string& _internal_hash() const;
  void _internal_set_hash(const std::string& value);
  std::string* _internal_mutable_hash();
  public:

  // optional bytes nodeID = 2;
  bool has_nodeid() const;
  private:
  bool _internal_has_nodeid() const;
  public:
  void clear_nodeid();
  const std::string& nodeid() const;
  void set_nodeid(const std::string& value);
  void set_nodeid(std::string&& value);
  void set_nodeid(const char* value);
  void set_nodeid(const void* value, size_t size);
  std::string* mutable_nodeid();
  std::string* release_nodeid();
  void set_allocated_nodeid(std::string* nodeid);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_nodeid();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_nodeid(
      std::string* nodeid);
  private:
  const std::string& _internal_nodeid() const;
  void _internal_set_nodeid(const std::string& value);
  std::string* _internal_mutable_nodeid();
  public:

  // optional bytes index = 3;
  bool has_index() const;
  private:
  bool _internal_has_index() const;
  public:
  void clear_index();
  const std::string& index() const;
  void set_index(const std::string& value);
  void set_index(std::string&& value);
  void set_index(const char* value);
  void set_index(const void* value, size_t size);
  std::string* mutable_index();
  std::string* release_index();
  void set_allocated_index(std::string* index);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_index();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_index(
      std::string* index);
  private:
  const std::string& _internal_index() const;
  void _internal_set_index(const std::string& value);
  std::string* _internal_mutable_index();
  public:

  // optional bytes data = 4;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const std::string& data() const;
  void set_data(const std::string& value);
  void set_data(std::string&& value);
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  std::string* mutable_data();
  std::string* release_data();
  void set_allocated_data(std::string* data);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_data();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_data(
      std::string* data);
  private:
  const std::string& _internal_data() const;
  void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // optional uint32 ledgerSeq = 5;
  bool has_ledgerseq() const;
  private:
  bool _internal_has_ledgerseq() const;
  public:
  void clear_ledgerseq();
  ::PROTOBUF_NAMESPACE_ID::uint32 ledgerseq() const;
  void set_ledgerseq(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_ledgerseq() const;
  void _internal_set_ledgerseq(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.TMIndexedObject)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hash_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nodeid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr index_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  ::PROTOBUF_NAMESPACE_ID::uint32 ledgerseq_;
  friend struct ::TableStruct_ripple_2eproto;
};
// -------------------------------------------------------------------

class TMGetObjectByHash PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.TMGetObjectByHash) */ {
 public:
  inline TMGetObjectByHash() : TMGetObjectByHash(nullptr) {};
  virtual ~TMGetObjectByHash();

  TMGetObjectByHash(const TMGetObjectByHash& from);
  TMGetObjectByHash(TMGetObjectByHash&& from) noexcept
    : TMGetObjectByHash() {
    *this = ::std::move(from);
  }

  inline TMGetObjectByHash& operator=(const TMGetObjectByHash& from) {
    CopyFrom(from);
    return *this;
  }
  inline TMGetObjectByHash& operator=(TMGetObjectByHash&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TMGetObjectByHash& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TMGetObjectByHash* internal_default_instance() {
    return reinterpret_cast<const TMGetObjectByHash*>(
               &_TMGetObjectByHash_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(TMGetObjectByHash& a, TMGetObjectByHash& b) {
    a.Swap(&b);
  }
  inline void Swap(TMGetObjectByHash* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TMGetObjectByHash* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TMGetObjectByHash* New() const final {
    return CreateMaybeMessage<TMGetObjectByHash>(nullptr);
  }

  TMGetObjectByHash* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TMGetObjectByHash>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TMGetObjectByHash& from);
  void MergeFrom(const TMGetObjectByHash& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TMGetObjectByHash* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.TMGetObjectByHash";
  }
  protected:
  explicit TMGetObjectByHash(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ripple_2eproto);
    return ::descriptor_table_ripple_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef TMGetObjectByHash_ObjectType ObjectType;
  static constexpr ObjectType otUNKNOWN =
    TMGetObjectByHash_ObjectType_otUNKNOWN;
  static constexpr ObjectType otLEDGER =
    TMGetObjectByHash_ObjectType_otLEDGER;
  static constexpr ObjectType otTRANSACTION =
    TMGetObjectByHash_ObjectType_otTRANSACTION;
  static constexpr ObjectType otTRANSACTION_NODE =
    TMGetObjectByHash_ObjectType_otTRANSACTION_NODE;
  static constexpr ObjectType otSTATE_NODE =
    TMGetObjectByHash_ObjectType_otSTATE_NODE;
  static constexpr ObjectType otCAS_OBJECT =
    TMGetObjectByHash_ObjectType_otCAS_OBJECT;
  static constexpr ObjectType otFETCH_PACK =
    TMGetObjectByHash_ObjectType_otFETCH_PACK;
  static constexpr ObjectType otTRANSACTIONS =
    TMGetObjectByHash_ObjectType_otTRANSACTIONS;
  static inline bool ObjectType_IsValid(int value) {
    return TMGetObjectByHash_ObjectType_IsValid(value);
  }
  static constexpr ObjectType ObjectType_MIN =
    TMGetObjectByHash_ObjectType_ObjectType_MIN;
  static constexpr ObjectType ObjectType_MAX =
    TMGetObjectByHash_ObjectType_ObjectType_MAX;
  static constexpr int ObjectType_ARRAYSIZE =
    TMGetObjectByHash_ObjectType_ObjectType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ObjectType_descriptor() {
    return TMGetObjectByHash_ObjectType_descriptor();
  }
  template<typename T>
  static inline const std::string& ObjectType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ObjectType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ObjectType_Name.");
    return TMGetObjectByHash_ObjectType_Name(enum_t_value);
  }
  static inline bool ObjectType_Parse(const std::string& name,
      ObjectType* value) {
    return TMGetObjectByHash_ObjectType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kObjectsFieldNumber = 6,
    kLedgerHashFieldNumber = 4,
    kTypeFieldNumber = 1,
    kSeqFieldNumber = 3,
    kQueryFieldNumber = 2,
    kFatFieldNumber = 5,
  };
  // repeated .protocol.TMIndexedObject objects = 6;
  int objects_size() const;
  private:
  int _internal_objects_size() const;
  public:
  void clear_objects();
  ::protocol::TMIndexedObject* mutable_objects(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::TMIndexedObject >*
      mutable_objects();
  private:
  const ::protocol::TMIndexedObject& _internal_objects(int index) const;
  ::protocol::TMIndexedObject* _internal_add_objects();
  public:
  const ::protocol::TMIndexedObject& objects(int index) const;
  ::protocol::TMIndexedObject* add_objects();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::TMIndexedObject >&
      objects() const;

  // optional bytes ledgerHash = 4;
  bool has_ledgerhash() const;
  private:
  bool _internal_has_ledgerhash() const;
  public:
  void clear_ledgerhash();
  const std::string& ledgerhash() const;
  void set_ledgerhash(const std::string& value);
  void set_ledgerhash(std::string&& value);
  void set_ledgerhash(const char* value);
  void set_ledgerhash(const void* value, size_t size);
  std::string* mutable_ledgerhash();
  std::string* release_ledgerhash();
  void set_allocated_ledgerhash(std::string* ledgerhash);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_ledgerhash();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_ledgerhash(
      std::string* ledgerhash);
  private:
  const std::string& _internal_ledgerhash() const;
  void _internal_set_ledgerhash(const std::string& value);
  std::string* _internal_mutable_ledgerhash();
  public:

  // required .protocol.TMGetObjectByHash.ObjectType type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::protocol::TMGetObjectByHash_ObjectType type() const;
  void set_type(::protocol::TMGetObjectByHash_ObjectType value);
  private:
  ::protocol::TMGetObjectByHash_ObjectType _internal_type() const;
  void _internal_set_type(::protocol::TMGetObjectByHash_ObjectType value);
  public:

  // optional uint32 seq = 3;
  bool has_seq() const;
  private:
  bool _internal_has_seq() const;
  public:
  void clear_seq();
  ::PROTOBUF_NAMESPACE_ID::uint32 seq() const;
  void set_seq(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_seq() const;
  void _internal_set_seq(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // required bool query = 2;
  bool has_query() const;
  private:
  bool _internal_has_query() const;
  public:
  void clear_query();
  bool query() const;
  void set_query(bool value);
  private:
  bool _internal_query() const;
  void _internal_set_query(bool value);
  public:

  // optional bool fat = 5;
  bool has_fat() const;
  private:
  bool _internal_has_fat() const;
  public:
  void clear_fat();
  bool fat() const;
  void set_fat(bool value);
  private:
  bool _internal_fat() const;
  void _internal_set_fat(bool value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.TMGetObjectByHash)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::TMIndexedObject > objects_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ledgerhash_;
  int type_;
  ::PROTOBUF_NAMESPACE_ID::uint32 seq_;
  bool query_;
  bool fat_;
  friend struct ::TableStruct_ripple_2eproto;
};
// -------------------------------------------------------------------

class TMLedgerNode PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.TMLedgerNode) */ {
 public:
  inline TMLedgerNode() : TMLedgerNode(nullptr) {};
  virtual ~TMLedgerNode();

  TMLedgerNode(const TMLedgerNode& from);
  TMLedgerNode(TMLedgerNode&& from) noexcept
    : TMLedgerNode() {
    *this = ::std::move(from);
  }

  inline TMLedgerNode& operator=(const TMLedgerNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline TMLedgerNode& operator=(TMLedgerNode&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TMLedgerNode& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TMLedgerNode* internal_default_instance() {
    return reinterpret_cast<const TMLedgerNode*>(
               &_TMLedgerNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(TMLedgerNode& a, TMLedgerNode& b) {
    a.Swap(&b);
  }
  inline void Swap(TMLedgerNode* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TMLedgerNode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TMLedgerNode* New() const final {
    return CreateMaybeMessage<TMLedgerNode>(nullptr);
  }

  TMLedgerNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TMLedgerNode>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TMLedgerNode& from);
  void MergeFrom(const TMLedgerNode& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TMLedgerNode* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.TMLedgerNode";
  }
  protected:
  explicit TMLedgerNode(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ripple_2eproto);
    return ::descriptor_table_ripple_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodedataFieldNumber = 1,
    kNodeidFieldNumber = 2,
  };
  // required bytes nodedata = 1;
  bool has_nodedata() const;
  private:
  bool _internal_has_nodedata() const;
  public:
  void clear_nodedata();
  const std::string& nodedata() const;
  void set_nodedata(const std::string& value);
  void set_nodedata(std::string&& value);
  void set_nodedata(const char* value);
  void set_nodedata(const void* value, size_t size);
  std::string* mutable_nodedata();
  std::string* release_nodedata();
  void set_allocated_nodedata(std::string* nodedata);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_nodedata();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_nodedata(
      std::string* nodedata);
  private:
  const std::string& _internal_nodedata() const;
  void _internal_set_nodedata(const std::string& value);
  std::string* _internal_mutable_nodedata();
  public:

  // optional bytes nodeid = 2;
  bool has_nodeid() const;
  private:
  bool _internal_has_nodeid() const;
  public:
  void clear_nodeid();
  const std::string& nodeid() const;
  void set_nodeid(const std::string& value);
  void set_nodeid(std::string&& value);
  void set_nodeid(const char* value);
  void set_nodeid(const void* value, size_t size);
  std::string* mutable_nodeid();
  std::string* release_nodeid();
  void set_allocated_nodeid(std::string* nodeid);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_nodeid();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_nodeid(
      std::string* nodeid);
  private:
  const std::string& _internal_nodeid() const;
  void _internal_set_nodeid(const std::string& value);
  std::string* _internal_mutable_nodeid();
  public:

  // @@protoc_insertion_point(class_scope:protocol.TMLedgerNode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nodedata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nodeid_;
  friend struct ::TableStruct_ripple_2eproto;
};
// -------------------------------------------------------------------

class TMGetLedger PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.TMGetLedger) */ {
 public:
  inline TMGetLedger() : TMGetLedger(nullptr) {};
  virtual ~TMGetLedger();

  TMGetLedger(const TMGetLedger& from);
  TMGetLedger(TMGetLedger&& from) noexcept
    : TMGetLedger() {
    *this = ::std::move(from);
  }

  inline TMGetLedger& operator=(const TMGetLedger& from) {
    CopyFrom(from);
    return *this;
  }
  inline TMGetLedger& operator=(TMGetLedger&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TMGetLedger& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TMGetLedger* internal_default_instance() {
    return reinterpret_cast<const TMGetLedger*>(
               &_TMGetLedger_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(TMGetLedger& a, TMGetLedger& b) {
    a.Swap(&b);
  }
  inline void Swap(TMGetLedger* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TMGetLedger* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TMGetLedger* New() const final {
    return CreateMaybeMessage<TMGetLedger>(nullptr);
  }

  TMGetLedger* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TMGetLedger>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TMGetLedger& from);
  void MergeFrom(const TMGetLedger& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TMGetLedger* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.TMGetLedger";
  }
  protected:
  explicit TMGetLedger(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ripple_2eproto);
    return ::descriptor_table_ripple_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodeIDsFieldNumber = 5,
    kLedgerHashFieldNumber = 3,
    kItypeFieldNumber = 1,
    kLtypeFieldNumber = 2,
    kLedgerSeqFieldNumber = 4,
    kQueryTypeFieldNumber = 7,
    kRequestCookieFieldNumber = 6,
    kQueryDepthFieldNumber = 8,
  };
  // repeated bytes nodeIDs = 5;
  int nodeids_size() const;
  private:
  int _internal_nodeids_size() const;
  public:
  void clear_nodeids();
  const std::string& nodeids(int index) const;
  std::string* mutable_nodeids(int index);
  void set_nodeids(int index, const std::string& value);
  void set_nodeids(int index, std::string&& value);
  void set_nodeids(int index, const char* value);
  void set_nodeids(int index, const void* value, size_t size);
  std::string* add_nodeids();
  void add_nodeids(const std::string& value);
  void add_nodeids(std::string&& value);
  void add_nodeids(const char* value);
  void add_nodeids(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& nodeids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_nodeids();
  private:
  const std::string& _internal_nodeids(int index) const;
  std::string* _internal_add_nodeids();
  public:

  // optional bytes ledgerHash = 3;
  bool has_ledgerhash() const;
  private:
  bool _internal_has_ledgerhash() const;
  public:
  void clear_ledgerhash();
  const std::string& ledgerhash() const;
  void set_ledgerhash(const std::string& value);
  void set_ledgerhash(std::string&& value);
  void set_ledgerhash(const char* value);
  void set_ledgerhash(const void* value, size_t size);
  std::string* mutable_ledgerhash();
  std::string* release_ledgerhash();
  void set_allocated_ledgerhash(std::string* ledgerhash);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_ledgerhash();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_ledgerhash(
      std::string* ledgerhash);
  private:
  const std::string& _internal_ledgerhash() const;
  void _internal_set_ledgerhash(const std::string& value);
  std::string* _internal_mutable_ledgerhash();
  public:

  // required .protocol.TMLedgerInfoType itype = 1;
  bool has_itype() const;
  private:
  bool _internal_has_itype() const;
  public:
  void clear_itype();
  ::protocol::TMLedgerInfoType itype() const;
  void set_itype(::protocol::TMLedgerInfoType value);
  private:
  ::protocol::TMLedgerInfoType _internal_itype() const;
  void _internal_set_itype(::protocol::TMLedgerInfoType value);
  public:

  // optional .protocol.TMLedgerType ltype = 2;
  bool has_ltype() const;
  private:
  bool _internal_has_ltype() const;
  public:
  void clear_ltype();
  ::protocol::TMLedgerType ltype() const;
  void set_ltype(::protocol::TMLedgerType value);
  private:
  ::protocol::TMLedgerType _internal_ltype() const;
  void _internal_set_ltype(::protocol::TMLedgerType value);
  public:

  // optional uint32 ledgerSeq = 4;
  bool has_ledgerseq() const;
  private:
  bool _internal_has_ledgerseq() const;
  public:
  void clear_ledgerseq();
  ::PROTOBUF_NAMESPACE_ID::uint32 ledgerseq() const;
  void set_ledgerseq(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_ledgerseq() const;
  void _internal_set_ledgerseq(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional .protocol.TMQueryType queryType = 7;
  bool has_querytype() const;
  private:
  bool _internal_has_querytype() const;
  public:
  void clear_querytype();
  ::protocol::TMQueryType querytype() const;
  void set_querytype(::protocol::TMQueryType value);
  private:
  ::protocol::TMQueryType _internal_querytype() const;
  void _internal_set_querytype(::protocol::TMQueryType value);
  public:

  // optional uint64 requestCookie = 6;
  bool has_requestcookie() const;
  private:
  bool _internal_has_requestcookie() const;
  public:
  void clear_requestcookie();
  ::PROTOBUF_NAMESPACE_ID::uint64 requestcookie() const;
  void set_requestcookie(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_requestcookie() const;
  void _internal_set_requestcookie(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional uint32 queryDepth = 8;
  bool has_querydepth() const;
  private:
  bool _internal_has_querydepth() const;
  public:
  void clear_querydepth();
  ::PROTOBUF_NAMESPACE_ID::uint32 querydepth() const;
  void set_querydepth(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_querydepth() const;
  void _internal_set_querydepth(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.TMGetLedger)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> nodeids_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ledgerhash_;
  int itype_;
  int ltype_;
  ::PROTOBUF_NAMESPACE_ID::uint32 ledgerseq_;
  int querytype_;
  ::PROTOBUF_NAMESPACE_ID::uint64 requestcookie_;
  ::PROTOBUF_NAMESPACE_ID::uint32 querydepth_;
  friend struct ::TableStruct_ripple_2eproto;
};
// -------------------------------------------------------------------

class TMLedgerData PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.TMLedgerData) */ {
 public:
  inline TMLedgerData() : TMLedgerData(nullptr) {};
  virtual ~TMLedgerData();

  TMLedgerData(const TMLedgerData& from);
  TMLedgerData(TMLedgerData&& from) noexcept
    : TMLedgerData() {
    *this = ::std::move(from);
  }

  inline TMLedgerData& operator=(const TMLedgerData& from) {
    CopyFrom(from);
    return *this;
  }
  inline TMLedgerData& operator=(TMLedgerData&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TMLedgerData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TMLedgerData* internal_default_instance() {
    return reinterpret_cast<const TMLedgerData*>(
               &_TMLedgerData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(TMLedgerData& a, TMLedgerData& b) {
    a.Swap(&b);
  }
  inline void Swap(TMLedgerData* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TMLedgerData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TMLedgerData* New() const final {
    return CreateMaybeMessage<TMLedgerData>(nullptr);
  }

  TMLedgerData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TMLedgerData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TMLedgerData& from);
  void MergeFrom(const TMLedgerData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TMLedgerData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.TMLedgerData";
  }
  protected:
  explicit TMLedgerData(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ripple_2eproto);
    return ::descriptor_table_ripple_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodesFieldNumber = 4,
    kLedgerHashFieldNumber = 1,
    kLedgerSeqFieldNumber = 2,
    kTypeFieldNumber = 3,
    kRequestCookieFieldNumber = 5,
    kErrorFieldNumber = 6,
  };
  // repeated .protocol.TMLedgerNode nodes = 4;
  int nodes_size() const;
  private:
  int _internal_nodes_size() const;
  public:
  void clear_nodes();
  ::protocol::TMLedgerNode* mutable_nodes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::TMLedgerNode >*
      mutable_nodes();
  private:
  const ::protocol::TMLedgerNode& _internal_nodes(int index) const;
  ::protocol::TMLedgerNode* _internal_add_nodes();
  public:
  const ::protocol::TMLedgerNode& nodes(int index) const;
  ::protocol::TMLedgerNode* add_nodes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::TMLedgerNode >&
      nodes() const;

  // required bytes ledgerHash = 1;
  bool has_ledgerhash() const;
  private:
  bool _internal_has_ledgerhash() const;
  public:
  void clear_ledgerhash();
  const std::string& ledgerhash() const;
  void set_ledgerhash(const std::string& value);
  void set_ledgerhash(std::string&& value);
  void set_ledgerhash(const char* value);
  void set_ledgerhash(const void* value, size_t size);
  std::string* mutable_ledgerhash();
  std::string* release_ledgerhash();
  void set_allocated_ledgerhash(std::string* ledgerhash);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_ledgerhash();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_ledgerhash(
      std::string* ledgerhash);
  private:
  const std::string& _internal_ledgerhash() const;
  void _internal_set_ledgerhash(const std::string& value);
  std::string* _internal_mutable_ledgerhash();
  public:

  // required uint32 ledgerSeq = 2;
  bool has_ledgerseq() const;
  private:
  bool _internal_has_ledgerseq() const;
  public:
  void clear_ledgerseq();
  ::PROTOBUF_NAMESPACE_ID::uint32 ledgerseq() const;
  void set_ledgerseq(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_ledgerseq() const;
  void _internal_set_ledgerseq(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // required .protocol.TMLedgerInfoType type = 3;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::protocol::TMLedgerInfoType type() const;
  void set_type(::protocol::TMLedgerInfoType value);
  private:
  ::protocol::TMLedgerInfoType _internal_type() const;
  void _internal_set_type(::protocol::TMLedgerInfoType value);
  public:

  // optional uint32 requestCookie = 5;
  bool has_requestcookie() const;
  private:
  bool _internal_has_requestcookie() const;
  public:
  void clear_requestcookie();
  ::PROTOBUF_NAMESPACE_ID::uint32 requestcookie() const;
  void set_requestcookie(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_requestcookie() const;
  void _internal_set_requestcookie(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional .protocol.TMReplyError error = 6;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  ::protocol::TMReplyError error() const;
  void set_error(::protocol::TMReplyError value);
  private:
  ::protocol::TMReplyError _internal_error() const;
  void _internal_set_error(::protocol::TMReplyError value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.TMLedgerData)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::TMLedgerNode > nodes_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ledgerhash_;
  ::PROTOBUF_NAMESPACE_ID::uint32 ledgerseq_;
  int type_;
  ::PROTOBUF_NAMESPACE_ID::uint32 requestcookie_;
  int error_;
  friend struct ::TableStruct_ripple_2eproto;
};
// -------------------------------------------------------------------

class TMPing PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.TMPing) */ {
 public:
  inline TMPing() : TMPing(nullptr) {};
  virtual ~TMPing();

  TMPing(const TMPing& from);
  TMPing(TMPing&& from) noexcept
    : TMPing() {
    *this = ::std::move(from);
  }

  inline TMPing& operator=(const TMPing& from) {
    CopyFrom(from);
    return *this;
  }
  inline TMPing& operator=(TMPing&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TMPing& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TMPing* internal_default_instance() {
    return reinterpret_cast<const TMPing*>(
               &_TMPing_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(TMPing& a, TMPing& b) {
    a.Swap(&b);
  }
  inline void Swap(TMPing* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TMPing* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TMPing* New() const final {
    return CreateMaybeMessage<TMPing>(nullptr);
  }

  TMPing* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TMPing>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TMPing& from);
  void MergeFrom(const TMPing& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TMPing* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.TMPing";
  }
  protected:
  explicit TMPing(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ripple_2eproto);
    return ::descriptor_table_ripple_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef TMPing_pingType pingType;
  static constexpr pingType ptPING =
    TMPing_pingType_ptPING;
  static constexpr pingType ptPONG =
    TMPing_pingType_ptPONG;
  static inline bool pingType_IsValid(int value) {
    return TMPing_pingType_IsValid(value);
  }
  static constexpr pingType pingType_MIN =
    TMPing_pingType_pingType_MIN;
  static constexpr pingType pingType_MAX =
    TMPing_pingType_pingType_MAX;
  static constexpr int pingType_ARRAYSIZE =
    TMPing_pingType_pingType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  pingType_descriptor() {
    return TMPing_pingType_descriptor();
  }
  template<typename T>
  static inline const std::string& pingType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, pingType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function pingType_Name.");
    return TMPing_pingType_Name(enum_t_value);
  }
  static inline bool pingType_Parse(const std::string& name,
      pingType* value) {
    return TMPing_pingType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kSeqFieldNumber = 2,
    kPingTimeFieldNumber = 3,
    kNetTimeFieldNumber = 4,
  };
  // required .protocol.TMPing.pingType type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::protocol::TMPing_pingType type() const;
  void set_type(::protocol::TMPing_pingType value);
  private:
  ::protocol::TMPing_pingType _internal_type() const;
  void _internal_set_type(::protocol::TMPing_pingType value);
  public:

  // optional uint32 seq = 2;
  bool has_seq() const;
  private:
  bool _internal_has_seq() const;
  public:
  void clear_seq();
  ::PROTOBUF_NAMESPACE_ID::uint32 seq() const;
  void set_seq(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_seq() const;
  void _internal_set_seq(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint64 pingTime = 3;
  bool has_pingtime() const;
  private:
  bool _internal_has_pingtime() const;
  public:
  void clear_pingtime();
  ::PROTOBUF_NAMESPACE_ID::uint64 pingtime() const;
  void set_pingtime(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_pingtime() const;
  void _internal_set_pingtime(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // optional uint64 netTime = 4;
  bool has_nettime() const;
  private:
  bool _internal_has_nettime() const;
  public:
  void clear_nettime();
  ::PROTOBUF_NAMESPACE_ID::uint64 nettime() const;
  void set_nettime(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_nettime() const;
  void _internal_set_nettime(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.TMPing)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int type_;
  ::PROTOBUF_NAMESPACE_ID::uint32 seq_;
  ::PROTOBUF_NAMESPACE_ID::uint64 pingtime_;
  ::PROTOBUF_NAMESPACE_ID::uint64 nettime_;
  friend struct ::TableStruct_ripple_2eproto;
};
// -------------------------------------------------------------------

class TMSquelch PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.TMSquelch) */ {
 public:
  inline TMSquelch() : TMSquelch(nullptr) {};
  virtual ~TMSquelch();

  TMSquelch(const TMSquelch& from);
  TMSquelch(TMSquelch&& from) noexcept
    : TMSquelch() {
    *this = ::std::move(from);
  }

  inline TMSquelch& operator=(const TMSquelch& from) {
    CopyFrom(from);
    return *this;
  }
  inline TMSquelch& operator=(TMSquelch&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TMSquelch& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TMSquelch* internal_default_instance() {
    return reinterpret_cast<const TMSquelch*>(
               &_TMSquelch_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(TMSquelch& a, TMSquelch& b) {
    a.Swap(&b);
  }
  inline void Swap(TMSquelch* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TMSquelch* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TMSquelch* New() const final {
    return CreateMaybeMessage<TMSquelch>(nullptr);
  }

  TMSquelch* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TMSquelch>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TMSquelch& from);
  void MergeFrom(const TMSquelch& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TMSquelch* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.TMSquelch";
  }
  protected:
  explicit TMSquelch(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ripple_2eproto);
    return ::descriptor_table_ripple_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValidatorPubKeyFieldNumber = 2,
    kSquelchFieldNumber = 1,
    kSquelchDurationFieldNumber = 3,
  };
  // required bytes validatorPubKey = 2;
  bool has_validatorpubkey() const;
  private:
  bool _internal_has_validatorpubkey() const;
  public:
  void clear_validatorpubkey();
  const std::string& validatorpubkey() const;
  void set_validatorpubkey(const std::string& value);
  void set_validatorpubkey(std::string&& value);
  void set_validatorpubkey(const char* value);
  void set_validatorpubkey(const void* value, size_t size);
  std::string* mutable_validatorpubkey();
  std::string* release_validatorpubkey();
  void set_allocated_validatorpubkey(std::string* validatorpubkey);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_validatorpubkey();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_validatorpubkey(
      std::string* validatorpubkey);
  private:
  const std::string& _internal_validatorpubkey() const;
  void _internal_set_validatorpubkey(const std::string& value);
  std::string* _internal_mutable_validatorpubkey();
  public:

  // required bool squelch = 1;
  bool has_squelch() const;
  private:
  bool _internal_has_squelch() const;
  public:
  void clear_squelch();
  bool squelch() const;
  void set_squelch(bool value);
  private:
  bool _internal_squelch() const;
  void _internal_set_squelch(bool value);
  public:

  // optional uint32 squelchDuration = 3;
  bool has_squelchduration() const;
  private:
  bool _internal_has_squelchduration() const;
  public:
  void clear_squelchduration();
  ::PROTOBUF_NAMESPACE_ID::uint32 squelchduration() const;
  void set_squelchduration(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_squelchduration() const;
  void _internal_set_squelchduration(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.TMSquelch)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr validatorpubkey_;
  bool squelch_;
  ::PROTOBUF_NAMESPACE_ID::uint32 squelchduration_;
  friend struct ::TableStruct_ripple_2eproto;
};
// -------------------------------------------------------------------

class TMProofPathRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.TMProofPathRequest) */ {
 public:
  inline TMProofPathRequest() : TMProofPathRequest(nullptr) {};
  virtual ~TMProofPathRequest();

  TMProofPathRequest(const TMProofPathRequest& from);
  TMProofPathRequest(TMProofPathRequest&& from) noexcept
    : TMProofPathRequest() {
    *this = ::std::move(from);
  }

  inline TMProofPathRequest& operator=(const TMProofPathRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline TMProofPathRequest& operator=(TMProofPathRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TMProofPathRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TMProofPathRequest* internal_default_instance() {
    return reinterpret_cast<const TMProofPathRequest*>(
               &_TMProofPathRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(TMProofPathRequest& a, TMProofPathRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(TMProofPathRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TMProofPathRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TMProofPathRequest* New() const final {
    return CreateMaybeMessage<TMProofPathRequest>(nullptr);
  }

  TMProofPathRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TMProofPathRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TMProofPathRequest& from);
  void MergeFrom(const TMProofPathRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TMProofPathRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.TMProofPathRequest";
  }
  protected:
  explicit TMProofPathRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ripple_2eproto);
    return ::descriptor_table_ripple_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kLedgerHashFieldNumber = 2,
    kTypeFieldNumber = 3,
  };
  // required bytes key = 1;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const std::string& key() const;
  void set_key(const std::string& value);
  void set_key(std::string&& value);
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  std::string* mutable_key();
  std::string* release_key();
  void set_allocated_key(std::string* key);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_key();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_key(
      std::string* key);
  private:
  const std::string& _internal_key() const;
  void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // required bytes ledgerHash = 2;
  bool has_ledgerhash() const;
  private:
  bool _internal_has_ledgerhash() const;
  public:
  void clear_ledgerhash();
  const std::string& ledgerhash() const;
  void set_ledgerhash(const std::string& value);
  void set_ledgerhash(std::string&& value);
  void set_ledgerhash(const char* value);
  void set_ledgerhash(const void* value, size_t size);
  std::string* mutable_ledgerhash();
  std::string* release_ledgerhash();
  void set_allocated_ledgerhash(std::string* ledgerhash);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_ledgerhash();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_ledgerhash(
      std::string* ledgerhash);
  private:
  const std::string& _internal_ledgerhash() const;
  void _internal_set_ledgerhash(const std::string& value);
  std::string* _internal_mutable_ledgerhash();
  public:

  // required .protocol.TMLedgerMapType type = 3;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::protocol::TMLedgerMapType type() const;
  void set_type(::protocol::TMLedgerMapType value);
  private:
  ::protocol::TMLedgerMapType _internal_type() const;
  void _internal_set_type(::protocol::TMLedgerMapType value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.TMProofPathRequest)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ledgerhash_;
  int type_;
  friend struct ::TableStruct_ripple_2eproto;
};
// -------------------------------------------------------------------

class TMProofPathResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.TMProofPathResponse) */ {
 public:
  inline TMProofPathResponse() : TMProofPathResponse(nullptr) {};
  virtual ~TMProofPathResponse();

  TMProofPathResponse(const TMProofPathResponse& from);
  TMProofPathResponse(TMProofPathResponse&& from) noexcept
    : TMProofPathResponse() {
    *this = ::std::move(from);
  }

  inline TMProofPathResponse& operator=(const TMProofPathResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline TMProofPathResponse& operator=(TMProofPathResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TMProofPathResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TMProofPathResponse* internal_default_instance() {
    return reinterpret_cast<const TMProofPathResponse*>(
               &_TMProofPathResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(TMProofPathResponse& a, TMProofPathResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(TMProofPathResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TMProofPathResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TMProofPathResponse* New() const final {
    return CreateMaybeMessage<TMProofPathResponse>(nullptr);
  }

  TMProofPathResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TMProofPathResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TMProofPathResponse& from);
  void MergeFrom(const TMProofPathResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TMProofPathResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.TMProofPathResponse";
  }
  protected:
  explicit TMProofPathResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ripple_2eproto);
    return ::descriptor_table_ripple_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 5,
    kKeyFieldNumber = 1,
    kLedgerHashFieldNumber = 2,
    kLedgerHeaderFieldNumber = 4,
    kTypeFieldNumber = 3,
    kErrorFieldNumber = 6,
  };
  // repeated bytes path = 5;
  int path_size() const;
  private:
  int _internal_path_size() const;
  public:
  void clear_path();
  const std::string& path(int index) const;
  std::string* mutable_path(int index);
  void set_path(int index, const std::string& value);
  void set_path(int index, std::string&& value);
  void set_path(int index, const char* value);
  void set_path(int index, const void* value, size_t size);
  std::string* add_path();
  void add_path(const std::string& value);
  void add_path(std::string&& value);
  void add_path(const char* value);
  void add_path(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& path() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_path();
  private:
  const std::string& _internal_path(int index) const;
  std::string* _internal_add_path();
  public:

  // required bytes key = 1;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const std::string& key() const;
  void set_key(const std::string& value);
  void set_key(std::string&& value);
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  std::string* mutable_key();
  std::string* release_key();
  void set_allocated_key(std::string* key);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_key();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_key(
      std::string* key);
  private:
  const std::string& _internal_key() const;
  void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // required bytes ledgerHash = 2;
  bool has_ledgerhash() const;
  private:
  bool _internal_has_ledgerhash() const;
  public:
  void clear_ledgerhash();
  const std::string& ledgerhash() const;
  void set_ledgerhash(const std::string& value);
  void set_ledgerhash(std::string&& value);
  void set_ledgerhash(const char* value);
  void set_ledgerhash(const void* value, size_t size);
  std::string* mutable_ledgerhash();
  std::string* release_ledgerhash();
  void set_allocated_ledgerhash(std::string* ledgerhash);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_ledgerhash();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_ledgerhash(
      std::string* ledgerhash);
  private:
  const std::string& _internal_ledgerhash() const;
  void _internal_set_ledgerhash(const std::string& value);
  std::string* _internal_mutable_ledgerhash();
  public:

  // optional bytes ledgerHeader = 4;
  bool has_ledgerheader() const;
  private:
  bool _internal_has_ledgerheader() const;
  public:
  void clear_ledgerheader();
  const std::string& ledgerheader() const;
  void set_ledgerheader(const std::string& value);
  void set_ledgerheader(std::string&& value);
  void set_ledgerheader(const char* value);
  void set_ledgerheader(const void* value, size_t size);
  std::string* mutable_ledgerheader();
  std::string* release_ledgerheader();
  void set_allocated_ledgerheader(std::string* ledgerheader);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_ledgerheader();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_ledgerheader(
      std::string* ledgerheader);
  private:
  const std::string& _internal_ledgerheader() const;
  void _internal_set_ledgerheader(const std::string& value);
  std::string* _internal_mutable_ledgerheader();
  public:

  // required .protocol.TMLedgerMapType type = 3;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::protocol::TMLedgerMapType type() const;
  void set_type(::protocol::TMLedgerMapType value);
  private:
  ::protocol::TMLedgerMapType _internal_type() const;
  void _internal_set_type(::protocol::TMLedgerMapType value);
  public:

  // optional .protocol.TMReplyError error = 6;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  ::protocol::TMReplyError error() const;
  void set_error(::protocol::TMReplyError value);
  private:
  ::protocol::TMReplyError _internal_error() const;
  void _internal_set_error(::protocol::TMReplyError value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.TMProofPathResponse)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> path_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ledgerhash_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ledgerheader_;
  int type_;
  int error_;
  friend struct ::TableStruct_ripple_2eproto;
};
// -------------------------------------------------------------------

class TMReplayDeltaRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.TMReplayDeltaRequest) */ {
 public:
  inline TMReplayDeltaRequest() : TMReplayDeltaRequest(nullptr) {};
  virtual ~TMReplayDeltaRequest();

  TMReplayDeltaRequest(const TMReplayDeltaRequest& from);
  TMReplayDeltaRequest(TMReplayDeltaRequest&& from) noexcept
    : TMReplayDeltaRequest() {
    *this = ::std::move(from);
  }

  inline TMReplayDeltaRequest& operator=(const TMReplayDeltaRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline TMReplayDeltaRequest& operator=(TMReplayDeltaRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TMReplayDeltaRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TMReplayDeltaRequest* internal_default_instance() {
    return reinterpret_cast<const TMReplayDeltaRequest*>(
               &_TMReplayDeltaRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(TMReplayDeltaRequest& a, TMReplayDeltaRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(TMReplayDeltaRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TMReplayDeltaRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TMReplayDeltaRequest* New() const final {
    return CreateMaybeMessage<TMReplayDeltaRequest>(nullptr);
  }

  TMReplayDeltaRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TMReplayDeltaRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TMReplayDeltaRequest& from);
  void MergeFrom(const TMReplayDeltaRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TMReplayDeltaRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.TMReplayDeltaRequest";
  }
  protected:
  explicit TMReplayDeltaRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ripple_2eproto);
    return ::descriptor_table_ripple_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLedgerHashFieldNumber = 1,
  };
  // required bytes ledgerHash = 1;
  bool has_ledgerhash() const;
  private:
  bool _internal_has_ledgerhash() const;
  public:
  void clear_ledgerhash();
  const std::string& ledgerhash() const;
  void set_ledgerhash(const std::string& value);
  void set_ledgerhash(std::string&& value);
  void set_ledgerhash(const char* value);
  void set_ledgerhash(const void* value, size_t size);
  std::string* mutable_ledgerhash();
  std::string* release_ledgerhash();
  void set_allocated_ledgerhash(std::string* ledgerhash);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_ledgerhash();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_ledgerhash(
      std::string* ledgerhash);
  private:
  const std::string& _internal_ledgerhash() const;
  void _internal_set_ledgerhash(const std::string& value);
  std::string* _internal_mutable_ledgerhash();
  public:

  // @@protoc_insertion_point(class_scope:protocol.TMReplayDeltaRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ledgerhash_;
  friend struct ::TableStruct_ripple_2eproto;
};
// -------------------------------------------------------------------

class TMReplayDeltaResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.TMReplayDeltaResponse) */ {
 public:
  inline TMReplayDeltaResponse() : TMReplayDeltaResponse(nullptr) {};
  virtual ~TMReplayDeltaResponse();

  TMReplayDeltaResponse(const TMReplayDeltaResponse& from);
  TMReplayDeltaResponse(TMReplayDeltaResponse&& from) noexcept
    : TMReplayDeltaResponse() {
    *this = ::std::move(from);
  }

  inline TMReplayDeltaResponse& operator=(const TMReplayDeltaResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline TMReplayDeltaResponse& operator=(TMReplayDeltaResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TMReplayDeltaResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TMReplayDeltaResponse* internal_default_instance() {
    return reinterpret_cast<const TMReplayDeltaResponse*>(
               &_TMReplayDeltaResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(TMReplayDeltaResponse& a, TMReplayDeltaResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(TMReplayDeltaResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TMReplayDeltaResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TMReplayDeltaResponse* New() const final {
    return CreateMaybeMessage<TMReplayDeltaResponse>(nullptr);
  }

  TMReplayDeltaResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TMReplayDeltaResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TMReplayDeltaResponse& from);
  void MergeFrom(const TMReplayDeltaResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TMReplayDeltaResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.TMReplayDeltaResponse";
  }
  protected:
  explicit TMReplayDeltaResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ripple_2eproto);
    return ::descriptor_table_ripple_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTransactionFieldNumber = 3,
    kLedgerHashFieldNumber = 1,
    kLedgerHeaderFieldNumber = 2,
    kErrorFieldNumber = 4,
  };
  // repeated bytes transaction = 3;
  int transaction_size() const;
  private:
  int _internal_transaction_size() const;
  public:
  void clear_transaction();
  const std::string& transaction(int index) const;
  std::string* mutable_transaction(int index);
  void set_transaction(int index, const std::string& value);
  void set_transaction(int index, std::string&& value);
  void set_transaction(int index, const char* value);
  void set_transaction(int index, const void* value, size_t size);
  std::string* add_transaction();
  void add_transaction(const std::string& value);
  void add_transaction(std::string&& value);
  void add_transaction(const char* value);
  void add_transaction(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& transaction() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_transaction();
  private:
  const std::string& _internal_transaction(int index) const;
  std::string* _internal_add_transaction();
  public:

  // required bytes ledgerHash = 1;
  bool has_ledgerhash() const;
  private:
  bool _internal_has_ledgerhash() const;
  public:
  void clear_ledgerhash();
  const std::string& ledgerhash() const;
  void set_ledgerhash(const std::string& value);
  void set_ledgerhash(std::string&& value);
  void set_ledgerhash(const char* value);
  void set_ledgerhash(const void* value, size_t size);
  std::string* mutable_ledgerhash();
  std::string* release_ledgerhash();
  void set_allocated_ledgerhash(std::string* ledgerhash);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_ledgerhash();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_ledgerhash(
      std::string* ledgerhash);
  private:
  const std::string& _internal_ledgerhash() const;
  void _internal_set_ledgerhash(const std::string& value);
  std::string* _internal_mutable_ledgerhash();
  public:

  // optional bytes ledgerHeader = 2;
  bool has_ledgerheader() const;
  private:
  bool _internal_has_ledgerheader() const;
  public:
  void clear_ledgerheader();
  const std::string& ledgerheader() const;
  void set_ledgerheader(const std::string& value);
  void set_ledgerheader(std::string&& value);
  void set_ledgerheader(const char* value);
  void set_ledgerheader(const void* value, size_t size);
  std::string* mutable_ledgerheader();
  std::string* release_ledgerheader();
  void set_allocated_ledgerheader(std::string* ledgerheader);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_ledgerheader();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_ledgerheader(
      std::string* ledgerheader);
  private:
  const std::string& _internal_ledgerheader() const;
  void _internal_set_ledgerheader(const std::string& value);
  std::string* _internal_mutable_ledgerheader();
  public:

  // optional .protocol.TMReplyError error = 4;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  ::protocol::TMReplyError error() const;
  void set_error(::protocol::TMReplyError value);
  private:
  ::protocol::TMReplyError _internal_error() const;
  void _internal_set_error(::protocol::TMReplyError value);
  public:

  // @@protoc_insertion_point(class_scope:protocol.TMReplayDeltaResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> transaction_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ledgerhash_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ledgerheader_;
  int error_;
  friend struct ::TableStruct_ripple_2eproto;
};
// -------------------------------------------------------------------

class TMHaveTransactions PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protocol.TMHaveTransactions) */ {
 public:
  inline TMHaveTransactions() : TMHaveTransactions(nullptr) {};
  virtual ~TMHaveTransactions();

  TMHaveTransactions(const TMHaveTransactions& from);
  TMHaveTransactions(TMHaveTransactions&& from) noexcept
    : TMHaveTransactions() {
    *this = ::std::move(from);
  }

  inline TMHaveTransactions& operator=(const TMHaveTransactions& from) {
    CopyFrom(from);
    return *this;
  }
  inline TMHaveTransactions& operator=(TMHaveTransactions&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TMHaveTransactions& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TMHaveTransactions* internal_default_instance() {
    return reinterpret_cast<const TMHaveTransactions*>(
               &_TMHaveTransactions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(TMHaveTransactions& a, TMHaveTransactions& b) {
    a.Swap(&b);
  }
  inline void Swap(TMHaveTransactions* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TMHaveTransactions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TMHaveTransactions* New() const final {
    return CreateMaybeMessage<TMHaveTransactions>(nullptr);
  }

  TMHaveTransactions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TMHaveTransactions>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TMHaveTransactions& from);
  void MergeFrom(const TMHaveTransactions& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TMHaveTransactions* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protocol.TMHaveTransactions";
  }
  protected:
  explicit TMHaveTransactions(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ripple_2eproto);
    return ::descriptor_table_ripple_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHashesFieldNumber = 1,
  };
  // repeated bytes hashes = 1;
  int hashes_size() const;
  private:
  int _internal_hashes_size() const;
  public:
  void clear_hashes();
  const std::string& hashes(int index) const;
  std::string* mutable_hashes(int index);
  void set_hashes(int index, const std::string& value);
  void set_hashes(int index, std::string&& value);
  void set_hashes(int index, const char* value);
  void set_hashes(int index, const void* value, size_t size);
  std::string* add_hashes();
  void add_hashes(const std::string& value);
  void add_hashes(std::string&& value);
  void add_hashes(const char* value);
  void add_hashes(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& hashes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_hashes();
  private:
  const std::string& _internal_hashes(int index) const;
  std::string* _internal_add_hashes();
  public:

  // @@protoc_insertion_point(class_scope:protocol.TMHaveTransactions)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> hashes_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ripple_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// TMManifest

// required bytes stobject = 1;
inline bool TMManifest::_internal_has_stobject() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TMManifest::has_stobject() const {
  return _internal_has_stobject();
}
inline void TMManifest::clear_stobject() {
  stobject_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TMManifest::stobject() const {
  // @@protoc_insertion_point(field_get:protocol.TMManifest.stobject)
  return _internal_stobject();
}
inline void TMManifest::set_stobject(const std::string& value) {
  _internal_set_stobject(value);
  // @@protoc_insertion_point(field_set:protocol.TMManifest.stobject)
}
inline std::string* TMManifest::mutable_stobject() {
  // @@protoc_insertion_point(field_mutable:protocol.TMManifest.stobject)
  return _internal_mutable_stobject();
}
inline const std::string& TMManifest::_internal_stobject() const {
  return stobject_.Get();
}
inline void TMManifest::_internal_set_stobject(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  stobject_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void TMManifest::set_stobject(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  stobject_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:protocol.TMManifest.stobject)
}
inline void TMManifest::set_stobject(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  stobject_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:protocol.TMManifest.stobject)
}
inline void TMManifest::set_stobject(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  stobject_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:protocol.TMManifest.stobject)
}
inline std::string* TMManifest::_internal_mutable_stobject() {
  _has_bits_[0] |= 0x00000001u;
  return stobject_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* TMManifest::release_stobject() {
  // @@protoc_insertion_point(field_release:protocol.TMManifest.stobject)
  if (!_internal_has_stobject()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return stobject_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void TMManifest::set_allocated_stobject(std::string* stobject) {
  if (stobject != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  stobject_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), stobject,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:protocol.TMManifest.stobject)
}
inline std::string* TMManifest::unsafe_arena_release_stobject() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protocol.TMManifest.stobject)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return stobject_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void TMManifest::unsafe_arena_set_allocated_stobject(
    std::string* stobject) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (stobject != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  stobject_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      stobject, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.TMManifest.stobject)
}

// -------------------------------------------------------------------

// TMManifests

// repeated .protocol.TMManifest list = 1;
inline int TMManifests::_internal_list_size() const {
  return list_.size();
}
inline int TMManifests::list_size() const {
  return _internal_list_size();
}
inline void TMManifests::clear_list() {
  list_.Clear();
}
inline ::protocol::TMManifest* TMManifests::mutable_list(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.TMManifests.list)
  return list_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::TMManifest >*
TMManifests::mutable_list() {
  // @@protoc_insertion_point(field_mutable_list:protocol.TMManifests.list)
  return &list_;
}
inline const ::protocol::TMManifest& TMManifests::_internal_list(int index) const {
  return list_.Get(index);
}
inline const ::protocol::TMManifest& TMManifests::list(int index) const {
  // @@protoc_insertion_point(field_get:protocol.TMManifests.list)
  return _internal_list(index);
}
inline ::protocol::TMManifest* TMManifests::_internal_add_list() {
  return list_.Add();
}
inline ::protocol::TMManifest* TMManifests::add_list() {
  // @@protoc_insertion_point(field_add:protocol.TMManifests.list)
  return _internal_add_list();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::TMManifest >&
TMManifests::list() const {
  // @@protoc_insertion_point(field_list:protocol.TMManifests.list)
  return list_;
}

// optional bool history = 2 [deprecated = true];
inline bool TMManifests::_internal_has_history() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TMManifests::has_history() const {
  return _internal_has_history();
}
inline void TMManifests::clear_history() {
  history_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool TMManifests::_internal_history() const {
  return history_;
}
inline bool TMManifests::history() const {
  // @@protoc_insertion_point(field_get:protocol.TMManifests.history)
  return _internal_history();
}
inline void TMManifests::_internal_set_history(bool value) {
  _has_bits_[0] |= 0x00000001u;
  history_ = value;
}
inline void TMManifests::set_history(bool value) {
  _internal_set_history(value);
  // @@protoc_insertion_point(field_set:protocol.TMManifests.history)
}

// -------------------------------------------------------------------

// TMClusterNode

// required string publicKey = 1;
inline bool TMClusterNode::_internal_has_publickey() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TMClusterNode::has_publickey() const {
  return _internal_has_publickey();
}
inline void TMClusterNode::clear_publickey() {
  publickey_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TMClusterNode::publickey() const {
  // @@protoc_insertion_point(field_get:protocol.TMClusterNode.publicKey)
  return _internal_publickey();
}
inline void TMClusterNode::set_publickey(const std::string& value) {
  _internal_set_publickey(value);
  // @@protoc_insertion_point(field_set:protocol.TMClusterNode.publicKey)
}
inline std::string* TMClusterNode::mutable_publickey() {
  // @@protoc_insertion_point(field_mutable:protocol.TMClusterNode.publicKey)
  return _internal_mutable_publickey();
}
inline const std::string& TMClusterNode::_internal_publickey() const {
  return publickey_.Get();
}
inline void TMClusterNode::_internal_set_publickey(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  publickey_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void TMClusterNode::set_publickey(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  publickey_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:protocol.TMClusterNode.publicKey)
}
inline void TMClusterNode::set_publickey(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  publickey_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:protocol.TMClusterNode.publicKey)
}
inline void TMClusterNode::set_publickey(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  publickey_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:protocol.TMClusterNode.publicKey)
}
inline std::string* TMClusterNode::_internal_mutable_publickey() {
  _has_bits_[0] |= 0x00000001u;
  return publickey_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* TMClusterNode::release_publickey() {
  // @@protoc_insertion_point(field_release:protocol.TMClusterNode.publicKey)
  if (!_internal_has_publickey()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return publickey_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void TMClusterNode::set_allocated_publickey(std::string* publickey) {
  if (publickey != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  publickey_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), publickey,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:protocol.TMClusterNode.publicKey)
}
inline std::string* TMClusterNode::unsafe_arena_release_publickey() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protocol.TMClusterNode.publicKey)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return publickey_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void TMClusterNode::unsafe_arena_set_allocated_publickey(
    std::string* publickey) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (publickey != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  publickey_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      publickey, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.TMClusterNode.publicKey)
}

// required uint32 reportTime = 2;
inline bool TMClusterNode::_internal_has_reporttime() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool TMClusterNode::has_reporttime() const {
  return _internal_has_reporttime();
}
inline void TMClusterNode::clear_reporttime() {
  reporttime_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TMClusterNode::_internal_reporttime() const {
  return reporttime_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TMClusterNode::reporttime() const {
  // @@protoc_insertion_point(field_get:protocol.TMClusterNode.reportTime)
  return _internal_reporttime();
}
inline void TMClusterNode::_internal_set_reporttime(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  reporttime_ = value;
}
inline void TMClusterNode::set_reporttime(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_reporttime(value);
  // @@protoc_insertion_point(field_set:protocol.TMClusterNode.reportTime)
}

// required uint32 nodeLoad = 3;
inline bool TMClusterNode::_internal_has_nodeload() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool TMClusterNode::has_nodeload() const {
  return _internal_has_nodeload();
}
inline void TMClusterNode::clear_nodeload() {
  nodeload_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TMClusterNode::_internal_nodeload() const {
  return nodeload_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TMClusterNode::nodeload() const {
  // @@protoc_insertion_point(field_get:protocol.TMClusterNode.nodeLoad)
  return _internal_nodeload();
}
inline void TMClusterNode::_internal_set_nodeload(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  nodeload_ = value;
}
inline void TMClusterNode::set_nodeload(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_nodeload(value);
  // @@protoc_insertion_point(field_set:protocol.TMClusterNode.nodeLoad)
}

// optional string nodeName = 4;
inline bool TMClusterNode::_internal_has_nodename() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TMClusterNode::has_nodename() const {
  return _internal_has_nodename();
}
inline void TMClusterNode::clear_nodename() {
  nodename_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& TMClusterNode::nodename() const {
  // @@protoc_insertion_point(field_get:protocol.TMClusterNode.nodeName)
  return _internal_nodename();
}
inline void TMClusterNode::set_nodename(const std::string& value) {
  _internal_set_nodename(value);
  // @@protoc_insertion_point(field_set:protocol.TMClusterNode.nodeName)
}
inline std::string* TMClusterNode::mutable_nodename() {
  // @@protoc_insertion_point(field_mutable:protocol.TMClusterNode.nodeName)
  return _internal_mutable_nodename();
}
inline const std::string& TMClusterNode::_internal_nodename() const {
  return nodename_.Get();
}
inline void TMClusterNode::_internal_set_nodename(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  nodename_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void TMClusterNode::set_nodename(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  nodename_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:protocol.TMClusterNode.nodeName)
}
inline void TMClusterNode::set_nodename(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  nodename_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:protocol.TMClusterNode.nodeName)
}
inline void TMClusterNode::set_nodename(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  nodename_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:protocol.TMClusterNode.nodeName)
}
inline std::string* TMClusterNode::_internal_mutable_nodename() {
  _has_bits_[0] |= 0x00000002u;
  return nodename_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* TMClusterNode::release_nodename() {
  // @@protoc_insertion_point(field_release:protocol.TMClusterNode.nodeName)
  if (!_internal_has_nodename()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return nodename_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void TMClusterNode::set_allocated_nodename(std::string* nodename) {
  if (nodename != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  nodename_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), nodename,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:protocol.TMClusterNode.nodeName)
}
inline std::string* TMClusterNode::unsafe_arena_release_nodename() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protocol.TMClusterNode.nodeName)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000002u;
  return nodename_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void TMClusterNode::unsafe_arena_set_allocated_nodename(
    std::string* nodename) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (nodename != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  nodename_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      nodename, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.TMClusterNode.nodeName)
}

// optional string address = 5;
inline bool TMClusterNode::_internal_has_address() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TMClusterNode::has_address() const {
  return _internal_has_address();
}
inline void TMClusterNode::clear_address() {
  address_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& TMClusterNode::address() const {
  // @@protoc_insertion_point(field_get:protocol.TMClusterNode.address)
  return _internal_address();
}
inline void TMClusterNode::set_address(const std::string& value) {
  _internal_set_address(value);
  // @@protoc_insertion_point(field_set:protocol.TMClusterNode.address)
}
inline std::string* TMClusterNode::mutable_address() {
  // @@protoc_insertion_point(field_mutable:protocol.TMClusterNode.address)
  return _internal_mutable_address();
}
inline const std::string& TMClusterNode::_internal_address() const {
  return address_.Get();
}
inline void TMClusterNode::_internal_set_address(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void TMClusterNode::set_address(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  address_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:protocol.TMClusterNode.address)
}
inline void TMClusterNode::set_address(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:protocol.TMClusterNode.address)
}
inline void TMClusterNode::set_address(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000004u;
  address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:protocol.TMClusterNode.address)
}
inline std::string* TMClusterNode::_internal_mutable_address() {
  _has_bits_[0] |= 0x00000004u;
  return address_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* TMClusterNode::release_address() {
  // @@protoc_insertion_point(field_release:protocol.TMClusterNode.address)
  if (!_internal_has_address()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return address_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void TMClusterNode::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), address,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:protocol.TMClusterNode.address)
}
inline std::string* TMClusterNode::unsafe_arena_release_address() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protocol.TMClusterNode.address)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000004u;
  return address_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void TMClusterNode::unsafe_arena_set_allocated_address(
    std::string* address) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (address != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  address_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      address, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.TMClusterNode.address)
}

// -------------------------------------------------------------------

// TMLoadSource

// required string name = 1;
inline bool TMLoadSource::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TMLoadSource::has_name() const {
  return _internal_has_name();
}
inline void TMLoadSource::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TMLoadSource::name() const {
  // @@protoc_insertion_point(field_get:protocol.TMLoadSource.name)
  return _internal_name();
}
inline void TMLoadSource::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:protocol.TMLoadSource.name)
}
inline std::string* TMLoadSource::mutable_name() {
  // @@protoc_insertion_point(field_mutable:protocol.TMLoadSource.name)
  return _internal_mutable_name();
}
inline const std::string& TMLoadSource::_internal_name() const {
  return name_.Get();
}
inline void TMLoadSource::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void TMLoadSource::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:protocol.TMLoadSource.name)
}
inline void TMLoadSource::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:protocol.TMLoadSource.name)
}
inline void TMLoadSource::set_name(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:protocol.TMLoadSource.name)
}
inline std::string* TMLoadSource::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* TMLoadSource::release_name() {
  // @@protoc_insertion_point(field_release:protocol.TMLoadSource.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void TMLoadSource::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:protocol.TMLoadSource.name)
}
inline std::string* TMLoadSource::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protocol.TMLoadSource.name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void TMLoadSource::unsafe_arena_set_allocated_name(
    std::string* name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.TMLoadSource.name)
}

// required uint32 cost = 2;
inline bool TMLoadSource::_internal_has_cost() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TMLoadSource::has_cost() const {
  return _internal_has_cost();
}
inline void TMLoadSource::clear_cost() {
  cost_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TMLoadSource::_internal_cost() const {
  return cost_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TMLoadSource::cost() const {
  // @@protoc_insertion_point(field_get:protocol.TMLoadSource.cost)
  return _internal_cost();
}
inline void TMLoadSource::_internal_set_cost(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  cost_ = value;
}
inline void TMLoadSource::set_cost(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_cost(value);
  // @@protoc_insertion_point(field_set:protocol.TMLoadSource.cost)
}

// optional uint32 count = 3;
inline bool TMLoadSource::_internal_has_count() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TMLoadSource::has_count() const {
  return _internal_has_count();
}
inline void TMLoadSource::clear_count() {
  count_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TMLoadSource::_internal_count() const {
  return count_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TMLoadSource::count() const {
  // @@protoc_insertion_point(field_get:protocol.TMLoadSource.count)
  return _internal_count();
}
inline void TMLoadSource::_internal_set_count(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  count_ = value;
}
inline void TMLoadSource::set_count(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:protocol.TMLoadSource.count)
}

// -------------------------------------------------------------------

// TMCluster

// repeated .protocol.TMClusterNode clusterNodes = 1;
inline int TMCluster::_internal_clusternodes_size() const {
  return clusternodes_.size();
}
inline int TMCluster::clusternodes_size() const {
  return _internal_clusternodes_size();
}
inline void TMCluster::clear_clusternodes() {
  clusternodes_.Clear();
}
inline ::protocol::TMClusterNode* TMCluster::mutable_clusternodes(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.TMCluster.clusterNodes)
  return clusternodes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::TMClusterNode >*
TMCluster::mutable_clusternodes() {
  // @@protoc_insertion_point(field_mutable_list:protocol.TMCluster.clusterNodes)
  return &clusternodes_;
}
inline const ::protocol::TMClusterNode& TMCluster::_internal_clusternodes(int index) const {
  return clusternodes_.Get(index);
}
inline const ::protocol::TMClusterNode& TMCluster::clusternodes(int index) const {
  // @@protoc_insertion_point(field_get:protocol.TMCluster.clusterNodes)
  return _internal_clusternodes(index);
}
inline ::protocol::TMClusterNode* TMCluster::_internal_add_clusternodes() {
  return clusternodes_.Add();
}
inline ::protocol::TMClusterNode* TMCluster::add_clusternodes() {
  // @@protoc_insertion_point(field_add:protocol.TMCluster.clusterNodes)
  return _internal_add_clusternodes();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::TMClusterNode >&
TMCluster::clusternodes() const {
  // @@protoc_insertion_point(field_list:protocol.TMCluster.clusterNodes)
  return clusternodes_;
}

// repeated .protocol.TMLoadSource loadSources = 2;
inline int TMCluster::_internal_loadsources_size() const {
  return loadsources_.size();
}
inline int TMCluster::loadsources_size() const {
  return _internal_loadsources_size();
}
inline void TMCluster::clear_loadsources() {
  loadsources_.Clear();
}
inline ::protocol::TMLoadSource* TMCluster::mutable_loadsources(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.TMCluster.loadSources)
  return loadsources_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::TMLoadSource >*
TMCluster::mutable_loadsources() {
  // @@protoc_insertion_point(field_mutable_list:protocol.TMCluster.loadSources)
  return &loadsources_;
}
inline const ::protocol::TMLoadSource& TMCluster::_internal_loadsources(int index) const {
  return loadsources_.Get(index);
}
inline const ::protocol::TMLoadSource& TMCluster::loadsources(int index) const {
  // @@protoc_insertion_point(field_get:protocol.TMCluster.loadSources)
  return _internal_loadsources(index);
}
inline ::protocol::TMLoadSource* TMCluster::_internal_add_loadsources() {
  return loadsources_.Add();
}
inline ::protocol::TMLoadSource* TMCluster::add_loadsources() {
  // @@protoc_insertion_point(field_add:protocol.TMCluster.loadSources)
  return _internal_add_loadsources();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::TMLoadSource >&
TMCluster::loadsources() const {
  // @@protoc_insertion_point(field_list:protocol.TMCluster.loadSources)
  return loadsources_;
}

// -------------------------------------------------------------------

// TMLink

// required bytes nodePubKey = 1 [deprecated = true];
inline bool TMLink::_internal_has_nodepubkey() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TMLink::has_nodepubkey() const {
  return _internal_has_nodepubkey();
}
inline void TMLink::clear_nodepubkey() {
  nodepubkey_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TMLink::nodepubkey() const {
  // @@protoc_insertion_point(field_get:protocol.TMLink.nodePubKey)
  return _internal_nodepubkey();
}
inline void TMLink::set_nodepubkey(const std::string& value) {
  _internal_set_nodepubkey(value);
  // @@protoc_insertion_point(field_set:protocol.TMLink.nodePubKey)
}
inline std::string* TMLink::mutable_nodepubkey() {
  // @@protoc_insertion_point(field_mutable:protocol.TMLink.nodePubKey)
  return _internal_mutable_nodepubkey();
}
inline const std::string& TMLink::_internal_nodepubkey() const {
  return nodepubkey_.Get();
}
inline void TMLink::_internal_set_nodepubkey(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  nodepubkey_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void TMLink::set_nodepubkey(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  nodepubkey_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:protocol.TMLink.nodePubKey)
}
inline void TMLink::set_nodepubkey(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  nodepubkey_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:protocol.TMLink.nodePubKey)
}
inline void TMLink::set_nodepubkey(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  nodepubkey_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:protocol.TMLink.nodePubKey)
}
inline std::string* TMLink::_internal_mutable_nodepubkey() {
  _has_bits_[0] |= 0x00000001u;
  return nodepubkey_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* TMLink::release_nodepubkey() {
  // @@protoc_insertion_point(field_release:protocol.TMLink.nodePubKey)
  if (!_internal_has_nodepubkey()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return nodepubkey_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void TMLink::set_allocated_nodepubkey(std::string* nodepubkey) {
  if (nodepubkey != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  nodepubkey_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), nodepubkey,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:protocol.TMLink.nodePubKey)
}
inline std::string* TMLink::unsafe_arena_release_nodepubkey() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protocol.TMLink.nodePubKey)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return nodepubkey_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void TMLink::unsafe_arena_set_allocated_nodepubkey(
    std::string* nodepubkey) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (nodepubkey != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  nodepubkey_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      nodepubkey, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.TMLink.nodePubKey)
}

// -------------------------------------------------------------------

// TMGetPeerShardInfo

// required uint32 hops = 1 [deprecated = true];
inline bool TMGetPeerShardInfo::_internal_has_hops() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TMGetPeerShardInfo::has_hops() const {
  return _internal_has_hops();
}
inline void TMGetPeerShardInfo::clear_hops() {
  hops_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TMGetPeerShardInfo::_internal_hops() const {
  return hops_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TMGetPeerShardInfo::hops() const {
  // @@protoc_insertion_point(field_get:protocol.TMGetPeerShardInfo.hops)
  return _internal_hops();
}
inline void TMGetPeerShardInfo::_internal_set_hops(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  hops_ = value;
}
inline void TMGetPeerShardInfo::set_hops(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_hops(value);
  // @@protoc_insertion_point(field_set:protocol.TMGetPeerShardInfo.hops)
}

// optional bool lastLink = 2 [deprecated = true];
inline bool TMGetPeerShardInfo::_internal_has_lastlink() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TMGetPeerShardInfo::has_lastlink() const {
  return _internal_has_lastlink();
}
inline void TMGetPeerShardInfo::clear_lastlink() {
  lastlink_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool TMGetPeerShardInfo::_internal_lastlink() const {
  return lastlink_;
}
inline bool TMGetPeerShardInfo::lastlink() const {
  // @@protoc_insertion_point(field_get:protocol.TMGetPeerShardInfo.lastLink)
  return _internal_lastlink();
}
inline void TMGetPeerShardInfo::_internal_set_lastlink(bool value) {
  _has_bits_[0] |= 0x00000002u;
  lastlink_ = value;
}
inline void TMGetPeerShardInfo::set_lastlink(bool value) {
  _internal_set_lastlink(value);
  // @@protoc_insertion_point(field_set:protocol.TMGetPeerShardInfo.lastLink)
}

// repeated .protocol.TMLink peerChain = 3 [deprecated = true];
inline int TMGetPeerShardInfo::_internal_peerchain_size() const {
  return peerchain_.size();
}
inline int TMGetPeerShardInfo::peerchain_size() const {
  return _internal_peerchain_size();
}
inline void TMGetPeerShardInfo::clear_peerchain() {
  peerchain_.Clear();
}
inline ::protocol::TMLink* TMGetPeerShardInfo::mutable_peerchain(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.TMGetPeerShardInfo.peerChain)
  return peerchain_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::TMLink >*
TMGetPeerShardInfo::mutable_peerchain() {
  // @@protoc_insertion_point(field_mutable_list:protocol.TMGetPeerShardInfo.peerChain)
  return &peerchain_;
}
inline const ::protocol::TMLink& TMGetPeerShardInfo::_internal_peerchain(int index) const {
  return peerchain_.Get(index);
}
inline const ::protocol::TMLink& TMGetPeerShardInfo::peerchain(int index) const {
  // @@protoc_insertion_point(field_get:protocol.TMGetPeerShardInfo.peerChain)
  return _internal_peerchain(index);
}
inline ::protocol::TMLink* TMGetPeerShardInfo::_internal_add_peerchain() {
  return peerchain_.Add();
}
inline ::protocol::TMLink* TMGetPeerShardInfo::add_peerchain() {
  // @@protoc_insertion_point(field_add:protocol.TMGetPeerShardInfo.peerChain)
  return _internal_add_peerchain();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::TMLink >&
TMGetPeerShardInfo::peerchain() const {
  // @@protoc_insertion_point(field_list:protocol.TMGetPeerShardInfo.peerChain)
  return peerchain_;
}

// -------------------------------------------------------------------

// TMPeerShardInfo

// required string shardIndexes = 1 [deprecated = true];
inline bool TMPeerShardInfo::_internal_has_shardindexes() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TMPeerShardInfo::has_shardindexes() const {
  return _internal_has_shardindexes();
}
inline void TMPeerShardInfo::clear_shardindexes() {
  shardindexes_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TMPeerShardInfo::shardindexes() const {
  // @@protoc_insertion_point(field_get:protocol.TMPeerShardInfo.shardIndexes)
  return _internal_shardindexes();
}
inline void TMPeerShardInfo::set_shardindexes(const std::string& value) {
  _internal_set_shardindexes(value);
  // @@protoc_insertion_point(field_set:protocol.TMPeerShardInfo.shardIndexes)
}
inline std::string* TMPeerShardInfo::mutable_shardindexes() {
  // @@protoc_insertion_point(field_mutable:protocol.TMPeerShardInfo.shardIndexes)
  return _internal_mutable_shardindexes();
}
inline const std::string& TMPeerShardInfo::_internal_shardindexes() const {
  return shardindexes_.Get();
}
inline void TMPeerShardInfo::_internal_set_shardindexes(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  shardindexes_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void TMPeerShardInfo::set_shardindexes(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  shardindexes_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:protocol.TMPeerShardInfo.shardIndexes)
}
inline void TMPeerShardInfo::set_shardindexes(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  shardindexes_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:protocol.TMPeerShardInfo.shardIndexes)
}
inline void TMPeerShardInfo::set_shardindexes(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  shardindexes_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:protocol.TMPeerShardInfo.shardIndexes)
}
inline std::string* TMPeerShardInfo::_internal_mutable_shardindexes() {
  _has_bits_[0] |= 0x00000001u;
  return shardindexes_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* TMPeerShardInfo::release_shardindexes() {
  // @@protoc_insertion_point(field_release:protocol.TMPeerShardInfo.shardIndexes)
  if (!_internal_has_shardindexes()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return shardindexes_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void TMPeerShardInfo::set_allocated_shardindexes(std::string* shardindexes) {
  if (shardindexes != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  shardindexes_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), shardindexes,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:protocol.TMPeerShardInfo.shardIndexes)
}
inline std::string* TMPeerShardInfo::unsafe_arena_release_shardindexes() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protocol.TMPeerShardInfo.shardIndexes)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return shardindexes_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void TMPeerShardInfo::unsafe_arena_set_allocated_shardindexes(
    std::string* shardindexes) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (shardindexes != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  shardindexes_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      shardindexes, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.TMPeerShardInfo.shardIndexes)
}

// optional bytes nodePubKey = 2 [deprecated = true];
inline bool TMPeerShardInfo::_internal_has_nodepubkey() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TMPeerShardInfo::has_nodepubkey() const {
  return _internal_has_nodepubkey();
}
inline void TMPeerShardInfo::clear_nodepubkey() {
  nodepubkey_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& TMPeerShardInfo::nodepubkey() const {
  // @@protoc_insertion_point(field_get:protocol.TMPeerShardInfo.nodePubKey)
  return _internal_nodepubkey();
}
inline void TMPeerShardInfo::set_nodepubkey(const std::string& value) {
  _internal_set_nodepubkey(value);
  // @@protoc_insertion_point(field_set:protocol.TMPeerShardInfo.nodePubKey)
}
inline std::string* TMPeerShardInfo::mutable_nodepubkey() {
  // @@protoc_insertion_point(field_mutable:protocol.TMPeerShardInfo.nodePubKey)
  return _internal_mutable_nodepubkey();
}
inline const std::string& TMPeerShardInfo::_internal_nodepubkey() const {
  return nodepubkey_.Get();
}
inline void TMPeerShardInfo::_internal_set_nodepubkey(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  nodepubkey_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void TMPeerShardInfo::set_nodepubkey(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  nodepubkey_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:protocol.TMPeerShardInfo.nodePubKey)
}
inline void TMPeerShardInfo::set_nodepubkey(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  nodepubkey_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:protocol.TMPeerShardInfo.nodePubKey)
}
inline void TMPeerShardInfo::set_nodepubkey(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  nodepubkey_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:protocol.TMPeerShardInfo.nodePubKey)
}
inline std::string* TMPeerShardInfo::_internal_mutable_nodepubkey() {
  _has_bits_[0] |= 0x00000002u;
  return nodepubkey_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* TMPeerShardInfo::release_nodepubkey() {
  // @@protoc_insertion_point(field_release:protocol.TMPeerShardInfo.nodePubKey)
  if (!_internal_has_nodepubkey()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return nodepubkey_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void TMPeerShardInfo::set_allocated_nodepubkey(std::string* nodepubkey) {
  if (nodepubkey != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  nodepubkey_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), nodepubkey,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:protocol.TMPeerShardInfo.nodePubKey)
}
inline std::string* TMPeerShardInfo::unsafe_arena_release_nodepubkey() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protocol.TMPeerShardInfo.nodePubKey)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000002u;
  return nodepubkey_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void TMPeerShardInfo::unsafe_arena_set_allocated_nodepubkey(
    std::string* nodepubkey) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (nodepubkey != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  nodepubkey_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      nodepubkey, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.TMPeerShardInfo.nodePubKey)
}

// optional string endpoint = 3 [deprecated = true];
inline bool TMPeerShardInfo::_internal_has_endpoint() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TMPeerShardInfo::has_endpoint() const {
  return _internal_has_endpoint();
}
inline void TMPeerShardInfo::clear_endpoint() {
  endpoint_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& TMPeerShardInfo::endpoint() const {
  // @@protoc_insertion_point(field_get:protocol.TMPeerShardInfo.endpoint)
  return _internal_endpoint();
}
inline void TMPeerShardInfo::set_endpoint(const std::string& value) {
  _internal_set_endpoint(value);
  // @@protoc_insertion_point(field_set:protocol.TMPeerShardInfo.endpoint)
}
inline std::string* TMPeerShardInfo::mutable_endpoint() {
  // @@protoc_insertion_point(field_mutable:protocol.TMPeerShardInfo.endpoint)
  return _internal_mutable_endpoint();
}
inline const std::string& TMPeerShardInfo::_internal_endpoint() const {
  return endpoint_.Get();
}
inline void TMPeerShardInfo::_internal_set_endpoint(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  endpoint_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void TMPeerShardInfo::set_endpoint(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  endpoint_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:protocol.TMPeerShardInfo.endpoint)
}
inline void TMPeerShardInfo::set_endpoint(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  endpoint_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:protocol.TMPeerShardInfo.endpoint)
}
inline void TMPeerShardInfo::set_endpoint(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000004u;
  endpoint_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:protocol.TMPeerShardInfo.endpoint)
}
inline std::string* TMPeerShardInfo::_internal_mutable_endpoint() {
  _has_bits_[0] |= 0x00000004u;
  return endpoint_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* TMPeerShardInfo::release_endpoint() {
  // @@protoc_insertion_point(field_release:protocol.TMPeerShardInfo.endpoint)
  if (!_internal_has_endpoint()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return endpoint_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void TMPeerShardInfo::set_allocated_endpoint(std::string* endpoint) {
  if (endpoint != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  endpoint_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), endpoint,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:protocol.TMPeerShardInfo.endpoint)
}
inline std::string* TMPeerShardInfo::unsafe_arena_release_endpoint() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protocol.TMPeerShardInfo.endpoint)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000004u;
  return endpoint_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void TMPeerShardInfo::unsafe_arena_set_allocated_endpoint(
    std::string* endpoint) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (endpoint != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  endpoint_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      endpoint, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.TMPeerShardInfo.endpoint)
}

// optional bool lastLink = 4 [deprecated = true];
inline bool TMPeerShardInfo::_internal_has_lastlink() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool TMPeerShardInfo::has_lastlink() const {
  return _internal_has_lastlink();
}
inline void TMPeerShardInfo::clear_lastlink() {
  lastlink_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool TMPeerShardInfo::_internal_lastlink() const {
  return lastlink_;
}
inline bool TMPeerShardInfo::lastlink() const {
  // @@protoc_insertion_point(field_get:protocol.TMPeerShardInfo.lastLink)
  return _internal_lastlink();
}
inline void TMPeerShardInfo::_internal_set_lastlink(bool value) {
  _has_bits_[0] |= 0x00000008u;
  lastlink_ = value;
}
inline void TMPeerShardInfo::set_lastlink(bool value) {
  _internal_set_lastlink(value);
  // @@protoc_insertion_point(field_set:protocol.TMPeerShardInfo.lastLink)
}

// repeated .protocol.TMLink peerChain = 5 [deprecated = true];
inline int TMPeerShardInfo::_internal_peerchain_size() const {
  return peerchain_.size();
}
inline int TMPeerShardInfo::peerchain_size() const {
  return _internal_peerchain_size();
}
inline void TMPeerShardInfo::clear_peerchain() {
  peerchain_.Clear();
}
inline ::protocol::TMLink* TMPeerShardInfo::mutable_peerchain(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.TMPeerShardInfo.peerChain)
  return peerchain_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::TMLink >*
TMPeerShardInfo::mutable_peerchain() {
  // @@protoc_insertion_point(field_mutable_list:protocol.TMPeerShardInfo.peerChain)
  return &peerchain_;
}
inline const ::protocol::TMLink& TMPeerShardInfo::_internal_peerchain(int index) const {
  return peerchain_.Get(index);
}
inline const ::protocol::TMLink& TMPeerShardInfo::peerchain(int index) const {
  // @@protoc_insertion_point(field_get:protocol.TMPeerShardInfo.peerChain)
  return _internal_peerchain(index);
}
inline ::protocol::TMLink* TMPeerShardInfo::_internal_add_peerchain() {
  return peerchain_.Add();
}
inline ::protocol::TMLink* TMPeerShardInfo::add_peerchain() {
  // @@protoc_insertion_point(field_add:protocol.TMPeerShardInfo.peerChain)
  return _internal_add_peerchain();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::TMLink >&
TMPeerShardInfo::peerchain() const {
  // @@protoc_insertion_point(field_list:protocol.TMPeerShardInfo.peerChain)
  return peerchain_;
}

// -------------------------------------------------------------------

// TMPublicKey

// required bytes publicKey = 1;
inline bool TMPublicKey::_internal_has_publickey() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TMPublicKey::has_publickey() const {
  return _internal_has_publickey();
}
inline void TMPublicKey::clear_publickey() {
  publickey_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TMPublicKey::publickey() const {
  // @@protoc_insertion_point(field_get:protocol.TMPublicKey.publicKey)
  return _internal_publickey();
}
inline void TMPublicKey::set_publickey(const std::string& value) {
  _internal_set_publickey(value);
  // @@protoc_insertion_point(field_set:protocol.TMPublicKey.publicKey)
}
inline std::string* TMPublicKey::mutable_publickey() {
  // @@protoc_insertion_point(field_mutable:protocol.TMPublicKey.publicKey)
  return _internal_mutable_publickey();
}
inline const std::string& TMPublicKey::_internal_publickey() const {
  return publickey_.Get();
}
inline void TMPublicKey::_internal_set_publickey(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  publickey_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void TMPublicKey::set_publickey(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  publickey_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:protocol.TMPublicKey.publicKey)
}
inline void TMPublicKey::set_publickey(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  publickey_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:protocol.TMPublicKey.publicKey)
}
inline void TMPublicKey::set_publickey(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  publickey_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:protocol.TMPublicKey.publicKey)
}
inline std::string* TMPublicKey::_internal_mutable_publickey() {
  _has_bits_[0] |= 0x00000001u;
  return publickey_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* TMPublicKey::release_publickey() {
  // @@protoc_insertion_point(field_release:protocol.TMPublicKey.publicKey)
  if (!_internal_has_publickey()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return publickey_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void TMPublicKey::set_allocated_publickey(std::string* publickey) {
  if (publickey != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  publickey_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), publickey,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:protocol.TMPublicKey.publicKey)
}
inline std::string* TMPublicKey::unsafe_arena_release_publickey() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protocol.TMPublicKey.publicKey)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return publickey_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void TMPublicKey::unsafe_arena_set_allocated_publickey(
    std::string* publickey) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (publickey != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  publickey_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      publickey, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.TMPublicKey.publicKey)
}

// -------------------------------------------------------------------

// TMGetPeerShardInfoV2

// repeated .protocol.TMPublicKey peerChain = 1;
inline int TMGetPeerShardInfoV2::_internal_peerchain_size() const {
  return peerchain_.size();
}
inline int TMGetPeerShardInfoV2::peerchain_size() const {
  return _internal_peerchain_size();
}
inline void TMGetPeerShardInfoV2::clear_peerchain() {
  peerchain_.Clear();
}
inline ::protocol::TMPublicKey* TMGetPeerShardInfoV2::mutable_peerchain(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.TMGetPeerShardInfoV2.peerChain)
  return peerchain_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::TMPublicKey >*
TMGetPeerShardInfoV2::mutable_peerchain() {
  // @@protoc_insertion_point(field_mutable_list:protocol.TMGetPeerShardInfoV2.peerChain)
  return &peerchain_;
}
inline const ::protocol::TMPublicKey& TMGetPeerShardInfoV2::_internal_peerchain(int index) const {
  return peerchain_.Get(index);
}
inline const ::protocol::TMPublicKey& TMGetPeerShardInfoV2::peerchain(int index) const {
  // @@protoc_insertion_point(field_get:protocol.TMGetPeerShardInfoV2.peerChain)
  return _internal_peerchain(index);
}
inline ::protocol::TMPublicKey* TMGetPeerShardInfoV2::_internal_add_peerchain() {
  return peerchain_.Add();
}
inline ::protocol::TMPublicKey* TMGetPeerShardInfoV2::add_peerchain() {
  // @@protoc_insertion_point(field_add:protocol.TMGetPeerShardInfoV2.peerChain)
  return _internal_add_peerchain();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::TMPublicKey >&
TMGetPeerShardInfoV2::peerchain() const {
  // @@protoc_insertion_point(field_list:protocol.TMGetPeerShardInfoV2.peerChain)
  return peerchain_;
}

// required uint32 relays = 2;
inline bool TMGetPeerShardInfoV2::_internal_has_relays() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TMGetPeerShardInfoV2::has_relays() const {
  return _internal_has_relays();
}
inline void TMGetPeerShardInfoV2::clear_relays() {
  relays_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TMGetPeerShardInfoV2::_internal_relays() const {
  return relays_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TMGetPeerShardInfoV2::relays() const {
  // @@protoc_insertion_point(field_get:protocol.TMGetPeerShardInfoV2.relays)
  return _internal_relays();
}
inline void TMGetPeerShardInfoV2::_internal_set_relays(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  relays_ = value;
}
inline void TMGetPeerShardInfoV2::set_relays(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_relays(value);
  // @@protoc_insertion_point(field_set:protocol.TMGetPeerShardInfoV2.relays)
}

// -------------------------------------------------------------------

// TMPeerShardInfoV2_TMIncomplete

// required uint32 shardIndex = 1;
inline bool TMPeerShardInfoV2_TMIncomplete::_internal_has_shardindex() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TMPeerShardInfoV2_TMIncomplete::has_shardindex() const {
  return _internal_has_shardindex();
}
inline void TMPeerShardInfoV2_TMIncomplete::clear_shardindex() {
  shardindex_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TMPeerShardInfoV2_TMIncomplete::_internal_shardindex() const {
  return shardindex_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TMPeerShardInfoV2_TMIncomplete::shardindex() const {
  // @@protoc_insertion_point(field_get:protocol.TMPeerShardInfoV2.TMIncomplete.shardIndex)
  return _internal_shardindex();
}
inline void TMPeerShardInfoV2_TMIncomplete::_internal_set_shardindex(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  shardindex_ = value;
}
inline void TMPeerShardInfoV2_TMIncomplete::set_shardindex(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_shardindex(value);
  // @@protoc_insertion_point(field_set:protocol.TMPeerShardInfoV2.TMIncomplete.shardIndex)
}

// required uint32 state = 2;
inline bool TMPeerShardInfoV2_TMIncomplete::_internal_has_state() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TMPeerShardInfoV2_TMIncomplete::has_state() const {
  return _internal_has_state();
}
inline void TMPeerShardInfoV2_TMIncomplete::clear_state() {
  state_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TMPeerShardInfoV2_TMIncomplete::_internal_state() const {
  return state_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TMPeerShardInfoV2_TMIncomplete::state() const {
  // @@protoc_insertion_point(field_get:protocol.TMPeerShardInfoV2.TMIncomplete.state)
  return _internal_state();
}
inline void TMPeerShardInfoV2_TMIncomplete::_internal_set_state(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  state_ = value;
}
inline void TMPeerShardInfoV2_TMIncomplete::set_state(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:protocol.TMPeerShardInfoV2.TMIncomplete.state)
}

// optional uint32 progress = 3;
inline bool TMPeerShardInfoV2_TMIncomplete::_internal_has_progress() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TMPeerShardInfoV2_TMIncomplete::has_progress() const {
  return _internal_has_progress();
}
inline void TMPeerShardInfoV2_TMIncomplete::clear_progress() {
  progress_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TMPeerShardInfoV2_TMIncomplete::_internal_progress() const {
  return progress_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TMPeerShardInfoV2_TMIncomplete::progress() const {
  // @@protoc_insertion_point(field_get:protocol.TMPeerShardInfoV2.TMIncomplete.progress)
  return _internal_progress();
}
inline void TMPeerShardInfoV2_TMIncomplete::_internal_set_progress(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  progress_ = value;
}
inline void TMPeerShardInfoV2_TMIncomplete::set_progress(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_progress(value);
  // @@protoc_insertion_point(field_set:protocol.TMPeerShardInfoV2.TMIncomplete.progress)
}

// -------------------------------------------------------------------

// TMPeerShardInfoV2

// required uint32 timestamp = 1;
inline bool TMPeerShardInfoV2::_internal_has_timestamp() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool TMPeerShardInfoV2::has_timestamp() const {
  return _internal_has_timestamp();
}
inline void TMPeerShardInfoV2::clear_timestamp() {
  timestamp_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TMPeerShardInfoV2::_internal_timestamp() const {
  return timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TMPeerShardInfoV2::timestamp() const {
  // @@protoc_insertion_point(field_get:protocol.TMPeerShardInfoV2.timestamp)
  return _internal_timestamp();
}
inline void TMPeerShardInfoV2::_internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  timestamp_ = value;
}
inline void TMPeerShardInfoV2::set_timestamp(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:protocol.TMPeerShardInfoV2.timestamp)
}

// repeated .protocol.TMPeerShardInfoV2.TMIncomplete incomplete = 2;
inline int TMPeerShardInfoV2::_internal_incomplete_size() const {
  return incomplete_.size();
}
inline int TMPeerShardInfoV2::incomplete_size() const {
  return _internal_incomplete_size();
}
inline void TMPeerShardInfoV2::clear_incomplete() {
  incomplete_.Clear();
}
inline ::protocol::TMPeerShardInfoV2_TMIncomplete* TMPeerShardInfoV2::mutable_incomplete(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.TMPeerShardInfoV2.incomplete)
  return incomplete_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::TMPeerShardInfoV2_TMIncomplete >*
TMPeerShardInfoV2::mutable_incomplete() {
  // @@protoc_insertion_point(field_mutable_list:protocol.TMPeerShardInfoV2.incomplete)
  return &incomplete_;
}
inline const ::protocol::TMPeerShardInfoV2_TMIncomplete& TMPeerShardInfoV2::_internal_incomplete(int index) const {
  return incomplete_.Get(index);
}
inline const ::protocol::TMPeerShardInfoV2_TMIncomplete& TMPeerShardInfoV2::incomplete(int index) const {
  // @@protoc_insertion_point(field_get:protocol.TMPeerShardInfoV2.incomplete)
  return _internal_incomplete(index);
}
inline ::protocol::TMPeerShardInfoV2_TMIncomplete* TMPeerShardInfoV2::_internal_add_incomplete() {
  return incomplete_.Add();
}
inline ::protocol::TMPeerShardInfoV2_TMIncomplete* TMPeerShardInfoV2::add_incomplete() {
  // @@protoc_insertion_point(field_add:protocol.TMPeerShardInfoV2.incomplete)
  return _internal_add_incomplete();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::TMPeerShardInfoV2_TMIncomplete >&
TMPeerShardInfoV2::incomplete() const {
  // @@protoc_insertion_point(field_list:protocol.TMPeerShardInfoV2.incomplete)
  return incomplete_;
}

// optional string finalized = 3;
inline bool TMPeerShardInfoV2::_internal_has_finalized() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TMPeerShardInfoV2::has_finalized() const {
  return _internal_has_finalized();
}
inline void TMPeerShardInfoV2::clear_finalized() {
  finalized_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TMPeerShardInfoV2::finalized() const {
  // @@protoc_insertion_point(field_get:protocol.TMPeerShardInfoV2.finalized)
  return _internal_finalized();
}
inline void TMPeerShardInfoV2::set_finalized(const std::string& value) {
  _internal_set_finalized(value);
  // @@protoc_insertion_point(field_set:protocol.TMPeerShardInfoV2.finalized)
}
inline std::string* TMPeerShardInfoV2::mutable_finalized() {
  // @@protoc_insertion_point(field_mutable:protocol.TMPeerShardInfoV2.finalized)
  return _internal_mutable_finalized();
}
inline const std::string& TMPeerShardInfoV2::_internal_finalized() const {
  return finalized_.Get();
}
inline void TMPeerShardInfoV2::_internal_set_finalized(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  finalized_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void TMPeerShardInfoV2::set_finalized(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  finalized_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:protocol.TMPeerShardInfoV2.finalized)
}
inline void TMPeerShardInfoV2::set_finalized(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  finalized_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:protocol.TMPeerShardInfoV2.finalized)
}
inline void TMPeerShardInfoV2::set_finalized(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  finalized_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:protocol.TMPeerShardInfoV2.finalized)
}
inline std::string* TMPeerShardInfoV2::_internal_mutable_finalized() {
  _has_bits_[0] |= 0x00000001u;
  return finalized_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* TMPeerShardInfoV2::release_finalized() {
  // @@protoc_insertion_point(field_release:protocol.TMPeerShardInfoV2.finalized)
  if (!_internal_has_finalized()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return finalized_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void TMPeerShardInfoV2::set_allocated_finalized(std::string* finalized) {
  if (finalized != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  finalized_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), finalized,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:protocol.TMPeerShardInfoV2.finalized)
}
inline std::string* TMPeerShardInfoV2::unsafe_arena_release_finalized() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protocol.TMPeerShardInfoV2.finalized)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return finalized_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void TMPeerShardInfoV2::unsafe_arena_set_allocated_finalized(
    std::string* finalized) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (finalized != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  finalized_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      finalized, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.TMPeerShardInfoV2.finalized)
}

// required bytes publicKey = 4;
inline bool TMPeerShardInfoV2::_internal_has_publickey() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TMPeerShardInfoV2::has_publickey() const {
  return _internal_has_publickey();
}
inline void TMPeerShardInfoV2::clear_publickey() {
  publickey_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& TMPeerShardInfoV2::publickey() const {
  // @@protoc_insertion_point(field_get:protocol.TMPeerShardInfoV2.publicKey)
  return _internal_publickey();
}
inline void TMPeerShardInfoV2::set_publickey(const std::string& value) {
  _internal_set_publickey(value);
  // @@protoc_insertion_point(field_set:protocol.TMPeerShardInfoV2.publicKey)
}
inline std::string* TMPeerShardInfoV2::mutable_publickey() {
  // @@protoc_insertion_point(field_mutable:protocol.TMPeerShardInfoV2.publicKey)
  return _internal_mutable_publickey();
}
inline const std::string& TMPeerShardInfoV2::_internal_publickey() const {
  return publickey_.Get();
}
inline void TMPeerShardInfoV2::_internal_set_publickey(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  publickey_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void TMPeerShardInfoV2::set_publickey(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  publickey_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:protocol.TMPeerShardInfoV2.publicKey)
}
inline void TMPeerShardInfoV2::set_publickey(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  publickey_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:protocol.TMPeerShardInfoV2.publicKey)
}
inline void TMPeerShardInfoV2::set_publickey(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  publickey_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:protocol.TMPeerShardInfoV2.publicKey)
}
inline std::string* TMPeerShardInfoV2::_internal_mutable_publickey() {
  _has_bits_[0] |= 0x00000002u;
  return publickey_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* TMPeerShardInfoV2::release_publickey() {
  // @@protoc_insertion_point(field_release:protocol.TMPeerShardInfoV2.publicKey)
  if (!_internal_has_publickey()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return publickey_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void TMPeerShardInfoV2::set_allocated_publickey(std::string* publickey) {
  if (publickey != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  publickey_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), publickey,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:protocol.TMPeerShardInfoV2.publicKey)
}
inline std::string* TMPeerShardInfoV2::unsafe_arena_release_publickey() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protocol.TMPeerShardInfoV2.publicKey)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000002u;
  return publickey_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void TMPeerShardInfoV2::unsafe_arena_set_allocated_publickey(
    std::string* publickey) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (publickey != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  publickey_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      publickey, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.TMPeerShardInfoV2.publicKey)
}

// required bytes signature = 5;
inline bool TMPeerShardInfoV2::_internal_has_signature() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TMPeerShardInfoV2::has_signature() const {
  return _internal_has_signature();
}
inline void TMPeerShardInfoV2::clear_signature() {
  signature_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& TMPeerShardInfoV2::signature() const {
  // @@protoc_insertion_point(field_get:protocol.TMPeerShardInfoV2.signature)
  return _internal_signature();
}
inline void TMPeerShardInfoV2::set_signature(const std::string& value) {
  _internal_set_signature(value);
  // @@protoc_insertion_point(field_set:protocol.TMPeerShardInfoV2.signature)
}
inline std::string* TMPeerShardInfoV2::mutable_signature() {
  // @@protoc_insertion_point(field_mutable:protocol.TMPeerShardInfoV2.signature)
  return _internal_mutable_signature();
}
inline const std::string& TMPeerShardInfoV2::_internal_signature() const {
  return signature_.Get();
}
inline void TMPeerShardInfoV2::_internal_set_signature(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  signature_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void TMPeerShardInfoV2::set_signature(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  signature_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:protocol.TMPeerShardInfoV2.signature)
}
inline void TMPeerShardInfoV2::set_signature(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  signature_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:protocol.TMPeerShardInfoV2.signature)
}
inline void TMPeerShardInfoV2::set_signature(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000004u;
  signature_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:protocol.TMPeerShardInfoV2.signature)
}
inline std::string* TMPeerShardInfoV2::_internal_mutable_signature() {
  _has_bits_[0] |= 0x00000004u;
  return signature_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* TMPeerShardInfoV2::release_signature() {
  // @@protoc_insertion_point(field_release:protocol.TMPeerShardInfoV2.signature)
  if (!_internal_has_signature()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return signature_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void TMPeerShardInfoV2::set_allocated_signature(std::string* signature) {
  if (signature != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  signature_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), signature,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:protocol.TMPeerShardInfoV2.signature)
}
inline std::string* TMPeerShardInfoV2::unsafe_arena_release_signature() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protocol.TMPeerShardInfoV2.signature)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000004u;
  return signature_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void TMPeerShardInfoV2::unsafe_arena_set_allocated_signature(
    std::string* signature) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (signature != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  signature_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      signature, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.TMPeerShardInfoV2.signature)
}

// repeated .protocol.TMPublicKey peerChain = 6;
inline int TMPeerShardInfoV2::_internal_peerchain_size() const {
  return peerchain_.size();
}
inline int TMPeerShardInfoV2::peerchain_size() const {
  return _internal_peerchain_size();
}
inline void TMPeerShardInfoV2::clear_peerchain() {
  peerchain_.Clear();
}
inline ::protocol::TMPublicKey* TMPeerShardInfoV2::mutable_peerchain(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.TMPeerShardInfoV2.peerChain)
  return peerchain_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::TMPublicKey >*
TMPeerShardInfoV2::mutable_peerchain() {
  // @@protoc_insertion_point(field_mutable_list:protocol.TMPeerShardInfoV2.peerChain)
  return &peerchain_;
}
inline const ::protocol::TMPublicKey& TMPeerShardInfoV2::_internal_peerchain(int index) const {
  return peerchain_.Get(index);
}
inline const ::protocol::TMPublicKey& TMPeerShardInfoV2::peerchain(int index) const {
  // @@protoc_insertion_point(field_get:protocol.TMPeerShardInfoV2.peerChain)
  return _internal_peerchain(index);
}
inline ::protocol::TMPublicKey* TMPeerShardInfoV2::_internal_add_peerchain() {
  return peerchain_.Add();
}
inline ::protocol::TMPublicKey* TMPeerShardInfoV2::add_peerchain() {
  // @@protoc_insertion_point(field_add:protocol.TMPeerShardInfoV2.peerChain)
  return _internal_add_peerchain();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::TMPublicKey >&
TMPeerShardInfoV2::peerchain() const {
  // @@protoc_insertion_point(field_list:protocol.TMPeerShardInfoV2.peerChain)
  return peerchain_;
}

// -------------------------------------------------------------------

// TMTransaction

// required bytes rawTransaction = 1;
inline bool TMTransaction::_internal_has_rawtransaction() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TMTransaction::has_rawtransaction() const {
  return _internal_has_rawtransaction();
}
inline void TMTransaction::clear_rawtransaction() {
  rawtransaction_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TMTransaction::rawtransaction() const {
  // @@protoc_insertion_point(field_get:protocol.TMTransaction.rawTransaction)
  return _internal_rawtransaction();
}
inline void TMTransaction::set_rawtransaction(const std::string& value) {
  _internal_set_rawtransaction(value);
  // @@protoc_insertion_point(field_set:protocol.TMTransaction.rawTransaction)
}
inline std::string* TMTransaction::mutable_rawtransaction() {
  // @@protoc_insertion_point(field_mutable:protocol.TMTransaction.rawTransaction)
  return _internal_mutable_rawtransaction();
}
inline const std::string& TMTransaction::_internal_rawtransaction() const {
  return rawtransaction_.Get();
}
inline void TMTransaction::_internal_set_rawtransaction(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  rawtransaction_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void TMTransaction::set_rawtransaction(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  rawtransaction_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:protocol.TMTransaction.rawTransaction)
}
inline void TMTransaction::set_rawtransaction(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  rawtransaction_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:protocol.TMTransaction.rawTransaction)
}
inline void TMTransaction::set_rawtransaction(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  rawtransaction_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:protocol.TMTransaction.rawTransaction)
}
inline std::string* TMTransaction::_internal_mutable_rawtransaction() {
  _has_bits_[0] |= 0x00000001u;
  return rawtransaction_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* TMTransaction::release_rawtransaction() {
  // @@protoc_insertion_point(field_release:protocol.TMTransaction.rawTransaction)
  if (!_internal_has_rawtransaction()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return rawtransaction_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void TMTransaction::set_allocated_rawtransaction(std::string* rawtransaction) {
  if (rawtransaction != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  rawtransaction_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), rawtransaction,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:protocol.TMTransaction.rawTransaction)
}
inline std::string* TMTransaction::unsafe_arena_release_rawtransaction() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protocol.TMTransaction.rawTransaction)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return rawtransaction_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void TMTransaction::unsafe_arena_set_allocated_rawtransaction(
    std::string* rawtransaction) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (rawtransaction != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  rawtransaction_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      rawtransaction, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.TMTransaction.rawTransaction)
}

// required .protocol.TransactionStatus status = 2;
inline bool TMTransaction::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool TMTransaction::has_status() const {
  return _internal_has_status();
}
inline void TMTransaction::clear_status() {
  status_ = 1;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::protocol::TransactionStatus TMTransaction::_internal_status() const {
  return static_cast< ::protocol::TransactionStatus >(status_);
}
inline ::protocol::TransactionStatus TMTransaction::status() const {
  // @@protoc_insertion_point(field_get:protocol.TMTransaction.status)
  return _internal_status();
}
inline void TMTransaction::_internal_set_status(::protocol::TransactionStatus value) {
  assert(::protocol::TransactionStatus_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  status_ = value;
}
inline void TMTransaction::set_status(::protocol::TransactionStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:protocol.TMTransaction.status)
}

// optional uint64 receiveTimestamp = 3;
inline bool TMTransaction::_internal_has_receivetimestamp() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TMTransaction::has_receivetimestamp() const {
  return _internal_has_receivetimestamp();
}
inline void TMTransaction::clear_receivetimestamp() {
  receivetimestamp_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 TMTransaction::_internal_receivetimestamp() const {
  return receivetimestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 TMTransaction::receivetimestamp() const {
  // @@protoc_insertion_point(field_get:protocol.TMTransaction.receiveTimestamp)
  return _internal_receivetimestamp();
}
inline void TMTransaction::_internal_set_receivetimestamp(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  receivetimestamp_ = value;
}
inline void TMTransaction::set_receivetimestamp(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_receivetimestamp(value);
  // @@protoc_insertion_point(field_set:protocol.TMTransaction.receiveTimestamp)
}

// optional bool deferred = 4;
inline bool TMTransaction::_internal_has_deferred() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TMTransaction::has_deferred() const {
  return _internal_has_deferred();
}
inline void TMTransaction::clear_deferred() {
  deferred_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool TMTransaction::_internal_deferred() const {
  return deferred_;
}
inline bool TMTransaction::deferred() const {
  // @@protoc_insertion_point(field_get:protocol.TMTransaction.deferred)
  return _internal_deferred();
}
inline void TMTransaction::_internal_set_deferred(bool value) {
  _has_bits_[0] |= 0x00000004u;
  deferred_ = value;
}
inline void TMTransaction::set_deferred(bool value) {
  _internal_set_deferred(value);
  // @@protoc_insertion_point(field_set:protocol.TMTransaction.deferred)
}

// -------------------------------------------------------------------

// TMTransactions

// repeated .protocol.TMTransaction transactions = 1;
inline int TMTransactions::_internal_transactions_size() const {
  return transactions_.size();
}
inline int TMTransactions::transactions_size() const {
  return _internal_transactions_size();
}
inline void TMTransactions::clear_transactions() {
  transactions_.Clear();
}
inline ::protocol::TMTransaction* TMTransactions::mutable_transactions(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.TMTransactions.transactions)
  return transactions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::TMTransaction >*
TMTransactions::mutable_transactions() {
  // @@protoc_insertion_point(field_mutable_list:protocol.TMTransactions.transactions)
  return &transactions_;
}
inline const ::protocol::TMTransaction& TMTransactions::_internal_transactions(int index) const {
  return transactions_.Get(index);
}
inline const ::protocol::TMTransaction& TMTransactions::transactions(int index) const {
  // @@protoc_insertion_point(field_get:protocol.TMTransactions.transactions)
  return _internal_transactions(index);
}
inline ::protocol::TMTransaction* TMTransactions::_internal_add_transactions() {
  return transactions_.Add();
}
inline ::protocol::TMTransaction* TMTransactions::add_transactions() {
  // @@protoc_insertion_point(field_add:protocol.TMTransactions.transactions)
  return _internal_add_transactions();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::TMTransaction >&
TMTransactions::transactions() const {
  // @@protoc_insertion_point(field_list:protocol.TMTransactions.transactions)
  return transactions_;
}

// -------------------------------------------------------------------

// TMStatusChange

// optional .protocol.NodeStatus newStatus = 1;
inline bool TMStatusChange::_internal_has_newstatus() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool TMStatusChange::has_newstatus() const {
  return _internal_has_newstatus();
}
inline void TMStatusChange::clear_newstatus() {
  newstatus_ = 1;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::protocol::NodeStatus TMStatusChange::_internal_newstatus() const {
  return static_cast< ::protocol::NodeStatus >(newstatus_);
}
inline ::protocol::NodeStatus TMStatusChange::newstatus() const {
  // @@protoc_insertion_point(field_get:protocol.TMStatusChange.newStatus)
  return _internal_newstatus();
}
inline void TMStatusChange::_internal_set_newstatus(::protocol::NodeStatus value) {
  assert(::protocol::NodeStatus_IsValid(value));
  _has_bits_[0] |= 0x00000040u;
  newstatus_ = value;
}
inline void TMStatusChange::set_newstatus(::protocol::NodeStatus value) {
  _internal_set_newstatus(value);
  // @@protoc_insertion_point(field_set:protocol.TMStatusChange.newStatus)
}

// optional .protocol.NodeEvent newEvent = 2;
inline bool TMStatusChange::_internal_has_newevent() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool TMStatusChange::has_newevent() const {
  return _internal_has_newevent();
}
inline void TMStatusChange::clear_newevent() {
  newevent_ = 1;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::protocol::NodeEvent TMStatusChange::_internal_newevent() const {
  return static_cast< ::protocol::NodeEvent >(newevent_);
}
inline ::protocol::NodeEvent TMStatusChange::newevent() const {
  // @@protoc_insertion_point(field_get:protocol.TMStatusChange.newEvent)
  return _internal_newevent();
}
inline void TMStatusChange::_internal_set_newevent(::protocol::NodeEvent value) {
  assert(::protocol::NodeEvent_IsValid(value));
  _has_bits_[0] |= 0x00000080u;
  newevent_ = value;
}
inline void TMStatusChange::set_newevent(::protocol::NodeEvent value) {
  _internal_set_newevent(value);
  // @@protoc_insertion_point(field_set:protocol.TMStatusChange.newEvent)
}

// optional uint32 ledgerSeq = 3;
inline bool TMStatusChange::_internal_has_ledgerseq() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TMStatusChange::has_ledgerseq() const {
  return _internal_has_ledgerseq();
}
inline void TMStatusChange::clear_ledgerseq() {
  ledgerseq_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TMStatusChange::_internal_ledgerseq() const {
  return ledgerseq_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TMStatusChange::ledgerseq() const {
  // @@protoc_insertion_point(field_get:protocol.TMStatusChange.ledgerSeq)
  return _internal_ledgerseq();
}
inline void TMStatusChange::_internal_set_ledgerseq(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  ledgerseq_ = value;
}
inline void TMStatusChange::set_ledgerseq(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_ledgerseq(value);
  // @@protoc_insertion_point(field_set:protocol.TMStatusChange.ledgerSeq)
}

// optional bytes ledgerHash = 4;
inline bool TMStatusChange::_internal_has_ledgerhash() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TMStatusChange::has_ledgerhash() const {
  return _internal_has_ledgerhash();
}
inline void TMStatusChange::clear_ledgerhash() {
  ledgerhash_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TMStatusChange::ledgerhash() const {
  // @@protoc_insertion_point(field_get:protocol.TMStatusChange.ledgerHash)
  return _internal_ledgerhash();
}
inline void TMStatusChange::set_ledgerhash(const std::string& value) {
  _internal_set_ledgerhash(value);
  // @@protoc_insertion_point(field_set:protocol.TMStatusChange.ledgerHash)
}
inline std::string* TMStatusChange::mutable_ledgerhash() {
  // @@protoc_insertion_point(field_mutable:protocol.TMStatusChange.ledgerHash)
  return _internal_mutable_ledgerhash();
}
inline const std::string& TMStatusChange::_internal_ledgerhash() const {
  return ledgerhash_.Get();
}
inline void TMStatusChange::_internal_set_ledgerhash(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  ledgerhash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void TMStatusChange::set_ledgerhash(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  ledgerhash_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:protocol.TMStatusChange.ledgerHash)
}
inline void TMStatusChange::set_ledgerhash(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  ledgerhash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:protocol.TMStatusChange.ledgerHash)
}
inline void TMStatusChange::set_ledgerhash(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  ledgerhash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:protocol.TMStatusChange.ledgerHash)
}
inline std::string* TMStatusChange::_internal_mutable_ledgerhash() {
  _has_bits_[0] |= 0x00000001u;
  return ledgerhash_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* TMStatusChange::release_ledgerhash() {
  // @@protoc_insertion_point(field_release:protocol.TMStatusChange.ledgerHash)
  if (!_internal_has_ledgerhash()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return ledgerhash_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void TMStatusChange::set_allocated_ledgerhash(std::string* ledgerhash) {
  if (ledgerhash != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  ledgerhash_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ledgerhash,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:protocol.TMStatusChange.ledgerHash)
}
inline std::string* TMStatusChange::unsafe_arena_release_ledgerhash() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protocol.TMStatusChange.ledgerHash)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return ledgerhash_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void TMStatusChange::unsafe_arena_set_allocated_ledgerhash(
    std::string* ledgerhash) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (ledgerhash != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  ledgerhash_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ledgerhash, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.TMStatusChange.ledgerHash)
}

// optional bytes ledgerHashPrevious = 5;
inline bool TMStatusChange::_internal_has_ledgerhashprevious() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TMStatusChange::has_ledgerhashprevious() const {
  return _internal_has_ledgerhashprevious();
}
inline void TMStatusChange::clear_ledgerhashprevious() {
  ledgerhashprevious_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& TMStatusChange::ledgerhashprevious() const {
  // @@protoc_insertion_point(field_get:protocol.TMStatusChange.ledgerHashPrevious)
  return _internal_ledgerhashprevious();
}
inline void TMStatusChange::set_ledgerhashprevious(const std::string& value) {
  _internal_set_ledgerhashprevious(value);
  // @@protoc_insertion_point(field_set:protocol.TMStatusChange.ledgerHashPrevious)
}
inline std::string* TMStatusChange::mutable_ledgerhashprevious() {
  // @@protoc_insertion_point(field_mutable:protocol.TMStatusChange.ledgerHashPrevious)
  return _internal_mutable_ledgerhashprevious();
}
inline const std::string& TMStatusChange::_internal_ledgerhashprevious() const {
  return ledgerhashprevious_.Get();
}
inline void TMStatusChange::_internal_set_ledgerhashprevious(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  ledgerhashprevious_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void TMStatusChange::set_ledgerhashprevious(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  ledgerhashprevious_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:protocol.TMStatusChange.ledgerHashPrevious)
}
inline void TMStatusChange::set_ledgerhashprevious(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  ledgerhashprevious_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:protocol.TMStatusChange.ledgerHashPrevious)
}
inline void TMStatusChange::set_ledgerhashprevious(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  ledgerhashprevious_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:protocol.TMStatusChange.ledgerHashPrevious)
}
inline std::string* TMStatusChange::_internal_mutable_ledgerhashprevious() {
  _has_bits_[0] |= 0x00000002u;
  return ledgerhashprevious_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* TMStatusChange::release_ledgerhashprevious() {
  // @@protoc_insertion_point(field_release:protocol.TMStatusChange.ledgerHashPrevious)
  if (!_internal_has_ledgerhashprevious()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return ledgerhashprevious_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void TMStatusChange::set_allocated_ledgerhashprevious(std::string* ledgerhashprevious) {
  if (ledgerhashprevious != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  ledgerhashprevious_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ledgerhashprevious,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:protocol.TMStatusChange.ledgerHashPrevious)
}
inline std::string* TMStatusChange::unsafe_arena_release_ledgerhashprevious() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protocol.TMStatusChange.ledgerHashPrevious)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000002u;
  return ledgerhashprevious_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void TMStatusChange::unsafe_arena_set_allocated_ledgerhashprevious(
    std::string* ledgerhashprevious) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (ledgerhashprevious != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  ledgerhashprevious_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ledgerhashprevious, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.TMStatusChange.ledgerHashPrevious)
}

// optional uint64 networkTime = 6;
inline bool TMStatusChange::_internal_has_networktime() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool TMStatusChange::has_networktime() const {
  return _internal_has_networktime();
}
inline void TMStatusChange::clear_networktime() {
  networktime_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 TMStatusChange::_internal_networktime() const {
  return networktime_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 TMStatusChange::networktime() const {
  // @@protoc_insertion_point(field_get:protocol.TMStatusChange.networkTime)
  return _internal_networktime();
}
inline void TMStatusChange::_internal_set_networktime(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000010u;
  networktime_ = value;
}
inline void TMStatusChange::set_networktime(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_networktime(value);
  // @@protoc_insertion_point(field_set:protocol.TMStatusChange.networkTime)
}

// optional uint32 firstSeq = 7;
inline bool TMStatusChange::_internal_has_firstseq() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool TMStatusChange::has_firstseq() const {
  return _internal_has_firstseq();
}
inline void TMStatusChange::clear_firstseq() {
  firstseq_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TMStatusChange::_internal_firstseq() const {
  return firstseq_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TMStatusChange::firstseq() const {
  // @@protoc_insertion_point(field_get:protocol.TMStatusChange.firstSeq)
  return _internal_firstseq();
}
inline void TMStatusChange::_internal_set_firstseq(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  firstseq_ = value;
}
inline void TMStatusChange::set_firstseq(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_firstseq(value);
  // @@protoc_insertion_point(field_set:protocol.TMStatusChange.firstSeq)
}

// optional uint32 lastSeq = 8;
inline bool TMStatusChange::_internal_has_lastseq() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool TMStatusChange::has_lastseq() const {
  return _internal_has_lastseq();
}
inline void TMStatusChange::clear_lastseq() {
  lastseq_ = 0u;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TMStatusChange::_internal_lastseq() const {
  return lastseq_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TMStatusChange::lastseq() const {
  // @@protoc_insertion_point(field_get:protocol.TMStatusChange.lastSeq)
  return _internal_lastseq();
}
inline void TMStatusChange::_internal_set_lastseq(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000020u;
  lastseq_ = value;
}
inline void TMStatusChange::set_lastseq(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_lastseq(value);
  // @@protoc_insertion_point(field_set:protocol.TMStatusChange.lastSeq)
}

// -------------------------------------------------------------------

// TMProposeSet

// required uint32 proposeSeq = 1;
inline bool TMProposeSet::_internal_has_proposeseq() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool TMProposeSet::has_proposeseq() const {
  return _internal_has_proposeseq();
}
inline void TMProposeSet::clear_proposeseq() {
  proposeseq_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TMProposeSet::_internal_proposeseq() const {
  return proposeseq_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TMProposeSet::proposeseq() const {
  // @@protoc_insertion_point(field_get:protocol.TMProposeSet.proposeSeq)
  return _internal_proposeseq();
}
inline void TMProposeSet::_internal_set_proposeseq(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  proposeseq_ = value;
}
inline void TMProposeSet::set_proposeseq(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_proposeseq(value);
  // @@protoc_insertion_point(field_set:protocol.TMProposeSet.proposeSeq)
}

// required bytes currentTxHash = 2;
inline bool TMProposeSet::_internal_has_currenttxhash() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TMProposeSet::has_currenttxhash() const {
  return _internal_has_currenttxhash();
}
inline void TMProposeSet::clear_currenttxhash() {
  currenttxhash_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TMProposeSet::currenttxhash() const {
  // @@protoc_insertion_point(field_get:protocol.TMProposeSet.currentTxHash)
  return _internal_currenttxhash();
}
inline void TMProposeSet::set_currenttxhash(const std::string& value) {
  _internal_set_currenttxhash(value);
  // @@protoc_insertion_point(field_set:protocol.TMProposeSet.currentTxHash)
}
inline std::string* TMProposeSet::mutable_currenttxhash() {
  // @@protoc_insertion_point(field_mutable:protocol.TMProposeSet.currentTxHash)
  return _internal_mutable_currenttxhash();
}
inline const std::string& TMProposeSet::_internal_currenttxhash() const {
  return currenttxhash_.Get();
}
inline void TMProposeSet::_internal_set_currenttxhash(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  currenttxhash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void TMProposeSet::set_currenttxhash(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  currenttxhash_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:protocol.TMProposeSet.currentTxHash)
}
inline void TMProposeSet::set_currenttxhash(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  currenttxhash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:protocol.TMProposeSet.currentTxHash)
}
inline void TMProposeSet::set_currenttxhash(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  currenttxhash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:protocol.TMProposeSet.currentTxHash)
}
inline std::string* TMProposeSet::_internal_mutable_currenttxhash() {
  _has_bits_[0] |= 0x00000001u;
  return currenttxhash_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* TMProposeSet::release_currenttxhash() {
  // @@protoc_insertion_point(field_release:protocol.TMProposeSet.currentTxHash)
  if (!_internal_has_currenttxhash()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return currenttxhash_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void TMProposeSet::set_allocated_currenttxhash(std::string* currenttxhash) {
  if (currenttxhash != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  currenttxhash_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), currenttxhash,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:protocol.TMProposeSet.currentTxHash)
}
inline std::string* TMProposeSet::unsafe_arena_release_currenttxhash() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protocol.TMProposeSet.currentTxHash)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return currenttxhash_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void TMProposeSet::unsafe_arena_set_allocated_currenttxhash(
    std::string* currenttxhash) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (currenttxhash != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  currenttxhash_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      currenttxhash, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.TMProposeSet.currentTxHash)
}

// required bytes nodePubKey = 3;
inline bool TMProposeSet::_internal_has_nodepubkey() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TMProposeSet::has_nodepubkey() const {
  return _internal_has_nodepubkey();
}
inline void TMProposeSet::clear_nodepubkey() {
  nodepubkey_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& TMProposeSet::nodepubkey() const {
  // @@protoc_insertion_point(field_get:protocol.TMProposeSet.nodePubKey)
  return _internal_nodepubkey();
}
inline void TMProposeSet::set_nodepubkey(const std::string& value) {
  _internal_set_nodepubkey(value);
  // @@protoc_insertion_point(field_set:protocol.TMProposeSet.nodePubKey)
}
inline std::string* TMProposeSet::mutable_nodepubkey() {
  // @@protoc_insertion_point(field_mutable:protocol.TMProposeSet.nodePubKey)
  return _internal_mutable_nodepubkey();
}
inline const std::string& TMProposeSet::_internal_nodepubkey() const {
  return nodepubkey_.Get();
}
inline void TMProposeSet::_internal_set_nodepubkey(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  nodepubkey_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void TMProposeSet::set_nodepubkey(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  nodepubkey_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:protocol.TMProposeSet.nodePubKey)
}
inline void TMProposeSet::set_nodepubkey(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  nodepubkey_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:protocol.TMProposeSet.nodePubKey)
}
inline void TMProposeSet::set_nodepubkey(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  nodepubkey_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:protocol.TMProposeSet.nodePubKey)
}
inline std::string* TMProposeSet::_internal_mutable_nodepubkey() {
  _has_bits_[0] |= 0x00000002u;
  return nodepubkey_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* TMProposeSet::release_nodepubkey() {
  // @@protoc_insertion_point(field_release:protocol.TMProposeSet.nodePubKey)
  if (!_internal_has_nodepubkey()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return nodepubkey_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void TMProposeSet::set_allocated_nodepubkey(std::string* nodepubkey) {
  if (nodepubkey != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  nodepubkey_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), nodepubkey,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:protocol.TMProposeSet.nodePubKey)
}
inline std::string* TMProposeSet::unsafe_arena_release_nodepubkey() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protocol.TMProposeSet.nodePubKey)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000002u;
  return nodepubkey_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void TMProposeSet::unsafe_arena_set_allocated_nodepubkey(
    std::string* nodepubkey) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (nodepubkey != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  nodepubkey_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      nodepubkey, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.TMProposeSet.nodePubKey)
}

// required uint32 closeTime = 4;
inline bool TMProposeSet::_internal_has_closetime() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool TMProposeSet::has_closetime() const {
  return _internal_has_closetime();
}
inline void TMProposeSet::clear_closetime() {
  closetime_ = 0u;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TMProposeSet::_internal_closetime() const {
  return closetime_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TMProposeSet::closetime() const {
  // @@protoc_insertion_point(field_get:protocol.TMProposeSet.closeTime)
  return _internal_closetime();
}
inline void TMProposeSet::_internal_set_closetime(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000020u;
  closetime_ = value;
}
inline void TMProposeSet::set_closetime(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_closetime(value);
  // @@protoc_insertion_point(field_set:protocol.TMProposeSet.closeTime)
}

// required bytes signature = 5;
inline bool TMProposeSet::_internal_has_signature() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TMProposeSet::has_signature() const {
  return _internal_has_signature();
}
inline void TMProposeSet::clear_signature() {
  signature_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& TMProposeSet::signature() const {
  // @@protoc_insertion_point(field_get:protocol.TMProposeSet.signature)
  return _internal_signature();
}
inline void TMProposeSet::set_signature(const std::string& value) {
  _internal_set_signature(value);
  // @@protoc_insertion_point(field_set:protocol.TMProposeSet.signature)
}
inline std::string* TMProposeSet::mutable_signature() {
  // @@protoc_insertion_point(field_mutable:protocol.TMProposeSet.signature)
  return _internal_mutable_signature();
}
inline const std::string& TMProposeSet::_internal_signature() const {
  return signature_.Get();
}
inline void TMProposeSet::_internal_set_signature(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  signature_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void TMProposeSet::set_signature(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  signature_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:protocol.TMProposeSet.signature)
}
inline void TMProposeSet::set_signature(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  signature_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:protocol.TMProposeSet.signature)
}
inline void TMProposeSet::set_signature(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000004u;
  signature_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:protocol.TMProposeSet.signature)
}
inline std::string* TMProposeSet::_internal_mutable_signature() {
  _has_bits_[0] |= 0x00000004u;
  return signature_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* TMProposeSet::release_signature() {
  // @@protoc_insertion_point(field_release:protocol.TMProposeSet.signature)
  if (!_internal_has_signature()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return signature_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void TMProposeSet::set_allocated_signature(std::string* signature) {
  if (signature != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  signature_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), signature,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:protocol.TMProposeSet.signature)
}
inline std::string* TMProposeSet::unsafe_arena_release_signature() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protocol.TMProposeSet.signature)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000004u;
  return signature_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void TMProposeSet::unsafe_arena_set_allocated_signature(
    std::string* signature) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (signature != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  signature_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      signature, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.TMProposeSet.signature)
}

// required bytes previousledger = 6;
inline bool TMProposeSet::_internal_has_previousledger() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool TMProposeSet::has_previousledger() const {
  return _internal_has_previousledger();
}
inline void TMProposeSet::clear_previousledger() {
  previousledger_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& TMProposeSet::previousledger() const {
  // @@protoc_insertion_point(field_get:protocol.TMProposeSet.previousledger)
  return _internal_previousledger();
}
inline void TMProposeSet::set_previousledger(const std::string& value) {
  _internal_set_previousledger(value);
  // @@protoc_insertion_point(field_set:protocol.TMProposeSet.previousledger)
}
inline std::string* TMProposeSet::mutable_previousledger() {
  // @@protoc_insertion_point(field_mutable:protocol.TMProposeSet.previousledger)
  return _internal_mutable_previousledger();
}
inline const std::string& TMProposeSet::_internal_previousledger() const {
  return previousledger_.Get();
}
inline void TMProposeSet::_internal_set_previousledger(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  previousledger_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void TMProposeSet::set_previousledger(std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  previousledger_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:protocol.TMProposeSet.previousledger)
}
inline void TMProposeSet::set_previousledger(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  previousledger_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:protocol.TMProposeSet.previousledger)
}
inline void TMProposeSet::set_previousledger(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000008u;
  previousledger_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:protocol.TMProposeSet.previousledger)
}
inline std::string* TMProposeSet::_internal_mutable_previousledger() {
  _has_bits_[0] |= 0x00000008u;
  return previousledger_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* TMProposeSet::release_previousledger() {
  // @@protoc_insertion_point(field_release:protocol.TMProposeSet.previousledger)
  if (!_internal_has_previousledger()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return previousledger_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void TMProposeSet::set_allocated_previousledger(std::string* previousledger) {
  if (previousledger != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  previousledger_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), previousledger,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:protocol.TMProposeSet.previousledger)
}
inline std::string* TMProposeSet::unsafe_arena_release_previousledger() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protocol.TMProposeSet.previousledger)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000008u;
  return previousledger_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void TMProposeSet::unsafe_arena_set_allocated_previousledger(
    std::string* previousledger) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (previousledger != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  previousledger_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      previousledger, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.TMProposeSet.previousledger)
}

// repeated bytes addedTransactions = 10;
inline int TMProposeSet::_internal_addedtransactions_size() const {
  return addedtransactions_.size();
}
inline int TMProposeSet::addedtransactions_size() const {
  return _internal_addedtransactions_size();
}
inline void TMProposeSet::clear_addedtransactions() {
  addedtransactions_.Clear();
}
inline std::string* TMProposeSet::add_addedtransactions() {
  // @@protoc_insertion_point(field_add_mutable:protocol.TMProposeSet.addedTransactions)
  return _internal_add_addedtransactions();
}
inline const std::string& TMProposeSet::_internal_addedtransactions(int index) const {
  return addedtransactions_.Get(index);
}
inline const std::string& TMProposeSet::addedtransactions(int index) const {
  // @@protoc_insertion_point(field_get:protocol.TMProposeSet.addedTransactions)
  return _internal_addedtransactions(index);
}
inline std::string* TMProposeSet::mutable_addedtransactions(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.TMProposeSet.addedTransactions)
  return addedtransactions_.Mutable(index);
}
inline void TMProposeSet::set_addedtransactions(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:protocol.TMProposeSet.addedTransactions)
  addedtransactions_.Mutable(index)->assign(value);
}
inline void TMProposeSet::set_addedtransactions(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:protocol.TMProposeSet.addedTransactions)
  addedtransactions_.Mutable(index)->assign(std::move(value));
}
inline void TMProposeSet::set_addedtransactions(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  addedtransactions_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:protocol.TMProposeSet.addedTransactions)
}
inline void TMProposeSet::set_addedtransactions(int index, const void* value, size_t size) {
  addedtransactions_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:protocol.TMProposeSet.addedTransactions)
}
inline std::string* TMProposeSet::_internal_add_addedtransactions() {
  return addedtransactions_.Add();
}
inline void TMProposeSet::add_addedtransactions(const std::string& value) {
  addedtransactions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:protocol.TMProposeSet.addedTransactions)
}
inline void TMProposeSet::add_addedtransactions(std::string&& value) {
  addedtransactions_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:protocol.TMProposeSet.addedTransactions)
}
inline void TMProposeSet::add_addedtransactions(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  addedtransactions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:protocol.TMProposeSet.addedTransactions)
}
inline void TMProposeSet::add_addedtransactions(const void* value, size_t size) {
  addedtransactions_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:protocol.TMProposeSet.addedTransactions)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TMProposeSet::addedtransactions() const {
  // @@protoc_insertion_point(field_list:protocol.TMProposeSet.addedTransactions)
  return addedtransactions_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TMProposeSet::mutable_addedtransactions() {
  // @@protoc_insertion_point(field_mutable_list:protocol.TMProposeSet.addedTransactions)
  return &addedtransactions_;
}

// repeated bytes removedTransactions = 11;
inline int TMProposeSet::_internal_removedtransactions_size() const {
  return removedtransactions_.size();
}
inline int TMProposeSet::removedtransactions_size() const {
  return _internal_removedtransactions_size();
}
inline void TMProposeSet::clear_removedtransactions() {
  removedtransactions_.Clear();
}
inline std::string* TMProposeSet::add_removedtransactions() {
  // @@protoc_insertion_point(field_add_mutable:protocol.TMProposeSet.removedTransactions)
  return _internal_add_removedtransactions();
}
inline const std::string& TMProposeSet::_internal_removedtransactions(int index) const {
  return removedtransactions_.Get(index);
}
inline const std::string& TMProposeSet::removedtransactions(int index) const {
  // @@protoc_insertion_point(field_get:protocol.TMProposeSet.removedTransactions)
  return _internal_removedtransactions(index);
}
inline std::string* TMProposeSet::mutable_removedtransactions(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.TMProposeSet.removedTransactions)
  return removedtransactions_.Mutable(index);
}
inline void TMProposeSet::set_removedtransactions(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:protocol.TMProposeSet.removedTransactions)
  removedtransactions_.Mutable(index)->assign(value);
}
inline void TMProposeSet::set_removedtransactions(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:protocol.TMProposeSet.removedTransactions)
  removedtransactions_.Mutable(index)->assign(std::move(value));
}
inline void TMProposeSet::set_removedtransactions(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  removedtransactions_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:protocol.TMProposeSet.removedTransactions)
}
inline void TMProposeSet::set_removedtransactions(int index, const void* value, size_t size) {
  removedtransactions_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:protocol.TMProposeSet.removedTransactions)
}
inline std::string* TMProposeSet::_internal_add_removedtransactions() {
  return removedtransactions_.Add();
}
inline void TMProposeSet::add_removedtransactions(const std::string& value) {
  removedtransactions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:protocol.TMProposeSet.removedTransactions)
}
inline void TMProposeSet::add_removedtransactions(std::string&& value) {
  removedtransactions_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:protocol.TMProposeSet.removedTransactions)
}
inline void TMProposeSet::add_removedtransactions(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  removedtransactions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:protocol.TMProposeSet.removedTransactions)
}
inline void TMProposeSet::add_removedtransactions(const void* value, size_t size) {
  removedtransactions_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:protocol.TMProposeSet.removedTransactions)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TMProposeSet::removedtransactions() const {
  // @@protoc_insertion_point(field_list:protocol.TMProposeSet.removedTransactions)
  return removedtransactions_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TMProposeSet::mutable_removedtransactions() {
  // @@protoc_insertion_point(field_mutable_list:protocol.TMProposeSet.removedTransactions)
  return &removedtransactions_;
}

// optional bool checkedSignature = 7 [deprecated = true];
inline bool TMProposeSet::_internal_has_checkedsignature() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool TMProposeSet::has_checkedsignature() const {
  return _internal_has_checkedsignature();
}
inline void TMProposeSet::clear_checkedsignature() {
  checkedsignature_ = false;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool TMProposeSet::_internal_checkedsignature() const {
  return checkedsignature_;
}
inline bool TMProposeSet::checkedsignature() const {
  // @@protoc_insertion_point(field_get:protocol.TMProposeSet.checkedSignature)
  return _internal_checkedsignature();
}
inline void TMProposeSet::_internal_set_checkedsignature(bool value) {
  _has_bits_[0] |= 0x00000040u;
  checkedsignature_ = value;
}
inline void TMProposeSet::set_checkedsignature(bool value) {
  _internal_set_checkedsignature(value);
  // @@protoc_insertion_point(field_set:protocol.TMProposeSet.checkedSignature)
}

// optional uint32 hops = 12 [deprecated = true];
inline bool TMProposeSet::_internal_has_hops() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool TMProposeSet::has_hops() const {
  return _internal_has_hops();
}
inline void TMProposeSet::clear_hops() {
  hops_ = 0u;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TMProposeSet::_internal_hops() const {
  return hops_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TMProposeSet::hops() const {
  // @@protoc_insertion_point(field_get:protocol.TMProposeSet.hops)
  return _internal_hops();
}
inline void TMProposeSet::_internal_set_hops(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000080u;
  hops_ = value;
}
inline void TMProposeSet::set_hops(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_hops(value);
  // @@protoc_insertion_point(field_set:protocol.TMProposeSet.hops)
}

// -------------------------------------------------------------------

// TMHaveTransactionSet

// required .protocol.TxSetStatus status = 1;
inline bool TMHaveTransactionSet::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TMHaveTransactionSet::has_status() const {
  return _internal_has_status();
}
inline void TMHaveTransactionSet::clear_status() {
  status_ = 1;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::protocol::TxSetStatus TMHaveTransactionSet::_internal_status() const {
  return static_cast< ::protocol::TxSetStatus >(status_);
}
inline ::protocol::TxSetStatus TMHaveTransactionSet::status() const {
  // @@protoc_insertion_point(field_get:protocol.TMHaveTransactionSet.status)
  return _internal_status();
}
inline void TMHaveTransactionSet::_internal_set_status(::protocol::TxSetStatus value) {
  assert(::protocol::TxSetStatus_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  status_ = value;
}
inline void TMHaveTransactionSet::set_status(::protocol::TxSetStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:protocol.TMHaveTransactionSet.status)
}

// required bytes hash = 2;
inline bool TMHaveTransactionSet::_internal_has_hash() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TMHaveTransactionSet::has_hash() const {
  return _internal_has_hash();
}
inline void TMHaveTransactionSet::clear_hash() {
  hash_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TMHaveTransactionSet::hash() const {
  // @@protoc_insertion_point(field_get:protocol.TMHaveTransactionSet.hash)
  return _internal_hash();
}
inline void TMHaveTransactionSet::set_hash(const std::string& value) {
  _internal_set_hash(value);
  // @@protoc_insertion_point(field_set:protocol.TMHaveTransactionSet.hash)
}
inline std::string* TMHaveTransactionSet::mutable_hash() {
  // @@protoc_insertion_point(field_mutable:protocol.TMHaveTransactionSet.hash)
  return _internal_mutable_hash();
}
inline const std::string& TMHaveTransactionSet::_internal_hash() const {
  return hash_.Get();
}
inline void TMHaveTransactionSet::_internal_set_hash(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  hash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void TMHaveTransactionSet::set_hash(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  hash_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:protocol.TMHaveTransactionSet.hash)
}
inline void TMHaveTransactionSet::set_hash(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  hash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:protocol.TMHaveTransactionSet.hash)
}
inline void TMHaveTransactionSet::set_hash(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  hash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:protocol.TMHaveTransactionSet.hash)
}
inline std::string* TMHaveTransactionSet::_internal_mutable_hash() {
  _has_bits_[0] |= 0x00000001u;
  return hash_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* TMHaveTransactionSet::release_hash() {
  // @@protoc_insertion_point(field_release:protocol.TMHaveTransactionSet.hash)
  if (!_internal_has_hash()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return hash_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void TMHaveTransactionSet::set_allocated_hash(std::string* hash) {
  if (hash != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  hash_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), hash,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:protocol.TMHaveTransactionSet.hash)
}
inline std::string* TMHaveTransactionSet::unsafe_arena_release_hash() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protocol.TMHaveTransactionSet.hash)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return hash_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void TMHaveTransactionSet::unsafe_arena_set_allocated_hash(
    std::string* hash) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (hash != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  hash_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      hash, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.TMHaveTransactionSet.hash)
}

// -------------------------------------------------------------------

// TMValidatorList

// required bytes manifest = 1;
inline bool TMValidatorList::_internal_has_manifest() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TMValidatorList::has_manifest() const {
  return _internal_has_manifest();
}
inline void TMValidatorList::clear_manifest() {
  manifest_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TMValidatorList::manifest() const {
  // @@protoc_insertion_point(field_get:protocol.TMValidatorList.manifest)
  return _internal_manifest();
}
inline void TMValidatorList::set_manifest(const std::string& value) {
  _internal_set_manifest(value);
  // @@protoc_insertion_point(field_set:protocol.TMValidatorList.manifest)
}
inline std::string* TMValidatorList::mutable_manifest() {
  // @@protoc_insertion_point(field_mutable:protocol.TMValidatorList.manifest)
  return _internal_mutable_manifest();
}
inline const std::string& TMValidatorList::_internal_manifest() const {
  return manifest_.Get();
}
inline void TMValidatorList::_internal_set_manifest(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  manifest_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void TMValidatorList::set_manifest(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  manifest_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:protocol.TMValidatorList.manifest)
}
inline void TMValidatorList::set_manifest(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  manifest_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:protocol.TMValidatorList.manifest)
}
inline void TMValidatorList::set_manifest(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  manifest_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:protocol.TMValidatorList.manifest)
}
inline std::string* TMValidatorList::_internal_mutable_manifest() {
  _has_bits_[0] |= 0x00000001u;
  return manifest_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* TMValidatorList::release_manifest() {
  // @@protoc_insertion_point(field_release:protocol.TMValidatorList.manifest)
  if (!_internal_has_manifest()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return manifest_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void TMValidatorList::set_allocated_manifest(std::string* manifest) {
  if (manifest != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  manifest_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), manifest,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:protocol.TMValidatorList.manifest)
}
inline std::string* TMValidatorList::unsafe_arena_release_manifest() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protocol.TMValidatorList.manifest)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return manifest_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void TMValidatorList::unsafe_arena_set_allocated_manifest(
    std::string* manifest) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (manifest != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  manifest_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      manifest, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.TMValidatorList.manifest)
}

// required bytes blob = 2;
inline bool TMValidatorList::_internal_has_blob() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TMValidatorList::has_blob() const {
  return _internal_has_blob();
}
inline void TMValidatorList::clear_blob() {
  blob_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& TMValidatorList::blob() const {
  // @@protoc_insertion_point(field_get:protocol.TMValidatorList.blob)
  return _internal_blob();
}
inline void TMValidatorList::set_blob(const std::string& value) {
  _internal_set_blob(value);
  // @@protoc_insertion_point(field_set:protocol.TMValidatorList.blob)
}
inline std::string* TMValidatorList::mutable_blob() {
  // @@protoc_insertion_point(field_mutable:protocol.TMValidatorList.blob)
  return _internal_mutable_blob();
}
inline const std::string& TMValidatorList::_internal_blob() const {
  return blob_.Get();
}
inline void TMValidatorList::_internal_set_blob(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  blob_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void TMValidatorList::set_blob(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  blob_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:protocol.TMValidatorList.blob)
}
inline void TMValidatorList::set_blob(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  blob_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:protocol.TMValidatorList.blob)
}
inline void TMValidatorList::set_blob(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  blob_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:protocol.TMValidatorList.blob)
}
inline std::string* TMValidatorList::_internal_mutable_blob() {
  _has_bits_[0] |= 0x00000002u;
  return blob_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* TMValidatorList::release_blob() {
  // @@protoc_insertion_point(field_release:protocol.TMValidatorList.blob)
  if (!_internal_has_blob()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return blob_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void TMValidatorList::set_allocated_blob(std::string* blob) {
  if (blob != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  blob_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), blob,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:protocol.TMValidatorList.blob)
}
inline std::string* TMValidatorList::unsafe_arena_release_blob() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protocol.TMValidatorList.blob)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000002u;
  return blob_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void TMValidatorList::unsafe_arena_set_allocated_blob(
    std::string* blob) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (blob != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  blob_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      blob, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.TMValidatorList.blob)
}

// required bytes signature = 3;
inline bool TMValidatorList::_internal_has_signature() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TMValidatorList::has_signature() const {
  return _internal_has_signature();
}
inline void TMValidatorList::clear_signature() {
  signature_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& TMValidatorList::signature() const {
  // @@protoc_insertion_point(field_get:protocol.TMValidatorList.signature)
  return _internal_signature();
}
inline void TMValidatorList::set_signature(const std::string& value) {
  _internal_set_signature(value);
  // @@protoc_insertion_point(field_set:protocol.TMValidatorList.signature)
}
inline std::string* TMValidatorList::mutable_signature() {
  // @@protoc_insertion_point(field_mutable:protocol.TMValidatorList.signature)
  return _internal_mutable_signature();
}
inline const std::string& TMValidatorList::_internal_signature() const {
  return signature_.Get();
}
inline void TMValidatorList::_internal_set_signature(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  signature_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void TMValidatorList::set_signature(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  signature_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:protocol.TMValidatorList.signature)
}
inline void TMValidatorList::set_signature(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  signature_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:protocol.TMValidatorList.signature)
}
inline void TMValidatorList::set_signature(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000004u;
  signature_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:protocol.TMValidatorList.signature)
}
inline std::string* TMValidatorList::_internal_mutable_signature() {
  _has_bits_[0] |= 0x00000004u;
  return signature_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* TMValidatorList::release_signature() {
  // @@protoc_insertion_point(field_release:protocol.TMValidatorList.signature)
  if (!_internal_has_signature()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return signature_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void TMValidatorList::set_allocated_signature(std::string* signature) {
  if (signature != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  signature_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), signature,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:protocol.TMValidatorList.signature)
}
inline std::string* TMValidatorList::unsafe_arena_release_signature() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protocol.TMValidatorList.signature)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000004u;
  return signature_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void TMValidatorList::unsafe_arena_set_allocated_signature(
    std::string* signature) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (signature != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  signature_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      signature, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.TMValidatorList.signature)
}

// required uint32 version = 4;
inline bool TMValidatorList::_internal_has_version() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool TMValidatorList::has_version() const {
  return _internal_has_version();
}
inline void TMValidatorList::clear_version() {
  version_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TMValidatorList::_internal_version() const {
  return version_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TMValidatorList::version() const {
  // @@protoc_insertion_point(field_get:protocol.TMValidatorList.version)
  return _internal_version();
}
inline void TMValidatorList::_internal_set_version(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  version_ = value;
}
inline void TMValidatorList::set_version(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:protocol.TMValidatorList.version)
}

// -------------------------------------------------------------------

// ValidatorBlobInfo

// optional bytes manifest = 1;
inline bool ValidatorBlobInfo::_internal_has_manifest() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ValidatorBlobInfo::has_manifest() const {
  return _internal_has_manifest();
}
inline void ValidatorBlobInfo::clear_manifest() {
  manifest_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ValidatorBlobInfo::manifest() const {
  // @@protoc_insertion_point(field_get:protocol.ValidatorBlobInfo.manifest)
  return _internal_manifest();
}
inline void ValidatorBlobInfo::set_manifest(const std::string& value) {
  _internal_set_manifest(value);
  // @@protoc_insertion_point(field_set:protocol.ValidatorBlobInfo.manifest)
}
inline std::string* ValidatorBlobInfo::mutable_manifest() {
  // @@protoc_insertion_point(field_mutable:protocol.ValidatorBlobInfo.manifest)
  return _internal_mutable_manifest();
}
inline const std::string& ValidatorBlobInfo::_internal_manifest() const {
  return manifest_.Get();
}
inline void ValidatorBlobInfo::_internal_set_manifest(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  manifest_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ValidatorBlobInfo::set_manifest(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  manifest_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:protocol.ValidatorBlobInfo.manifest)
}
inline void ValidatorBlobInfo::set_manifest(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  manifest_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:protocol.ValidatorBlobInfo.manifest)
}
inline void ValidatorBlobInfo::set_manifest(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  manifest_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:protocol.ValidatorBlobInfo.manifest)
}
inline std::string* ValidatorBlobInfo::_internal_mutable_manifest() {
  _has_bits_[0] |= 0x00000001u;
  return manifest_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ValidatorBlobInfo::release_manifest() {
  // @@protoc_insertion_point(field_release:protocol.ValidatorBlobInfo.manifest)
  if (!_internal_has_manifest()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return manifest_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ValidatorBlobInfo::set_allocated_manifest(std::string* manifest) {
  if (manifest != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  manifest_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), manifest,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:protocol.ValidatorBlobInfo.manifest)
}
inline std::string* ValidatorBlobInfo::unsafe_arena_release_manifest() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protocol.ValidatorBlobInfo.manifest)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return manifest_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void ValidatorBlobInfo::unsafe_arena_set_allocated_manifest(
    std::string* manifest) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (manifest != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  manifest_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      manifest, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.ValidatorBlobInfo.manifest)
}

// required bytes blob = 2;
inline bool ValidatorBlobInfo::_internal_has_blob() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ValidatorBlobInfo::has_blob() const {
  return _internal_has_blob();
}
inline void ValidatorBlobInfo::clear_blob() {
  blob_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ValidatorBlobInfo::blob() const {
  // @@protoc_insertion_point(field_get:protocol.ValidatorBlobInfo.blob)
  return _internal_blob();
}
inline void ValidatorBlobInfo::set_blob(const std::string& value) {
  _internal_set_blob(value);
  // @@protoc_insertion_point(field_set:protocol.ValidatorBlobInfo.blob)
}
inline std::string* ValidatorBlobInfo::mutable_blob() {
  // @@protoc_insertion_point(field_mutable:protocol.ValidatorBlobInfo.blob)
  return _internal_mutable_blob();
}
inline const std::string& ValidatorBlobInfo::_internal_blob() const {
  return blob_.Get();
}
inline void ValidatorBlobInfo::_internal_set_blob(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  blob_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ValidatorBlobInfo::set_blob(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  blob_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:protocol.ValidatorBlobInfo.blob)
}
inline void ValidatorBlobInfo::set_blob(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  blob_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:protocol.ValidatorBlobInfo.blob)
}
inline void ValidatorBlobInfo::set_blob(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  blob_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:protocol.ValidatorBlobInfo.blob)
}
inline std::string* ValidatorBlobInfo::_internal_mutable_blob() {
  _has_bits_[0] |= 0x00000002u;
  return blob_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ValidatorBlobInfo::release_blob() {
  // @@protoc_insertion_point(field_release:protocol.ValidatorBlobInfo.blob)
  if (!_internal_has_blob()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return blob_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ValidatorBlobInfo::set_allocated_blob(std::string* blob) {
  if (blob != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  blob_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), blob,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:protocol.ValidatorBlobInfo.blob)
}
inline std::string* ValidatorBlobInfo::unsafe_arena_release_blob() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protocol.ValidatorBlobInfo.blob)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000002u;
  return blob_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void ValidatorBlobInfo::unsafe_arena_set_allocated_blob(
    std::string* blob) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (blob != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  blob_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      blob, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.ValidatorBlobInfo.blob)
}

// required bytes signature = 3;
inline bool ValidatorBlobInfo::_internal_has_signature() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ValidatorBlobInfo::has_signature() const {
  return _internal_has_signature();
}
inline void ValidatorBlobInfo::clear_signature() {
  signature_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ValidatorBlobInfo::signature() const {
  // @@protoc_insertion_point(field_get:protocol.ValidatorBlobInfo.signature)
  return _internal_signature();
}
inline void ValidatorBlobInfo::set_signature(const std::string& value) {
  _internal_set_signature(value);
  // @@protoc_insertion_point(field_set:protocol.ValidatorBlobInfo.signature)
}
inline std::string* ValidatorBlobInfo::mutable_signature() {
  // @@protoc_insertion_point(field_mutable:protocol.ValidatorBlobInfo.signature)
  return _internal_mutable_signature();
}
inline const std::string& ValidatorBlobInfo::_internal_signature() const {
  return signature_.Get();
}
inline void ValidatorBlobInfo::_internal_set_signature(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  signature_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ValidatorBlobInfo::set_signature(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  signature_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:protocol.ValidatorBlobInfo.signature)
}
inline void ValidatorBlobInfo::set_signature(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  signature_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:protocol.ValidatorBlobInfo.signature)
}
inline void ValidatorBlobInfo::set_signature(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000004u;
  signature_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:protocol.ValidatorBlobInfo.signature)
}
inline std::string* ValidatorBlobInfo::_internal_mutable_signature() {
  _has_bits_[0] |= 0x00000004u;
  return signature_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ValidatorBlobInfo::release_signature() {
  // @@protoc_insertion_point(field_release:protocol.ValidatorBlobInfo.signature)
  if (!_internal_has_signature()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return signature_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ValidatorBlobInfo::set_allocated_signature(std::string* signature) {
  if (signature != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  signature_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), signature,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:protocol.ValidatorBlobInfo.signature)
}
inline std::string* ValidatorBlobInfo::unsafe_arena_release_signature() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protocol.ValidatorBlobInfo.signature)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000004u;
  return signature_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void ValidatorBlobInfo::unsafe_arena_set_allocated_signature(
    std::string* signature) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (signature != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  signature_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      signature, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.ValidatorBlobInfo.signature)
}

// -------------------------------------------------------------------

// TMValidatorListCollection

// required uint32 version = 1;
inline bool TMValidatorListCollection::_internal_has_version() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TMValidatorListCollection::has_version() const {
  return _internal_has_version();
}
inline void TMValidatorListCollection::clear_version() {
  version_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TMValidatorListCollection::_internal_version() const {
  return version_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TMValidatorListCollection::version() const {
  // @@protoc_insertion_point(field_get:protocol.TMValidatorListCollection.version)
  return _internal_version();
}
inline void TMValidatorListCollection::_internal_set_version(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  version_ = value;
}
inline void TMValidatorListCollection::set_version(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:protocol.TMValidatorListCollection.version)
}

// required bytes manifest = 2;
inline bool TMValidatorListCollection::_internal_has_manifest() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TMValidatorListCollection::has_manifest() const {
  return _internal_has_manifest();
}
inline void TMValidatorListCollection::clear_manifest() {
  manifest_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TMValidatorListCollection::manifest() const {
  // @@protoc_insertion_point(field_get:protocol.TMValidatorListCollection.manifest)
  return _internal_manifest();
}
inline void TMValidatorListCollection::set_manifest(const std::string& value) {
  _internal_set_manifest(value);
  // @@protoc_insertion_point(field_set:protocol.TMValidatorListCollection.manifest)
}
inline std::string* TMValidatorListCollection::mutable_manifest() {
  // @@protoc_insertion_point(field_mutable:protocol.TMValidatorListCollection.manifest)
  return _internal_mutable_manifest();
}
inline const std::string& TMValidatorListCollection::_internal_manifest() const {
  return manifest_.Get();
}
inline void TMValidatorListCollection::_internal_set_manifest(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  manifest_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void TMValidatorListCollection::set_manifest(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  manifest_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:protocol.TMValidatorListCollection.manifest)
}
inline void TMValidatorListCollection::set_manifest(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  manifest_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:protocol.TMValidatorListCollection.manifest)
}
inline void TMValidatorListCollection::set_manifest(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  manifest_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:protocol.TMValidatorListCollection.manifest)
}
inline std::string* TMValidatorListCollection::_internal_mutable_manifest() {
  _has_bits_[0] |= 0x00000001u;
  return manifest_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* TMValidatorListCollection::release_manifest() {
  // @@protoc_insertion_point(field_release:protocol.TMValidatorListCollection.manifest)
  if (!_internal_has_manifest()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return manifest_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void TMValidatorListCollection::set_allocated_manifest(std::string* manifest) {
  if (manifest != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  manifest_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), manifest,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:protocol.TMValidatorListCollection.manifest)
}
inline std::string* TMValidatorListCollection::unsafe_arena_release_manifest() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protocol.TMValidatorListCollection.manifest)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return manifest_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void TMValidatorListCollection::unsafe_arena_set_allocated_manifest(
    std::string* manifest) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (manifest != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  manifest_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      manifest, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.TMValidatorListCollection.manifest)
}

// repeated .protocol.ValidatorBlobInfo blobs = 3;
inline int TMValidatorListCollection::_internal_blobs_size() const {
  return blobs_.size();
}
inline int TMValidatorListCollection::blobs_size() const {
  return _internal_blobs_size();
}
inline void TMValidatorListCollection::clear_blobs() {
  blobs_.Clear();
}
inline ::protocol::ValidatorBlobInfo* TMValidatorListCollection::mutable_blobs(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.TMValidatorListCollection.blobs)
  return blobs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::ValidatorBlobInfo >*
TMValidatorListCollection::mutable_blobs() {
  // @@protoc_insertion_point(field_mutable_list:protocol.TMValidatorListCollection.blobs)
  return &blobs_;
}
inline const ::protocol::ValidatorBlobInfo& TMValidatorListCollection::_internal_blobs(int index) const {
  return blobs_.Get(index);
}
inline const ::protocol::ValidatorBlobInfo& TMValidatorListCollection::blobs(int index) const {
  // @@protoc_insertion_point(field_get:protocol.TMValidatorListCollection.blobs)
  return _internal_blobs(index);
}
inline ::protocol::ValidatorBlobInfo* TMValidatorListCollection::_internal_add_blobs() {
  return blobs_.Add();
}
inline ::protocol::ValidatorBlobInfo* TMValidatorListCollection::add_blobs() {
  // @@protoc_insertion_point(field_add:protocol.TMValidatorListCollection.blobs)
  return _internal_add_blobs();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::ValidatorBlobInfo >&
TMValidatorListCollection::blobs() const {
  // @@protoc_insertion_point(field_list:protocol.TMValidatorListCollection.blobs)
  return blobs_;
}

// -------------------------------------------------------------------

// TMValidation

// required bytes validation = 1;
inline bool TMValidation::_internal_has_validation() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TMValidation::has_validation() const {
  return _internal_has_validation();
}
inline void TMValidation::clear_validation() {
  validation_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TMValidation::validation() const {
  // @@protoc_insertion_point(field_get:protocol.TMValidation.validation)
  return _internal_validation();
}
inline void TMValidation::set_validation(const std::string& value) {
  _internal_set_validation(value);
  // @@protoc_insertion_point(field_set:protocol.TMValidation.validation)
}
inline std::string* TMValidation::mutable_validation() {
  // @@protoc_insertion_point(field_mutable:protocol.TMValidation.validation)
  return _internal_mutable_validation();
}
inline const std::string& TMValidation::_internal_validation() const {
  return validation_.Get();
}
inline void TMValidation::_internal_set_validation(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  validation_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void TMValidation::set_validation(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  validation_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:protocol.TMValidation.validation)
}
inline void TMValidation::set_validation(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  validation_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:protocol.TMValidation.validation)
}
inline void TMValidation::set_validation(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  validation_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:protocol.TMValidation.validation)
}
inline std::string* TMValidation::_internal_mutable_validation() {
  _has_bits_[0] |= 0x00000001u;
  return validation_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* TMValidation::release_validation() {
  // @@protoc_insertion_point(field_release:protocol.TMValidation.validation)
  if (!_internal_has_validation()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return validation_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void TMValidation::set_allocated_validation(std::string* validation) {
  if (validation != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  validation_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), validation,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:protocol.TMValidation.validation)
}
inline std::string* TMValidation::unsafe_arena_release_validation() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protocol.TMValidation.validation)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return validation_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void TMValidation::unsafe_arena_set_allocated_validation(
    std::string* validation) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (validation != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  validation_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      validation, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.TMValidation.validation)
}

// optional bool checkedSignature = 2 [deprecated = true];
inline bool TMValidation::_internal_has_checkedsignature() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TMValidation::has_checkedsignature() const {
  return _internal_has_checkedsignature();
}
inline void TMValidation::clear_checkedsignature() {
  checkedsignature_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool TMValidation::_internal_checkedsignature() const {
  return checkedsignature_;
}
inline bool TMValidation::checkedsignature() const {
  // @@protoc_insertion_point(field_get:protocol.TMValidation.checkedSignature)
  return _internal_checkedsignature();
}
inline void TMValidation::_internal_set_checkedsignature(bool value) {
  _has_bits_[0] |= 0x00000002u;
  checkedsignature_ = value;
}
inline void TMValidation::set_checkedsignature(bool value) {
  _internal_set_checkedsignature(value);
  // @@protoc_insertion_point(field_set:protocol.TMValidation.checkedSignature)
}

// optional uint32 hops = 3 [deprecated = true];
inline bool TMValidation::_internal_has_hops() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TMValidation::has_hops() const {
  return _internal_has_hops();
}
inline void TMValidation::clear_hops() {
  hops_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TMValidation::_internal_hops() const {
  return hops_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TMValidation::hops() const {
  // @@protoc_insertion_point(field_get:protocol.TMValidation.hops)
  return _internal_hops();
}
inline void TMValidation::_internal_set_hops(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  hops_ = value;
}
inline void TMValidation::set_hops(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_hops(value);
  // @@protoc_insertion_point(field_set:protocol.TMValidation.hops)
}

// -------------------------------------------------------------------

// TMEndpoints_TMEndpointv2

// required string endpoint = 1;
inline bool TMEndpoints_TMEndpointv2::_internal_has_endpoint() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TMEndpoints_TMEndpointv2::has_endpoint() const {
  return _internal_has_endpoint();
}
inline void TMEndpoints_TMEndpointv2::clear_endpoint() {
  endpoint_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TMEndpoints_TMEndpointv2::endpoint() const {
  // @@protoc_insertion_point(field_get:protocol.TMEndpoints.TMEndpointv2.endpoint)
  return _internal_endpoint();
}
inline void TMEndpoints_TMEndpointv2::set_endpoint(const std::string& value) {
  _internal_set_endpoint(value);
  // @@protoc_insertion_point(field_set:protocol.TMEndpoints.TMEndpointv2.endpoint)
}
inline std::string* TMEndpoints_TMEndpointv2::mutable_endpoint() {
  // @@protoc_insertion_point(field_mutable:protocol.TMEndpoints.TMEndpointv2.endpoint)
  return _internal_mutable_endpoint();
}
inline const std::string& TMEndpoints_TMEndpointv2::_internal_endpoint() const {
  return endpoint_.Get();
}
inline void TMEndpoints_TMEndpointv2::_internal_set_endpoint(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  endpoint_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void TMEndpoints_TMEndpointv2::set_endpoint(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  endpoint_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:protocol.TMEndpoints.TMEndpointv2.endpoint)
}
inline void TMEndpoints_TMEndpointv2::set_endpoint(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  endpoint_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:protocol.TMEndpoints.TMEndpointv2.endpoint)
}
inline void TMEndpoints_TMEndpointv2::set_endpoint(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  endpoint_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:protocol.TMEndpoints.TMEndpointv2.endpoint)
}
inline std::string* TMEndpoints_TMEndpointv2::_internal_mutable_endpoint() {
  _has_bits_[0] |= 0x00000001u;
  return endpoint_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* TMEndpoints_TMEndpointv2::release_endpoint() {
  // @@protoc_insertion_point(field_release:protocol.TMEndpoints.TMEndpointv2.endpoint)
  if (!_internal_has_endpoint()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return endpoint_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void TMEndpoints_TMEndpointv2::set_allocated_endpoint(std::string* endpoint) {
  if (endpoint != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  endpoint_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), endpoint,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:protocol.TMEndpoints.TMEndpointv2.endpoint)
}
inline std::string* TMEndpoints_TMEndpointv2::unsafe_arena_release_endpoint() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protocol.TMEndpoints.TMEndpointv2.endpoint)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return endpoint_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void TMEndpoints_TMEndpointv2::unsafe_arena_set_allocated_endpoint(
    std::string* endpoint) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (endpoint != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  endpoint_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      endpoint, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.TMEndpoints.TMEndpointv2.endpoint)
}

// required uint32 hops = 2;
inline bool TMEndpoints_TMEndpointv2::_internal_has_hops() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TMEndpoints_TMEndpointv2::has_hops() const {
  return _internal_has_hops();
}
inline void TMEndpoints_TMEndpointv2::clear_hops() {
  hops_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TMEndpoints_TMEndpointv2::_internal_hops() const {
  return hops_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TMEndpoints_TMEndpointv2::hops() const {
  // @@protoc_insertion_point(field_get:protocol.TMEndpoints.TMEndpointv2.hops)
  return _internal_hops();
}
inline void TMEndpoints_TMEndpointv2::_internal_set_hops(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  hops_ = value;
}
inline void TMEndpoints_TMEndpointv2::set_hops(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_hops(value);
  // @@protoc_insertion_point(field_set:protocol.TMEndpoints.TMEndpointv2.hops)
}

// -------------------------------------------------------------------

// TMEndpoints

// required uint32 version = 1;
inline bool TMEndpoints::_internal_has_version() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TMEndpoints::has_version() const {
  return _internal_has_version();
}
inline void TMEndpoints::clear_version() {
  version_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TMEndpoints::_internal_version() const {
  return version_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TMEndpoints::version() const {
  // @@protoc_insertion_point(field_get:protocol.TMEndpoints.version)
  return _internal_version();
}
inline void TMEndpoints::_internal_set_version(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  version_ = value;
}
inline void TMEndpoints::set_version(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:protocol.TMEndpoints.version)
}

// repeated .protocol.TMEndpoints.TMEndpointv2 endpoints_v2 = 3;
inline int TMEndpoints::_internal_endpoints_v2_size() const {
  return endpoints_v2_.size();
}
inline int TMEndpoints::endpoints_v2_size() const {
  return _internal_endpoints_v2_size();
}
inline void TMEndpoints::clear_endpoints_v2() {
  endpoints_v2_.Clear();
}
inline ::protocol::TMEndpoints_TMEndpointv2* TMEndpoints::mutable_endpoints_v2(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.TMEndpoints.endpoints_v2)
  return endpoints_v2_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::TMEndpoints_TMEndpointv2 >*
TMEndpoints::mutable_endpoints_v2() {
  // @@protoc_insertion_point(field_mutable_list:protocol.TMEndpoints.endpoints_v2)
  return &endpoints_v2_;
}
inline const ::protocol::TMEndpoints_TMEndpointv2& TMEndpoints::_internal_endpoints_v2(int index) const {
  return endpoints_v2_.Get(index);
}
inline const ::protocol::TMEndpoints_TMEndpointv2& TMEndpoints::endpoints_v2(int index) const {
  // @@protoc_insertion_point(field_get:protocol.TMEndpoints.endpoints_v2)
  return _internal_endpoints_v2(index);
}
inline ::protocol::TMEndpoints_TMEndpointv2* TMEndpoints::_internal_add_endpoints_v2() {
  return endpoints_v2_.Add();
}
inline ::protocol::TMEndpoints_TMEndpointv2* TMEndpoints::add_endpoints_v2() {
  // @@protoc_insertion_point(field_add:protocol.TMEndpoints.endpoints_v2)
  return _internal_add_endpoints_v2();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::TMEndpoints_TMEndpointv2 >&
TMEndpoints::endpoints_v2() const {
  // @@protoc_insertion_point(field_list:protocol.TMEndpoints.endpoints_v2)
  return endpoints_v2_;
}

// -------------------------------------------------------------------

// TMIndexedObject

// optional bytes hash = 1;
inline bool TMIndexedObject::_internal_has_hash() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TMIndexedObject::has_hash() const {
  return _internal_has_hash();
}
inline void TMIndexedObject::clear_hash() {
  hash_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TMIndexedObject::hash() const {
  // @@protoc_insertion_point(field_get:protocol.TMIndexedObject.hash)
  return _internal_hash();
}
inline void TMIndexedObject::set_hash(const std::string& value) {
  _internal_set_hash(value);
  // @@protoc_insertion_point(field_set:protocol.TMIndexedObject.hash)
}
inline std::string* TMIndexedObject::mutable_hash() {
  // @@protoc_insertion_point(field_mutable:protocol.TMIndexedObject.hash)
  return _internal_mutable_hash();
}
inline const std::string& TMIndexedObject::_internal_hash() const {
  return hash_.Get();
}
inline void TMIndexedObject::_internal_set_hash(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  hash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void TMIndexedObject::set_hash(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  hash_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:protocol.TMIndexedObject.hash)
}
inline void TMIndexedObject::set_hash(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  hash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:protocol.TMIndexedObject.hash)
}
inline void TMIndexedObject::set_hash(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  hash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:protocol.TMIndexedObject.hash)
}
inline std::string* TMIndexedObject::_internal_mutable_hash() {
  _has_bits_[0] |= 0x00000001u;
  return hash_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* TMIndexedObject::release_hash() {
  // @@protoc_insertion_point(field_release:protocol.TMIndexedObject.hash)
  if (!_internal_has_hash()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return hash_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void TMIndexedObject::set_allocated_hash(std::string* hash) {
  if (hash != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  hash_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), hash,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:protocol.TMIndexedObject.hash)
}
inline std::string* TMIndexedObject::unsafe_arena_release_hash() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protocol.TMIndexedObject.hash)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return hash_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void TMIndexedObject::unsafe_arena_set_allocated_hash(
    std::string* hash) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (hash != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  hash_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      hash, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.TMIndexedObject.hash)
}

// optional bytes nodeID = 2;
inline bool TMIndexedObject::_internal_has_nodeid() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TMIndexedObject::has_nodeid() const {
  return _internal_has_nodeid();
}
inline void TMIndexedObject::clear_nodeid() {
  nodeid_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& TMIndexedObject::nodeid() const {
  // @@protoc_insertion_point(field_get:protocol.TMIndexedObject.nodeID)
  return _internal_nodeid();
}
inline void TMIndexedObject::set_nodeid(const std::string& value) {
  _internal_set_nodeid(value);
  // @@protoc_insertion_point(field_set:protocol.TMIndexedObject.nodeID)
}
inline std::string* TMIndexedObject::mutable_nodeid() {
  // @@protoc_insertion_point(field_mutable:protocol.TMIndexedObject.nodeID)
  return _internal_mutable_nodeid();
}
inline const std::string& TMIndexedObject::_internal_nodeid() const {
  return nodeid_.Get();
}
inline void TMIndexedObject::_internal_set_nodeid(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  nodeid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void TMIndexedObject::set_nodeid(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  nodeid_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:protocol.TMIndexedObject.nodeID)
}
inline void TMIndexedObject::set_nodeid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  nodeid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:protocol.TMIndexedObject.nodeID)
}
inline void TMIndexedObject::set_nodeid(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  nodeid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:protocol.TMIndexedObject.nodeID)
}
inline std::string* TMIndexedObject::_internal_mutable_nodeid() {
  _has_bits_[0] |= 0x00000002u;
  return nodeid_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* TMIndexedObject::release_nodeid() {
  // @@protoc_insertion_point(field_release:protocol.TMIndexedObject.nodeID)
  if (!_internal_has_nodeid()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return nodeid_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void TMIndexedObject::set_allocated_nodeid(std::string* nodeid) {
  if (nodeid != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  nodeid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), nodeid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:protocol.TMIndexedObject.nodeID)
}
inline std::string* TMIndexedObject::unsafe_arena_release_nodeid() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protocol.TMIndexedObject.nodeID)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000002u;
  return nodeid_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void TMIndexedObject::unsafe_arena_set_allocated_nodeid(
    std::string* nodeid) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (nodeid != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  nodeid_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      nodeid, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.TMIndexedObject.nodeID)
}

// optional bytes index = 3;
inline bool TMIndexedObject::_internal_has_index() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TMIndexedObject::has_index() const {
  return _internal_has_index();
}
inline void TMIndexedObject::clear_index() {
  index_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& TMIndexedObject::index() const {
  // @@protoc_insertion_point(field_get:protocol.TMIndexedObject.index)
  return _internal_index();
}
inline void TMIndexedObject::set_index(const std::string& value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:protocol.TMIndexedObject.index)
}
inline std::string* TMIndexedObject::mutable_index() {
  // @@protoc_insertion_point(field_mutable:protocol.TMIndexedObject.index)
  return _internal_mutable_index();
}
inline const std::string& TMIndexedObject::_internal_index() const {
  return index_.Get();
}
inline void TMIndexedObject::_internal_set_index(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  index_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void TMIndexedObject::set_index(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  index_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:protocol.TMIndexedObject.index)
}
inline void TMIndexedObject::set_index(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  index_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:protocol.TMIndexedObject.index)
}
inline void TMIndexedObject::set_index(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000004u;
  index_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:protocol.TMIndexedObject.index)
}
inline std::string* TMIndexedObject::_internal_mutable_index() {
  _has_bits_[0] |= 0x00000004u;
  return index_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* TMIndexedObject::release_index() {
  // @@protoc_insertion_point(field_release:protocol.TMIndexedObject.index)
  if (!_internal_has_index()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return index_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void TMIndexedObject::set_allocated_index(std::string* index) {
  if (index != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  index_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), index,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:protocol.TMIndexedObject.index)
}
inline std::string* TMIndexedObject::unsafe_arena_release_index() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protocol.TMIndexedObject.index)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000004u;
  return index_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void TMIndexedObject::unsafe_arena_set_allocated_index(
    std::string* index) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (index != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  index_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      index, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.TMIndexedObject.index)
}

// optional bytes data = 4;
inline bool TMIndexedObject::_internal_has_data() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool TMIndexedObject::has_data() const {
  return _internal_has_data();
}
inline void TMIndexedObject::clear_data() {
  data_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& TMIndexedObject::data() const {
  // @@protoc_insertion_point(field_get:protocol.TMIndexedObject.data)
  return _internal_data();
}
inline void TMIndexedObject::set_data(const std::string& value) {
  _internal_set_data(value);
  // @@protoc_insertion_point(field_set:protocol.TMIndexedObject.data)
}
inline std::string* TMIndexedObject::mutable_data() {
  // @@protoc_insertion_point(field_mutable:protocol.TMIndexedObject.data)
  return _internal_mutable_data();
}
inline const std::string& TMIndexedObject::_internal_data() const {
  return data_.Get();
}
inline void TMIndexedObject::_internal_set_data(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void TMIndexedObject::set_data(std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  data_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:protocol.TMIndexedObject.data)
}
inline void TMIndexedObject::set_data(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:protocol.TMIndexedObject.data)
}
inline void TMIndexedObject::set_data(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000008u;
  data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:protocol.TMIndexedObject.data)
}
inline std::string* TMIndexedObject::_internal_mutable_data() {
  _has_bits_[0] |= 0x00000008u;
  return data_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* TMIndexedObject::release_data() {
  // @@protoc_insertion_point(field_release:protocol.TMIndexedObject.data)
  if (!_internal_has_data()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return data_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void TMIndexedObject::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:protocol.TMIndexedObject.data)
}
inline std::string* TMIndexedObject::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protocol.TMIndexedObject.data)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000008u;
  return data_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void TMIndexedObject::unsafe_arena_set_allocated_data(
    std::string* data) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (data != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  data_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      data, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.TMIndexedObject.data)
}

// optional uint32 ledgerSeq = 5;
inline bool TMIndexedObject::_internal_has_ledgerseq() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool TMIndexedObject::has_ledgerseq() const {
  return _internal_has_ledgerseq();
}
inline void TMIndexedObject::clear_ledgerseq() {
  ledgerseq_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TMIndexedObject::_internal_ledgerseq() const {
  return ledgerseq_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TMIndexedObject::ledgerseq() const {
  // @@protoc_insertion_point(field_get:protocol.TMIndexedObject.ledgerSeq)
  return _internal_ledgerseq();
}
inline void TMIndexedObject::_internal_set_ledgerseq(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  ledgerseq_ = value;
}
inline void TMIndexedObject::set_ledgerseq(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_ledgerseq(value);
  // @@protoc_insertion_point(field_set:protocol.TMIndexedObject.ledgerSeq)
}

// -------------------------------------------------------------------

// TMGetObjectByHash

// required .protocol.TMGetObjectByHash.ObjectType type = 1;
inline bool TMGetObjectByHash::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TMGetObjectByHash::has_type() const {
  return _internal_has_type();
}
inline void TMGetObjectByHash::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::protocol::TMGetObjectByHash_ObjectType TMGetObjectByHash::_internal_type() const {
  return static_cast< ::protocol::TMGetObjectByHash_ObjectType >(type_);
}
inline ::protocol::TMGetObjectByHash_ObjectType TMGetObjectByHash::type() const {
  // @@protoc_insertion_point(field_get:protocol.TMGetObjectByHash.type)
  return _internal_type();
}
inline void TMGetObjectByHash::_internal_set_type(::protocol::TMGetObjectByHash_ObjectType value) {
  assert(::protocol::TMGetObjectByHash_ObjectType_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  type_ = value;
}
inline void TMGetObjectByHash::set_type(::protocol::TMGetObjectByHash_ObjectType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:protocol.TMGetObjectByHash.type)
}

// required bool query = 2;
inline bool TMGetObjectByHash::_internal_has_query() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool TMGetObjectByHash::has_query() const {
  return _internal_has_query();
}
inline void TMGetObjectByHash::clear_query() {
  query_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool TMGetObjectByHash::_internal_query() const {
  return query_;
}
inline bool TMGetObjectByHash::query() const {
  // @@protoc_insertion_point(field_get:protocol.TMGetObjectByHash.query)
  return _internal_query();
}
inline void TMGetObjectByHash::_internal_set_query(bool value) {
  _has_bits_[0] |= 0x00000008u;
  query_ = value;
}
inline void TMGetObjectByHash::set_query(bool value) {
  _internal_set_query(value);
  // @@protoc_insertion_point(field_set:protocol.TMGetObjectByHash.query)
}

// optional uint32 seq = 3;
inline bool TMGetObjectByHash::_internal_has_seq() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TMGetObjectByHash::has_seq() const {
  return _internal_has_seq();
}
inline void TMGetObjectByHash::clear_seq() {
  seq_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TMGetObjectByHash::_internal_seq() const {
  return seq_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TMGetObjectByHash::seq() const {
  // @@protoc_insertion_point(field_get:protocol.TMGetObjectByHash.seq)
  return _internal_seq();
}
inline void TMGetObjectByHash::_internal_set_seq(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  seq_ = value;
}
inline void TMGetObjectByHash::set_seq(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_seq(value);
  // @@protoc_insertion_point(field_set:protocol.TMGetObjectByHash.seq)
}

// optional bytes ledgerHash = 4;
inline bool TMGetObjectByHash::_internal_has_ledgerhash() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TMGetObjectByHash::has_ledgerhash() const {
  return _internal_has_ledgerhash();
}
inline void TMGetObjectByHash::clear_ledgerhash() {
  ledgerhash_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TMGetObjectByHash::ledgerhash() const {
  // @@protoc_insertion_point(field_get:protocol.TMGetObjectByHash.ledgerHash)
  return _internal_ledgerhash();
}
inline void TMGetObjectByHash::set_ledgerhash(const std::string& value) {
  _internal_set_ledgerhash(value);
  // @@protoc_insertion_point(field_set:protocol.TMGetObjectByHash.ledgerHash)
}
inline std::string* TMGetObjectByHash::mutable_ledgerhash() {
  // @@protoc_insertion_point(field_mutable:protocol.TMGetObjectByHash.ledgerHash)
  return _internal_mutable_ledgerhash();
}
inline const std::string& TMGetObjectByHash::_internal_ledgerhash() const {
  return ledgerhash_.Get();
}
inline void TMGetObjectByHash::_internal_set_ledgerhash(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  ledgerhash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void TMGetObjectByHash::set_ledgerhash(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  ledgerhash_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:protocol.TMGetObjectByHash.ledgerHash)
}
inline void TMGetObjectByHash::set_ledgerhash(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  ledgerhash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:protocol.TMGetObjectByHash.ledgerHash)
}
inline void TMGetObjectByHash::set_ledgerhash(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  ledgerhash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:protocol.TMGetObjectByHash.ledgerHash)
}
inline std::string* TMGetObjectByHash::_internal_mutable_ledgerhash() {
  _has_bits_[0] |= 0x00000001u;
  return ledgerhash_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* TMGetObjectByHash::release_ledgerhash() {
  // @@protoc_insertion_point(field_release:protocol.TMGetObjectByHash.ledgerHash)
  if (!_internal_has_ledgerhash()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return ledgerhash_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void TMGetObjectByHash::set_allocated_ledgerhash(std::string* ledgerhash) {
  if (ledgerhash != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  ledgerhash_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ledgerhash,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:protocol.TMGetObjectByHash.ledgerHash)
}
inline std::string* TMGetObjectByHash::unsafe_arena_release_ledgerhash() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protocol.TMGetObjectByHash.ledgerHash)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return ledgerhash_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void TMGetObjectByHash::unsafe_arena_set_allocated_ledgerhash(
    std::string* ledgerhash) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (ledgerhash != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  ledgerhash_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ledgerhash, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.TMGetObjectByHash.ledgerHash)
}

// optional bool fat = 5;
inline bool TMGetObjectByHash::_internal_has_fat() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool TMGetObjectByHash::has_fat() const {
  return _internal_has_fat();
}
inline void TMGetObjectByHash::clear_fat() {
  fat_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool TMGetObjectByHash::_internal_fat() const {
  return fat_;
}
inline bool TMGetObjectByHash::fat() const {
  // @@protoc_insertion_point(field_get:protocol.TMGetObjectByHash.fat)
  return _internal_fat();
}
inline void TMGetObjectByHash::_internal_set_fat(bool value) {
  _has_bits_[0] |= 0x00000010u;
  fat_ = value;
}
inline void TMGetObjectByHash::set_fat(bool value) {
  _internal_set_fat(value);
  // @@protoc_insertion_point(field_set:protocol.TMGetObjectByHash.fat)
}

// repeated .protocol.TMIndexedObject objects = 6;
inline int TMGetObjectByHash::_internal_objects_size() const {
  return objects_.size();
}
inline int TMGetObjectByHash::objects_size() const {
  return _internal_objects_size();
}
inline void TMGetObjectByHash::clear_objects() {
  objects_.Clear();
}
inline ::protocol::TMIndexedObject* TMGetObjectByHash::mutable_objects(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.TMGetObjectByHash.objects)
  return objects_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::TMIndexedObject >*
TMGetObjectByHash::mutable_objects() {
  // @@protoc_insertion_point(field_mutable_list:protocol.TMGetObjectByHash.objects)
  return &objects_;
}
inline const ::protocol::TMIndexedObject& TMGetObjectByHash::_internal_objects(int index) const {
  return objects_.Get(index);
}
inline const ::protocol::TMIndexedObject& TMGetObjectByHash::objects(int index) const {
  // @@protoc_insertion_point(field_get:protocol.TMGetObjectByHash.objects)
  return _internal_objects(index);
}
inline ::protocol::TMIndexedObject* TMGetObjectByHash::_internal_add_objects() {
  return objects_.Add();
}
inline ::protocol::TMIndexedObject* TMGetObjectByHash::add_objects() {
  // @@protoc_insertion_point(field_add:protocol.TMGetObjectByHash.objects)
  return _internal_add_objects();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::TMIndexedObject >&
TMGetObjectByHash::objects() const {
  // @@protoc_insertion_point(field_list:protocol.TMGetObjectByHash.objects)
  return objects_;
}

// -------------------------------------------------------------------

// TMLedgerNode

// required bytes nodedata = 1;
inline bool TMLedgerNode::_internal_has_nodedata() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TMLedgerNode::has_nodedata() const {
  return _internal_has_nodedata();
}
inline void TMLedgerNode::clear_nodedata() {
  nodedata_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TMLedgerNode::nodedata() const {
  // @@protoc_insertion_point(field_get:protocol.TMLedgerNode.nodedata)
  return _internal_nodedata();
}
inline void TMLedgerNode::set_nodedata(const std::string& value) {
  _internal_set_nodedata(value);
  // @@protoc_insertion_point(field_set:protocol.TMLedgerNode.nodedata)
}
inline std::string* TMLedgerNode::mutable_nodedata() {
  // @@protoc_insertion_point(field_mutable:protocol.TMLedgerNode.nodedata)
  return _internal_mutable_nodedata();
}
inline const std::string& TMLedgerNode::_internal_nodedata() const {
  return nodedata_.Get();
}
inline void TMLedgerNode::_internal_set_nodedata(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  nodedata_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void TMLedgerNode::set_nodedata(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  nodedata_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:protocol.TMLedgerNode.nodedata)
}
inline void TMLedgerNode::set_nodedata(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  nodedata_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:protocol.TMLedgerNode.nodedata)
}
inline void TMLedgerNode::set_nodedata(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  nodedata_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:protocol.TMLedgerNode.nodedata)
}
inline std::string* TMLedgerNode::_internal_mutable_nodedata() {
  _has_bits_[0] |= 0x00000001u;
  return nodedata_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* TMLedgerNode::release_nodedata() {
  // @@protoc_insertion_point(field_release:protocol.TMLedgerNode.nodedata)
  if (!_internal_has_nodedata()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return nodedata_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void TMLedgerNode::set_allocated_nodedata(std::string* nodedata) {
  if (nodedata != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  nodedata_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), nodedata,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:protocol.TMLedgerNode.nodedata)
}
inline std::string* TMLedgerNode::unsafe_arena_release_nodedata() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protocol.TMLedgerNode.nodedata)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return nodedata_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void TMLedgerNode::unsafe_arena_set_allocated_nodedata(
    std::string* nodedata) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (nodedata != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  nodedata_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      nodedata, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.TMLedgerNode.nodedata)
}

// optional bytes nodeid = 2;
inline bool TMLedgerNode::_internal_has_nodeid() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TMLedgerNode::has_nodeid() const {
  return _internal_has_nodeid();
}
inline void TMLedgerNode::clear_nodeid() {
  nodeid_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& TMLedgerNode::nodeid() const {
  // @@protoc_insertion_point(field_get:protocol.TMLedgerNode.nodeid)
  return _internal_nodeid();
}
inline void TMLedgerNode::set_nodeid(const std::string& value) {
  _internal_set_nodeid(value);
  // @@protoc_insertion_point(field_set:protocol.TMLedgerNode.nodeid)
}
inline std::string* TMLedgerNode::mutable_nodeid() {
  // @@protoc_insertion_point(field_mutable:protocol.TMLedgerNode.nodeid)
  return _internal_mutable_nodeid();
}
inline const std::string& TMLedgerNode::_internal_nodeid() const {
  return nodeid_.Get();
}
inline void TMLedgerNode::_internal_set_nodeid(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  nodeid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void TMLedgerNode::set_nodeid(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  nodeid_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:protocol.TMLedgerNode.nodeid)
}
inline void TMLedgerNode::set_nodeid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  nodeid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:protocol.TMLedgerNode.nodeid)
}
inline void TMLedgerNode::set_nodeid(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  nodeid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:protocol.TMLedgerNode.nodeid)
}
inline std::string* TMLedgerNode::_internal_mutable_nodeid() {
  _has_bits_[0] |= 0x00000002u;
  return nodeid_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* TMLedgerNode::release_nodeid() {
  // @@protoc_insertion_point(field_release:protocol.TMLedgerNode.nodeid)
  if (!_internal_has_nodeid()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return nodeid_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void TMLedgerNode::set_allocated_nodeid(std::string* nodeid) {
  if (nodeid != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  nodeid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), nodeid,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:protocol.TMLedgerNode.nodeid)
}
inline std::string* TMLedgerNode::unsafe_arena_release_nodeid() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protocol.TMLedgerNode.nodeid)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000002u;
  return nodeid_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void TMLedgerNode::unsafe_arena_set_allocated_nodeid(
    std::string* nodeid) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (nodeid != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  nodeid_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      nodeid, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.TMLedgerNode.nodeid)
}

// -------------------------------------------------------------------

// TMGetLedger

// required .protocol.TMLedgerInfoType itype = 1;
inline bool TMGetLedger::_internal_has_itype() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TMGetLedger::has_itype() const {
  return _internal_has_itype();
}
inline void TMGetLedger::clear_itype() {
  itype_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::protocol::TMLedgerInfoType TMGetLedger::_internal_itype() const {
  return static_cast< ::protocol::TMLedgerInfoType >(itype_);
}
inline ::protocol::TMLedgerInfoType TMGetLedger::itype() const {
  // @@protoc_insertion_point(field_get:protocol.TMGetLedger.itype)
  return _internal_itype();
}
inline void TMGetLedger::_internal_set_itype(::protocol::TMLedgerInfoType value) {
  assert(::protocol::TMLedgerInfoType_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  itype_ = value;
}
inline void TMGetLedger::set_itype(::protocol::TMLedgerInfoType value) {
  _internal_set_itype(value);
  // @@protoc_insertion_point(field_set:protocol.TMGetLedger.itype)
}

// optional .protocol.TMLedgerType ltype = 2;
inline bool TMGetLedger::_internal_has_ltype() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TMGetLedger::has_ltype() const {
  return _internal_has_ltype();
}
inline void TMGetLedger::clear_ltype() {
  ltype_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::protocol::TMLedgerType TMGetLedger::_internal_ltype() const {
  return static_cast< ::protocol::TMLedgerType >(ltype_);
}
inline ::protocol::TMLedgerType TMGetLedger::ltype() const {
  // @@protoc_insertion_point(field_get:protocol.TMGetLedger.ltype)
  return _internal_ltype();
}
inline void TMGetLedger::_internal_set_ltype(::protocol::TMLedgerType value) {
  assert(::protocol::TMLedgerType_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  ltype_ = value;
}
inline void TMGetLedger::set_ltype(::protocol::TMLedgerType value) {
  _internal_set_ltype(value);
  // @@protoc_insertion_point(field_set:protocol.TMGetLedger.ltype)
}

// optional bytes ledgerHash = 3;
inline bool TMGetLedger::_internal_has_ledgerhash() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TMGetLedger::has_ledgerhash() const {
  return _internal_has_ledgerhash();
}
inline void TMGetLedger::clear_ledgerhash() {
  ledgerhash_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TMGetLedger::ledgerhash() const {
  // @@protoc_insertion_point(field_get:protocol.TMGetLedger.ledgerHash)
  return _internal_ledgerhash();
}
inline void TMGetLedger::set_ledgerhash(const std::string& value) {
  _internal_set_ledgerhash(value);
  // @@protoc_insertion_point(field_set:protocol.TMGetLedger.ledgerHash)
}
inline std::string* TMGetLedger::mutable_ledgerhash() {
  // @@protoc_insertion_point(field_mutable:protocol.TMGetLedger.ledgerHash)
  return _internal_mutable_ledgerhash();
}
inline const std::string& TMGetLedger::_internal_ledgerhash() const {
  return ledgerhash_.Get();
}
inline void TMGetLedger::_internal_set_ledgerhash(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  ledgerhash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void TMGetLedger::set_ledgerhash(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  ledgerhash_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:protocol.TMGetLedger.ledgerHash)
}
inline void TMGetLedger::set_ledgerhash(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  ledgerhash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:protocol.TMGetLedger.ledgerHash)
}
inline void TMGetLedger::set_ledgerhash(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  ledgerhash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:protocol.TMGetLedger.ledgerHash)
}
inline std::string* TMGetLedger::_internal_mutable_ledgerhash() {
  _has_bits_[0] |= 0x00000001u;
  return ledgerhash_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* TMGetLedger::release_ledgerhash() {
  // @@protoc_insertion_point(field_release:protocol.TMGetLedger.ledgerHash)
  if (!_internal_has_ledgerhash()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return ledgerhash_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void TMGetLedger::set_allocated_ledgerhash(std::string* ledgerhash) {
  if (ledgerhash != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  ledgerhash_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ledgerhash,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:protocol.TMGetLedger.ledgerHash)
}
inline std::string* TMGetLedger::unsafe_arena_release_ledgerhash() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protocol.TMGetLedger.ledgerHash)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return ledgerhash_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void TMGetLedger::unsafe_arena_set_allocated_ledgerhash(
    std::string* ledgerhash) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (ledgerhash != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  ledgerhash_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ledgerhash, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.TMGetLedger.ledgerHash)
}

// optional uint32 ledgerSeq = 4;
inline bool TMGetLedger::_internal_has_ledgerseq() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool TMGetLedger::has_ledgerseq() const {
  return _internal_has_ledgerseq();
}
inline void TMGetLedger::clear_ledgerseq() {
  ledgerseq_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TMGetLedger::_internal_ledgerseq() const {
  return ledgerseq_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TMGetLedger::ledgerseq() const {
  // @@protoc_insertion_point(field_get:protocol.TMGetLedger.ledgerSeq)
  return _internal_ledgerseq();
}
inline void TMGetLedger::_internal_set_ledgerseq(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  ledgerseq_ = value;
}
inline void TMGetLedger::set_ledgerseq(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_ledgerseq(value);
  // @@protoc_insertion_point(field_set:protocol.TMGetLedger.ledgerSeq)
}

// repeated bytes nodeIDs = 5;
inline int TMGetLedger::_internal_nodeids_size() const {
  return nodeids_.size();
}
inline int TMGetLedger::nodeids_size() const {
  return _internal_nodeids_size();
}
inline void TMGetLedger::clear_nodeids() {
  nodeids_.Clear();
}
inline std::string* TMGetLedger::add_nodeids() {
  // @@protoc_insertion_point(field_add_mutable:protocol.TMGetLedger.nodeIDs)
  return _internal_add_nodeids();
}
inline const std::string& TMGetLedger::_internal_nodeids(int index) const {
  return nodeids_.Get(index);
}
inline const std::string& TMGetLedger::nodeids(int index) const {
  // @@protoc_insertion_point(field_get:protocol.TMGetLedger.nodeIDs)
  return _internal_nodeids(index);
}
inline std::string* TMGetLedger::mutable_nodeids(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.TMGetLedger.nodeIDs)
  return nodeids_.Mutable(index);
}
inline void TMGetLedger::set_nodeids(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:protocol.TMGetLedger.nodeIDs)
  nodeids_.Mutable(index)->assign(value);
}
inline void TMGetLedger::set_nodeids(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:protocol.TMGetLedger.nodeIDs)
  nodeids_.Mutable(index)->assign(std::move(value));
}
inline void TMGetLedger::set_nodeids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  nodeids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:protocol.TMGetLedger.nodeIDs)
}
inline void TMGetLedger::set_nodeids(int index, const void* value, size_t size) {
  nodeids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:protocol.TMGetLedger.nodeIDs)
}
inline std::string* TMGetLedger::_internal_add_nodeids() {
  return nodeids_.Add();
}
inline void TMGetLedger::add_nodeids(const std::string& value) {
  nodeids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:protocol.TMGetLedger.nodeIDs)
}
inline void TMGetLedger::add_nodeids(std::string&& value) {
  nodeids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:protocol.TMGetLedger.nodeIDs)
}
inline void TMGetLedger::add_nodeids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  nodeids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:protocol.TMGetLedger.nodeIDs)
}
inline void TMGetLedger::add_nodeids(const void* value, size_t size) {
  nodeids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:protocol.TMGetLedger.nodeIDs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TMGetLedger::nodeids() const {
  // @@protoc_insertion_point(field_list:protocol.TMGetLedger.nodeIDs)
  return nodeids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TMGetLedger::mutable_nodeids() {
  // @@protoc_insertion_point(field_mutable_list:protocol.TMGetLedger.nodeIDs)
  return &nodeids_;
}

// optional uint64 requestCookie = 6;
inline bool TMGetLedger::_internal_has_requestcookie() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool TMGetLedger::has_requestcookie() const {
  return _internal_has_requestcookie();
}
inline void TMGetLedger::clear_requestcookie() {
  requestcookie_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 TMGetLedger::_internal_requestcookie() const {
  return requestcookie_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 TMGetLedger::requestcookie() const {
  // @@protoc_insertion_point(field_get:protocol.TMGetLedger.requestCookie)
  return _internal_requestcookie();
}
inline void TMGetLedger::_internal_set_requestcookie(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000020u;
  requestcookie_ = value;
}
inline void TMGetLedger::set_requestcookie(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_requestcookie(value);
  // @@protoc_insertion_point(field_set:protocol.TMGetLedger.requestCookie)
}

// optional .protocol.TMQueryType queryType = 7;
inline bool TMGetLedger::_internal_has_querytype() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool TMGetLedger::has_querytype() const {
  return _internal_has_querytype();
}
inline void TMGetLedger::clear_querytype() {
  querytype_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::protocol::TMQueryType TMGetLedger::_internal_querytype() const {
  return static_cast< ::protocol::TMQueryType >(querytype_);
}
inline ::protocol::TMQueryType TMGetLedger::querytype() const {
  // @@protoc_insertion_point(field_get:protocol.TMGetLedger.queryType)
  return _internal_querytype();
}
inline void TMGetLedger::_internal_set_querytype(::protocol::TMQueryType value) {
  assert(::protocol::TMQueryType_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  querytype_ = value;
}
inline void TMGetLedger::set_querytype(::protocol::TMQueryType value) {
  _internal_set_querytype(value);
  // @@protoc_insertion_point(field_set:protocol.TMGetLedger.queryType)
}

// optional uint32 queryDepth = 8;
inline bool TMGetLedger::_internal_has_querydepth() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool TMGetLedger::has_querydepth() const {
  return _internal_has_querydepth();
}
inline void TMGetLedger::clear_querydepth() {
  querydepth_ = 0u;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TMGetLedger::_internal_querydepth() const {
  return querydepth_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TMGetLedger::querydepth() const {
  // @@protoc_insertion_point(field_get:protocol.TMGetLedger.queryDepth)
  return _internal_querydepth();
}
inline void TMGetLedger::_internal_set_querydepth(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000040u;
  querydepth_ = value;
}
inline void TMGetLedger::set_querydepth(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_querydepth(value);
  // @@protoc_insertion_point(field_set:protocol.TMGetLedger.queryDepth)
}

// -------------------------------------------------------------------

// TMLedgerData

// required bytes ledgerHash = 1;
inline bool TMLedgerData::_internal_has_ledgerhash() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TMLedgerData::has_ledgerhash() const {
  return _internal_has_ledgerhash();
}
inline void TMLedgerData::clear_ledgerhash() {
  ledgerhash_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TMLedgerData::ledgerhash() const {
  // @@protoc_insertion_point(field_get:protocol.TMLedgerData.ledgerHash)
  return _internal_ledgerhash();
}
inline void TMLedgerData::set_ledgerhash(const std::string& value) {
  _internal_set_ledgerhash(value);
  // @@protoc_insertion_point(field_set:protocol.TMLedgerData.ledgerHash)
}
inline std::string* TMLedgerData::mutable_ledgerhash() {
  // @@protoc_insertion_point(field_mutable:protocol.TMLedgerData.ledgerHash)
  return _internal_mutable_ledgerhash();
}
inline const std::string& TMLedgerData::_internal_ledgerhash() const {
  return ledgerhash_.Get();
}
inline void TMLedgerData::_internal_set_ledgerhash(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  ledgerhash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void TMLedgerData::set_ledgerhash(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  ledgerhash_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:protocol.TMLedgerData.ledgerHash)
}
inline void TMLedgerData::set_ledgerhash(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  ledgerhash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:protocol.TMLedgerData.ledgerHash)
}
inline void TMLedgerData::set_ledgerhash(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  ledgerhash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:protocol.TMLedgerData.ledgerHash)
}
inline std::string* TMLedgerData::_internal_mutable_ledgerhash() {
  _has_bits_[0] |= 0x00000001u;
  return ledgerhash_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* TMLedgerData::release_ledgerhash() {
  // @@protoc_insertion_point(field_release:protocol.TMLedgerData.ledgerHash)
  if (!_internal_has_ledgerhash()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return ledgerhash_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void TMLedgerData::set_allocated_ledgerhash(std::string* ledgerhash) {
  if (ledgerhash != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  ledgerhash_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ledgerhash,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:protocol.TMLedgerData.ledgerHash)
}
inline std::string* TMLedgerData::unsafe_arena_release_ledgerhash() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protocol.TMLedgerData.ledgerHash)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return ledgerhash_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void TMLedgerData::unsafe_arena_set_allocated_ledgerhash(
    std::string* ledgerhash) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (ledgerhash != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  ledgerhash_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ledgerhash, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.TMLedgerData.ledgerHash)
}

// required uint32 ledgerSeq = 2;
inline bool TMLedgerData::_internal_has_ledgerseq() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TMLedgerData::has_ledgerseq() const {
  return _internal_has_ledgerseq();
}
inline void TMLedgerData::clear_ledgerseq() {
  ledgerseq_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TMLedgerData::_internal_ledgerseq() const {
  return ledgerseq_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TMLedgerData::ledgerseq() const {
  // @@protoc_insertion_point(field_get:protocol.TMLedgerData.ledgerSeq)
  return _internal_ledgerseq();
}
inline void TMLedgerData::_internal_set_ledgerseq(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  ledgerseq_ = value;
}
inline void TMLedgerData::set_ledgerseq(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_ledgerseq(value);
  // @@protoc_insertion_point(field_set:protocol.TMLedgerData.ledgerSeq)
}

// required .protocol.TMLedgerInfoType type = 3;
inline bool TMLedgerData::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TMLedgerData::has_type() const {
  return _internal_has_type();
}
inline void TMLedgerData::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::protocol::TMLedgerInfoType TMLedgerData::_internal_type() const {
  return static_cast< ::protocol::TMLedgerInfoType >(type_);
}
inline ::protocol::TMLedgerInfoType TMLedgerData::type() const {
  // @@protoc_insertion_point(field_get:protocol.TMLedgerData.type)
  return _internal_type();
}
inline void TMLedgerData::_internal_set_type(::protocol::TMLedgerInfoType value) {
  assert(::protocol::TMLedgerInfoType_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  type_ = value;
}
inline void TMLedgerData::set_type(::protocol::TMLedgerInfoType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:protocol.TMLedgerData.type)
}

// repeated .protocol.TMLedgerNode nodes = 4;
inline int TMLedgerData::_internal_nodes_size() const {
  return nodes_.size();
}
inline int TMLedgerData::nodes_size() const {
  return _internal_nodes_size();
}
inline void TMLedgerData::clear_nodes() {
  nodes_.Clear();
}
inline ::protocol::TMLedgerNode* TMLedgerData::mutable_nodes(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.TMLedgerData.nodes)
  return nodes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::TMLedgerNode >*
TMLedgerData::mutable_nodes() {
  // @@protoc_insertion_point(field_mutable_list:protocol.TMLedgerData.nodes)
  return &nodes_;
}
inline const ::protocol::TMLedgerNode& TMLedgerData::_internal_nodes(int index) const {
  return nodes_.Get(index);
}
inline const ::protocol::TMLedgerNode& TMLedgerData::nodes(int index) const {
  // @@protoc_insertion_point(field_get:protocol.TMLedgerData.nodes)
  return _internal_nodes(index);
}
inline ::protocol::TMLedgerNode* TMLedgerData::_internal_add_nodes() {
  return nodes_.Add();
}
inline ::protocol::TMLedgerNode* TMLedgerData::add_nodes() {
  // @@protoc_insertion_point(field_add:protocol.TMLedgerData.nodes)
  return _internal_add_nodes();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protocol::TMLedgerNode >&
TMLedgerData::nodes() const {
  // @@protoc_insertion_point(field_list:protocol.TMLedgerData.nodes)
  return nodes_;
}

// optional uint32 requestCookie = 5;
inline bool TMLedgerData::_internal_has_requestcookie() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool TMLedgerData::has_requestcookie() const {
  return _internal_has_requestcookie();
}
inline void TMLedgerData::clear_requestcookie() {
  requestcookie_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TMLedgerData::_internal_requestcookie() const {
  return requestcookie_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TMLedgerData::requestcookie() const {
  // @@protoc_insertion_point(field_get:protocol.TMLedgerData.requestCookie)
  return _internal_requestcookie();
}
inline void TMLedgerData::_internal_set_requestcookie(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  requestcookie_ = value;
}
inline void TMLedgerData::set_requestcookie(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_requestcookie(value);
  // @@protoc_insertion_point(field_set:protocol.TMLedgerData.requestCookie)
}

// optional .protocol.TMReplyError error = 6;
inline bool TMLedgerData::_internal_has_error() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool TMLedgerData::has_error() const {
  return _internal_has_error();
}
inline void TMLedgerData::clear_error() {
  error_ = 1;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::protocol::TMReplyError TMLedgerData::_internal_error() const {
  return static_cast< ::protocol::TMReplyError >(error_);
}
inline ::protocol::TMReplyError TMLedgerData::error() const {
  // @@protoc_insertion_point(field_get:protocol.TMLedgerData.error)
  return _internal_error();
}
inline void TMLedgerData::_internal_set_error(::protocol::TMReplyError value) {
  assert(::protocol::TMReplyError_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  error_ = value;
}
inline void TMLedgerData::set_error(::protocol::TMReplyError value) {
  _internal_set_error(value);
  // @@protoc_insertion_point(field_set:protocol.TMLedgerData.error)
}

// -------------------------------------------------------------------

// TMPing

// required .protocol.TMPing.pingType type = 1;
inline bool TMPing::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TMPing::has_type() const {
  return _internal_has_type();
}
inline void TMPing::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::protocol::TMPing_pingType TMPing::_internal_type() const {
  return static_cast< ::protocol::TMPing_pingType >(type_);
}
inline ::protocol::TMPing_pingType TMPing::type() const {
  // @@protoc_insertion_point(field_get:protocol.TMPing.type)
  return _internal_type();
}
inline void TMPing::_internal_set_type(::protocol::TMPing_pingType value) {
  assert(::protocol::TMPing_pingType_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  type_ = value;
}
inline void TMPing::set_type(::protocol::TMPing_pingType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:protocol.TMPing.type)
}

// optional uint32 seq = 2;
inline bool TMPing::_internal_has_seq() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TMPing::has_seq() const {
  return _internal_has_seq();
}
inline void TMPing::clear_seq() {
  seq_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TMPing::_internal_seq() const {
  return seq_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TMPing::seq() const {
  // @@protoc_insertion_point(field_get:protocol.TMPing.seq)
  return _internal_seq();
}
inline void TMPing::_internal_set_seq(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  seq_ = value;
}
inline void TMPing::set_seq(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_seq(value);
  // @@protoc_insertion_point(field_set:protocol.TMPing.seq)
}

// optional uint64 pingTime = 3;
inline bool TMPing::_internal_has_pingtime() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TMPing::has_pingtime() const {
  return _internal_has_pingtime();
}
inline void TMPing::clear_pingtime() {
  pingtime_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 TMPing::_internal_pingtime() const {
  return pingtime_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 TMPing::pingtime() const {
  // @@protoc_insertion_point(field_get:protocol.TMPing.pingTime)
  return _internal_pingtime();
}
inline void TMPing::_internal_set_pingtime(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  pingtime_ = value;
}
inline void TMPing::set_pingtime(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_pingtime(value);
  // @@protoc_insertion_point(field_set:protocol.TMPing.pingTime)
}

// optional uint64 netTime = 4;
inline bool TMPing::_internal_has_nettime() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool TMPing::has_nettime() const {
  return _internal_has_nettime();
}
inline void TMPing::clear_nettime() {
  nettime_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 TMPing::_internal_nettime() const {
  return nettime_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 TMPing::nettime() const {
  // @@protoc_insertion_point(field_get:protocol.TMPing.netTime)
  return _internal_nettime();
}
inline void TMPing::_internal_set_nettime(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000008u;
  nettime_ = value;
}
inline void TMPing::set_nettime(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_nettime(value);
  // @@protoc_insertion_point(field_set:protocol.TMPing.netTime)
}

// -------------------------------------------------------------------

// TMSquelch

// required bool squelch = 1;
inline bool TMSquelch::_internal_has_squelch() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TMSquelch::has_squelch() const {
  return _internal_has_squelch();
}
inline void TMSquelch::clear_squelch() {
  squelch_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool TMSquelch::_internal_squelch() const {
  return squelch_;
}
inline bool TMSquelch::squelch() const {
  // @@protoc_insertion_point(field_get:protocol.TMSquelch.squelch)
  return _internal_squelch();
}
inline void TMSquelch::_internal_set_squelch(bool value) {
  _has_bits_[0] |= 0x00000002u;
  squelch_ = value;
}
inline void TMSquelch::set_squelch(bool value) {
  _internal_set_squelch(value);
  // @@protoc_insertion_point(field_set:protocol.TMSquelch.squelch)
}

// required bytes validatorPubKey = 2;
inline bool TMSquelch::_internal_has_validatorpubkey() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TMSquelch::has_validatorpubkey() const {
  return _internal_has_validatorpubkey();
}
inline void TMSquelch::clear_validatorpubkey() {
  validatorpubkey_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TMSquelch::validatorpubkey() const {
  // @@protoc_insertion_point(field_get:protocol.TMSquelch.validatorPubKey)
  return _internal_validatorpubkey();
}
inline void TMSquelch::set_validatorpubkey(const std::string& value) {
  _internal_set_validatorpubkey(value);
  // @@protoc_insertion_point(field_set:protocol.TMSquelch.validatorPubKey)
}
inline std::string* TMSquelch::mutable_validatorpubkey() {
  // @@protoc_insertion_point(field_mutable:protocol.TMSquelch.validatorPubKey)
  return _internal_mutable_validatorpubkey();
}
inline const std::string& TMSquelch::_internal_validatorpubkey() const {
  return validatorpubkey_.Get();
}
inline void TMSquelch::_internal_set_validatorpubkey(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  validatorpubkey_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void TMSquelch::set_validatorpubkey(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  validatorpubkey_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:protocol.TMSquelch.validatorPubKey)
}
inline void TMSquelch::set_validatorpubkey(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  validatorpubkey_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:protocol.TMSquelch.validatorPubKey)
}
inline void TMSquelch::set_validatorpubkey(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  validatorpubkey_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:protocol.TMSquelch.validatorPubKey)
}
inline std::string* TMSquelch::_internal_mutable_validatorpubkey() {
  _has_bits_[0] |= 0x00000001u;
  return validatorpubkey_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* TMSquelch::release_validatorpubkey() {
  // @@protoc_insertion_point(field_release:protocol.TMSquelch.validatorPubKey)
  if (!_internal_has_validatorpubkey()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return validatorpubkey_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void TMSquelch::set_allocated_validatorpubkey(std::string* validatorpubkey) {
  if (validatorpubkey != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  validatorpubkey_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), validatorpubkey,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:protocol.TMSquelch.validatorPubKey)
}
inline std::string* TMSquelch::unsafe_arena_release_validatorpubkey() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protocol.TMSquelch.validatorPubKey)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return validatorpubkey_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void TMSquelch::unsafe_arena_set_allocated_validatorpubkey(
    std::string* validatorpubkey) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (validatorpubkey != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  validatorpubkey_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      validatorpubkey, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.TMSquelch.validatorPubKey)
}

// optional uint32 squelchDuration = 3;
inline bool TMSquelch::_internal_has_squelchduration() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TMSquelch::has_squelchduration() const {
  return _internal_has_squelchduration();
}
inline void TMSquelch::clear_squelchduration() {
  squelchduration_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TMSquelch::_internal_squelchduration() const {
  return squelchduration_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TMSquelch::squelchduration() const {
  // @@protoc_insertion_point(field_get:protocol.TMSquelch.squelchDuration)
  return _internal_squelchduration();
}
inline void TMSquelch::_internal_set_squelchduration(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  squelchduration_ = value;
}
inline void TMSquelch::set_squelchduration(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_squelchduration(value);
  // @@protoc_insertion_point(field_set:protocol.TMSquelch.squelchDuration)
}

// -------------------------------------------------------------------

// TMProofPathRequest

// required bytes key = 1;
inline bool TMProofPathRequest::_internal_has_key() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TMProofPathRequest::has_key() const {
  return _internal_has_key();
}
inline void TMProofPathRequest::clear_key() {
  key_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TMProofPathRequest::key() const {
  // @@protoc_insertion_point(field_get:protocol.TMProofPathRequest.key)
  return _internal_key();
}
inline void TMProofPathRequest::set_key(const std::string& value) {
  _internal_set_key(value);
  // @@protoc_insertion_point(field_set:protocol.TMProofPathRequest.key)
}
inline std::string* TMProofPathRequest::mutable_key() {
  // @@protoc_insertion_point(field_mutable:protocol.TMProofPathRequest.key)
  return _internal_mutable_key();
}
inline const std::string& TMProofPathRequest::_internal_key() const {
  return key_.Get();
}
inline void TMProofPathRequest::_internal_set_key(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void TMProofPathRequest::set_key(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  key_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:protocol.TMProofPathRequest.key)
}
inline void TMProofPathRequest::set_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:protocol.TMProofPathRequest.key)
}
inline void TMProofPathRequest::set_key(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:protocol.TMProofPathRequest.key)
}
inline std::string* TMProofPathRequest::_internal_mutable_key() {
  _has_bits_[0] |= 0x00000001u;
  return key_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* TMProofPathRequest::release_key() {
  // @@protoc_insertion_point(field_release:protocol.TMProofPathRequest.key)
  if (!_internal_has_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return key_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void TMProofPathRequest::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:protocol.TMProofPathRequest.key)
}
inline std::string* TMProofPathRequest::unsafe_arena_release_key() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protocol.TMProofPathRequest.key)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return key_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void TMProofPathRequest::unsafe_arena_set_allocated_key(
    std::string* key) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (key != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  key_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      key, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.TMProofPathRequest.key)
}

// required bytes ledgerHash = 2;
inline bool TMProofPathRequest::_internal_has_ledgerhash() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TMProofPathRequest::has_ledgerhash() const {
  return _internal_has_ledgerhash();
}
inline void TMProofPathRequest::clear_ledgerhash() {
  ledgerhash_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& TMProofPathRequest::ledgerhash() const {
  // @@protoc_insertion_point(field_get:protocol.TMProofPathRequest.ledgerHash)
  return _internal_ledgerhash();
}
inline void TMProofPathRequest::set_ledgerhash(const std::string& value) {
  _internal_set_ledgerhash(value);
  // @@protoc_insertion_point(field_set:protocol.TMProofPathRequest.ledgerHash)
}
inline std::string* TMProofPathRequest::mutable_ledgerhash() {
  // @@protoc_insertion_point(field_mutable:protocol.TMProofPathRequest.ledgerHash)
  return _internal_mutable_ledgerhash();
}
inline const std::string& TMProofPathRequest::_internal_ledgerhash() const {
  return ledgerhash_.Get();
}
inline void TMProofPathRequest::_internal_set_ledgerhash(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  ledgerhash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void TMProofPathRequest::set_ledgerhash(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  ledgerhash_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:protocol.TMProofPathRequest.ledgerHash)
}
inline void TMProofPathRequest::set_ledgerhash(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  ledgerhash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:protocol.TMProofPathRequest.ledgerHash)
}
inline void TMProofPathRequest::set_ledgerhash(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  ledgerhash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:protocol.TMProofPathRequest.ledgerHash)
}
inline std::string* TMProofPathRequest::_internal_mutable_ledgerhash() {
  _has_bits_[0] |= 0x00000002u;
  return ledgerhash_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* TMProofPathRequest::release_ledgerhash() {
  // @@protoc_insertion_point(field_release:protocol.TMProofPathRequest.ledgerHash)
  if (!_internal_has_ledgerhash()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return ledgerhash_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void TMProofPathRequest::set_allocated_ledgerhash(std::string* ledgerhash) {
  if (ledgerhash != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  ledgerhash_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ledgerhash,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:protocol.TMProofPathRequest.ledgerHash)
}
inline std::string* TMProofPathRequest::unsafe_arena_release_ledgerhash() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protocol.TMProofPathRequest.ledgerHash)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000002u;
  return ledgerhash_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void TMProofPathRequest::unsafe_arena_set_allocated_ledgerhash(
    std::string* ledgerhash) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (ledgerhash != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  ledgerhash_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ledgerhash, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.TMProofPathRequest.ledgerHash)
}

// required .protocol.TMLedgerMapType type = 3;
inline bool TMProofPathRequest::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TMProofPathRequest::has_type() const {
  return _internal_has_type();
}
inline void TMProofPathRequest::clear_type() {
  type_ = 1;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::protocol::TMLedgerMapType TMProofPathRequest::_internal_type() const {
  return static_cast< ::protocol::TMLedgerMapType >(type_);
}
inline ::protocol::TMLedgerMapType TMProofPathRequest::type() const {
  // @@protoc_insertion_point(field_get:protocol.TMProofPathRequest.type)
  return _internal_type();
}
inline void TMProofPathRequest::_internal_set_type(::protocol::TMLedgerMapType value) {
  assert(::protocol::TMLedgerMapType_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  type_ = value;
}
inline void TMProofPathRequest::set_type(::protocol::TMLedgerMapType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:protocol.TMProofPathRequest.type)
}

// -------------------------------------------------------------------

// TMProofPathResponse

// required bytes key = 1;
inline bool TMProofPathResponse::_internal_has_key() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TMProofPathResponse::has_key() const {
  return _internal_has_key();
}
inline void TMProofPathResponse::clear_key() {
  key_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TMProofPathResponse::key() const {
  // @@protoc_insertion_point(field_get:protocol.TMProofPathResponse.key)
  return _internal_key();
}
inline void TMProofPathResponse::set_key(const std::string& value) {
  _internal_set_key(value);
  // @@protoc_insertion_point(field_set:protocol.TMProofPathResponse.key)
}
inline std::string* TMProofPathResponse::mutable_key() {
  // @@protoc_insertion_point(field_mutable:protocol.TMProofPathResponse.key)
  return _internal_mutable_key();
}
inline const std::string& TMProofPathResponse::_internal_key() const {
  return key_.Get();
}
inline void TMProofPathResponse::_internal_set_key(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void TMProofPathResponse::set_key(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  key_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:protocol.TMProofPathResponse.key)
}
inline void TMProofPathResponse::set_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:protocol.TMProofPathResponse.key)
}
inline void TMProofPathResponse::set_key(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:protocol.TMProofPathResponse.key)
}
inline std::string* TMProofPathResponse::_internal_mutable_key() {
  _has_bits_[0] |= 0x00000001u;
  return key_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* TMProofPathResponse::release_key() {
  // @@protoc_insertion_point(field_release:protocol.TMProofPathResponse.key)
  if (!_internal_has_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return key_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void TMProofPathResponse::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:protocol.TMProofPathResponse.key)
}
inline std::string* TMProofPathResponse::unsafe_arena_release_key() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protocol.TMProofPathResponse.key)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return key_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void TMProofPathResponse::unsafe_arena_set_allocated_key(
    std::string* key) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (key != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  key_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      key, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.TMProofPathResponse.key)
}

// required bytes ledgerHash = 2;
inline bool TMProofPathResponse::_internal_has_ledgerhash() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TMProofPathResponse::has_ledgerhash() const {
  return _internal_has_ledgerhash();
}
inline void TMProofPathResponse::clear_ledgerhash() {
  ledgerhash_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& TMProofPathResponse::ledgerhash() const {
  // @@protoc_insertion_point(field_get:protocol.TMProofPathResponse.ledgerHash)
  return _internal_ledgerhash();
}
inline void TMProofPathResponse::set_ledgerhash(const std::string& value) {
  _internal_set_ledgerhash(value);
  // @@protoc_insertion_point(field_set:protocol.TMProofPathResponse.ledgerHash)
}
inline std::string* TMProofPathResponse::mutable_ledgerhash() {
  // @@protoc_insertion_point(field_mutable:protocol.TMProofPathResponse.ledgerHash)
  return _internal_mutable_ledgerhash();
}
inline const std::string& TMProofPathResponse::_internal_ledgerhash() const {
  return ledgerhash_.Get();
}
inline void TMProofPathResponse::_internal_set_ledgerhash(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  ledgerhash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void TMProofPathResponse::set_ledgerhash(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  ledgerhash_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:protocol.TMProofPathResponse.ledgerHash)
}
inline void TMProofPathResponse::set_ledgerhash(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  ledgerhash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:protocol.TMProofPathResponse.ledgerHash)
}
inline void TMProofPathResponse::set_ledgerhash(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  ledgerhash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:protocol.TMProofPathResponse.ledgerHash)
}
inline std::string* TMProofPathResponse::_internal_mutable_ledgerhash() {
  _has_bits_[0] |= 0x00000002u;
  return ledgerhash_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* TMProofPathResponse::release_ledgerhash() {
  // @@protoc_insertion_point(field_release:protocol.TMProofPathResponse.ledgerHash)
  if (!_internal_has_ledgerhash()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return ledgerhash_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void TMProofPathResponse::set_allocated_ledgerhash(std::string* ledgerhash) {
  if (ledgerhash != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  ledgerhash_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ledgerhash,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:protocol.TMProofPathResponse.ledgerHash)
}
inline std::string* TMProofPathResponse::unsafe_arena_release_ledgerhash() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protocol.TMProofPathResponse.ledgerHash)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000002u;
  return ledgerhash_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void TMProofPathResponse::unsafe_arena_set_allocated_ledgerhash(
    std::string* ledgerhash) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (ledgerhash != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  ledgerhash_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ledgerhash, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.TMProofPathResponse.ledgerHash)
}

// required .protocol.TMLedgerMapType type = 3;
inline bool TMProofPathResponse::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool TMProofPathResponse::has_type() const {
  return _internal_has_type();
}
inline void TMProofPathResponse::clear_type() {
  type_ = 1;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::protocol::TMLedgerMapType TMProofPathResponse::_internal_type() const {
  return static_cast< ::protocol::TMLedgerMapType >(type_);
}
inline ::protocol::TMLedgerMapType TMProofPathResponse::type() const {
  // @@protoc_insertion_point(field_get:protocol.TMProofPathResponse.type)
  return _internal_type();
}
inline void TMProofPathResponse::_internal_set_type(::protocol::TMLedgerMapType value) {
  assert(::protocol::TMLedgerMapType_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  type_ = value;
}
inline void TMProofPathResponse::set_type(::protocol::TMLedgerMapType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:protocol.TMProofPathResponse.type)
}

// optional bytes ledgerHeader = 4;
inline bool TMProofPathResponse::_internal_has_ledgerheader() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TMProofPathResponse::has_ledgerheader() const {
  return _internal_has_ledgerheader();
}
inline void TMProofPathResponse::clear_ledgerheader() {
  ledgerheader_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& TMProofPathResponse::ledgerheader() const {
  // @@protoc_insertion_point(field_get:protocol.TMProofPathResponse.ledgerHeader)
  return _internal_ledgerheader();
}
inline void TMProofPathResponse::set_ledgerheader(const std::string& value) {
  _internal_set_ledgerheader(value);
  // @@protoc_insertion_point(field_set:protocol.TMProofPathResponse.ledgerHeader)
}
inline std::string* TMProofPathResponse::mutable_ledgerheader() {
  // @@protoc_insertion_point(field_mutable:protocol.TMProofPathResponse.ledgerHeader)
  return _internal_mutable_ledgerheader();
}
inline const std::string& TMProofPathResponse::_internal_ledgerheader() const {
  return ledgerheader_.Get();
}
inline void TMProofPathResponse::_internal_set_ledgerheader(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  ledgerheader_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void TMProofPathResponse::set_ledgerheader(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  ledgerheader_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:protocol.TMProofPathResponse.ledgerHeader)
}
inline void TMProofPathResponse::set_ledgerheader(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  ledgerheader_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:protocol.TMProofPathResponse.ledgerHeader)
}
inline void TMProofPathResponse::set_ledgerheader(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000004u;
  ledgerheader_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:protocol.TMProofPathResponse.ledgerHeader)
}
inline std::string* TMProofPathResponse::_internal_mutable_ledgerheader() {
  _has_bits_[0] |= 0x00000004u;
  return ledgerheader_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* TMProofPathResponse::release_ledgerheader() {
  // @@protoc_insertion_point(field_release:protocol.TMProofPathResponse.ledgerHeader)
  if (!_internal_has_ledgerheader()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return ledgerheader_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void TMProofPathResponse::set_allocated_ledgerheader(std::string* ledgerheader) {
  if (ledgerheader != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  ledgerheader_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ledgerheader,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:protocol.TMProofPathResponse.ledgerHeader)
}
inline std::string* TMProofPathResponse::unsafe_arena_release_ledgerheader() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protocol.TMProofPathResponse.ledgerHeader)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000004u;
  return ledgerheader_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void TMProofPathResponse::unsafe_arena_set_allocated_ledgerheader(
    std::string* ledgerheader) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (ledgerheader != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  ledgerheader_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ledgerheader, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.TMProofPathResponse.ledgerHeader)
}

// repeated bytes path = 5;
inline int TMProofPathResponse::_internal_path_size() const {
  return path_.size();
}
inline int TMProofPathResponse::path_size() const {
  return _internal_path_size();
}
inline void TMProofPathResponse::clear_path() {
  path_.Clear();
}
inline std::string* TMProofPathResponse::add_path() {
  // @@protoc_insertion_point(field_add_mutable:protocol.TMProofPathResponse.path)
  return _internal_add_path();
}
inline const std::string& TMProofPathResponse::_internal_path(int index) const {
  return path_.Get(index);
}
inline const std::string& TMProofPathResponse::path(int index) const {
  // @@protoc_insertion_point(field_get:protocol.TMProofPathResponse.path)
  return _internal_path(index);
}
inline std::string* TMProofPathResponse::mutable_path(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.TMProofPathResponse.path)
  return path_.Mutable(index);
}
inline void TMProofPathResponse::set_path(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:protocol.TMProofPathResponse.path)
  path_.Mutable(index)->assign(value);
}
inline void TMProofPathResponse::set_path(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:protocol.TMProofPathResponse.path)
  path_.Mutable(index)->assign(std::move(value));
}
inline void TMProofPathResponse::set_path(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  path_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:protocol.TMProofPathResponse.path)
}
inline void TMProofPathResponse::set_path(int index, const void* value, size_t size) {
  path_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:protocol.TMProofPathResponse.path)
}
inline std::string* TMProofPathResponse::_internal_add_path() {
  return path_.Add();
}
inline void TMProofPathResponse::add_path(const std::string& value) {
  path_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:protocol.TMProofPathResponse.path)
}
inline void TMProofPathResponse::add_path(std::string&& value) {
  path_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:protocol.TMProofPathResponse.path)
}
inline void TMProofPathResponse::add_path(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  path_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:protocol.TMProofPathResponse.path)
}
inline void TMProofPathResponse::add_path(const void* value, size_t size) {
  path_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:protocol.TMProofPathResponse.path)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TMProofPathResponse::path() const {
  // @@protoc_insertion_point(field_list:protocol.TMProofPathResponse.path)
  return path_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TMProofPathResponse::mutable_path() {
  // @@protoc_insertion_point(field_mutable_list:protocol.TMProofPathResponse.path)
  return &path_;
}

// optional .protocol.TMReplyError error = 6;
inline bool TMProofPathResponse::_internal_has_error() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool TMProofPathResponse::has_error() const {
  return _internal_has_error();
}
inline void TMProofPathResponse::clear_error() {
  error_ = 1;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::protocol::TMReplyError TMProofPathResponse::_internal_error() const {
  return static_cast< ::protocol::TMReplyError >(error_);
}
inline ::protocol::TMReplyError TMProofPathResponse::error() const {
  // @@protoc_insertion_point(field_get:protocol.TMProofPathResponse.error)
  return _internal_error();
}
inline void TMProofPathResponse::_internal_set_error(::protocol::TMReplyError value) {
  assert(::protocol::TMReplyError_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  error_ = value;
}
inline void TMProofPathResponse::set_error(::protocol::TMReplyError value) {
  _internal_set_error(value);
  // @@protoc_insertion_point(field_set:protocol.TMProofPathResponse.error)
}

// -------------------------------------------------------------------

// TMReplayDeltaRequest

// required bytes ledgerHash = 1;
inline bool TMReplayDeltaRequest::_internal_has_ledgerhash() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TMReplayDeltaRequest::has_ledgerhash() const {
  return _internal_has_ledgerhash();
}
inline void TMReplayDeltaRequest::clear_ledgerhash() {
  ledgerhash_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TMReplayDeltaRequest::ledgerhash() const {
  // @@protoc_insertion_point(field_get:protocol.TMReplayDeltaRequest.ledgerHash)
  return _internal_ledgerhash();
}
inline void TMReplayDeltaRequest::set_ledgerhash(const std::string& value) {
  _internal_set_ledgerhash(value);
  // @@protoc_insertion_point(field_set:protocol.TMReplayDeltaRequest.ledgerHash)
}
inline std::string* TMReplayDeltaRequest::mutable_ledgerhash() {
  // @@protoc_insertion_point(field_mutable:protocol.TMReplayDeltaRequest.ledgerHash)
  return _internal_mutable_ledgerhash();
}
inline const std::string& TMReplayDeltaRequest::_internal_ledgerhash() const {
  return ledgerhash_.Get();
}
inline void TMReplayDeltaRequest::_internal_set_ledgerhash(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  ledgerhash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void TMReplayDeltaRequest::set_ledgerhash(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  ledgerhash_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:protocol.TMReplayDeltaRequest.ledgerHash)
}
inline void TMReplayDeltaRequest::set_ledgerhash(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  ledgerhash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:protocol.TMReplayDeltaRequest.ledgerHash)
}
inline void TMReplayDeltaRequest::set_ledgerhash(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  ledgerhash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:protocol.TMReplayDeltaRequest.ledgerHash)
}
inline std::string* TMReplayDeltaRequest::_internal_mutable_ledgerhash() {
  _has_bits_[0] |= 0x00000001u;
  return ledgerhash_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* TMReplayDeltaRequest::release_ledgerhash() {
  // @@protoc_insertion_point(field_release:protocol.TMReplayDeltaRequest.ledgerHash)
  if (!_internal_has_ledgerhash()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return ledgerhash_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void TMReplayDeltaRequest::set_allocated_ledgerhash(std::string* ledgerhash) {
  if (ledgerhash != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  ledgerhash_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ledgerhash,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:protocol.TMReplayDeltaRequest.ledgerHash)
}
inline std::string* TMReplayDeltaRequest::unsafe_arena_release_ledgerhash() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protocol.TMReplayDeltaRequest.ledgerHash)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return ledgerhash_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void TMReplayDeltaRequest::unsafe_arena_set_allocated_ledgerhash(
    std::string* ledgerhash) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (ledgerhash != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  ledgerhash_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ledgerhash, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.TMReplayDeltaRequest.ledgerHash)
}

// -------------------------------------------------------------------

// TMReplayDeltaResponse

// required bytes ledgerHash = 1;
inline bool TMReplayDeltaResponse::_internal_has_ledgerhash() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TMReplayDeltaResponse::has_ledgerhash() const {
  return _internal_has_ledgerhash();
}
inline void TMReplayDeltaResponse::clear_ledgerhash() {
  ledgerhash_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TMReplayDeltaResponse::ledgerhash() const {
  // @@protoc_insertion_point(field_get:protocol.TMReplayDeltaResponse.ledgerHash)
  return _internal_ledgerhash();
}
inline void TMReplayDeltaResponse::set_ledgerhash(const std::string& value) {
  _internal_set_ledgerhash(value);
  // @@protoc_insertion_point(field_set:protocol.TMReplayDeltaResponse.ledgerHash)
}
inline std::string* TMReplayDeltaResponse::mutable_ledgerhash() {
  // @@protoc_insertion_point(field_mutable:protocol.TMReplayDeltaResponse.ledgerHash)
  return _internal_mutable_ledgerhash();
}
inline const std::string& TMReplayDeltaResponse::_internal_ledgerhash() const {
  return ledgerhash_.Get();
}
inline void TMReplayDeltaResponse::_internal_set_ledgerhash(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  ledgerhash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void TMReplayDeltaResponse::set_ledgerhash(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  ledgerhash_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:protocol.TMReplayDeltaResponse.ledgerHash)
}
inline void TMReplayDeltaResponse::set_ledgerhash(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  ledgerhash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:protocol.TMReplayDeltaResponse.ledgerHash)
}
inline void TMReplayDeltaResponse::set_ledgerhash(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  ledgerhash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:protocol.TMReplayDeltaResponse.ledgerHash)
}
inline std::string* TMReplayDeltaResponse::_internal_mutable_ledgerhash() {
  _has_bits_[0] |= 0x00000001u;
  return ledgerhash_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* TMReplayDeltaResponse::release_ledgerhash() {
  // @@protoc_insertion_point(field_release:protocol.TMReplayDeltaResponse.ledgerHash)
  if (!_internal_has_ledgerhash()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return ledgerhash_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void TMReplayDeltaResponse::set_allocated_ledgerhash(std::string* ledgerhash) {
  if (ledgerhash != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  ledgerhash_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ledgerhash,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:protocol.TMReplayDeltaResponse.ledgerHash)
}
inline std::string* TMReplayDeltaResponse::unsafe_arena_release_ledgerhash() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protocol.TMReplayDeltaResponse.ledgerHash)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000001u;
  return ledgerhash_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void TMReplayDeltaResponse::unsafe_arena_set_allocated_ledgerhash(
    std::string* ledgerhash) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (ledgerhash != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  ledgerhash_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ledgerhash, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.TMReplayDeltaResponse.ledgerHash)
}

// optional bytes ledgerHeader = 2;
inline bool TMReplayDeltaResponse::_internal_has_ledgerheader() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TMReplayDeltaResponse::has_ledgerheader() const {
  return _internal_has_ledgerheader();
}
inline void TMReplayDeltaResponse::clear_ledgerheader() {
  ledgerheader_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& TMReplayDeltaResponse::ledgerheader() const {
  // @@protoc_insertion_point(field_get:protocol.TMReplayDeltaResponse.ledgerHeader)
  return _internal_ledgerheader();
}
inline void TMReplayDeltaResponse::set_ledgerheader(const std::string& value) {
  _internal_set_ledgerheader(value);
  // @@protoc_insertion_point(field_set:protocol.TMReplayDeltaResponse.ledgerHeader)
}
inline std::string* TMReplayDeltaResponse::mutable_ledgerheader() {
  // @@protoc_insertion_point(field_mutable:protocol.TMReplayDeltaResponse.ledgerHeader)
  return _internal_mutable_ledgerheader();
}
inline const std::string& TMReplayDeltaResponse::_internal_ledgerheader() const {
  return ledgerheader_.Get();
}
inline void TMReplayDeltaResponse::_internal_set_ledgerheader(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  ledgerheader_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void TMReplayDeltaResponse::set_ledgerheader(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  ledgerheader_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:protocol.TMReplayDeltaResponse.ledgerHeader)
}
inline void TMReplayDeltaResponse::set_ledgerheader(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  ledgerheader_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:protocol.TMReplayDeltaResponse.ledgerHeader)
}
inline void TMReplayDeltaResponse::set_ledgerheader(const void* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  ledgerheader_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:protocol.TMReplayDeltaResponse.ledgerHeader)
}
inline std::string* TMReplayDeltaResponse::_internal_mutable_ledgerheader() {
  _has_bits_[0] |= 0x00000002u;
  return ledgerheader_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* TMReplayDeltaResponse::release_ledgerheader() {
  // @@protoc_insertion_point(field_release:protocol.TMReplayDeltaResponse.ledgerHeader)
  if (!_internal_has_ledgerheader()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return ledgerheader_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void TMReplayDeltaResponse::set_allocated_ledgerheader(std::string* ledgerheader) {
  if (ledgerheader != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  ledgerheader_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ledgerheader,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:protocol.TMReplayDeltaResponse.ledgerHeader)
}
inline std::string* TMReplayDeltaResponse::unsafe_arena_release_ledgerheader() {
  // @@protoc_insertion_point(field_unsafe_arena_release:protocol.TMReplayDeltaResponse.ledgerHeader)
  GOOGLE_DCHECK(GetArena() != nullptr);
  _has_bits_[0] &= ~0x00000002u;
  return ledgerheader_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void TMReplayDeltaResponse::unsafe_arena_set_allocated_ledgerheader(
    std::string* ledgerheader) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (ledgerheader != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  ledgerheader_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ledgerheader, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protocol.TMReplayDeltaResponse.ledgerHeader)
}

// repeated bytes transaction = 3;
inline int TMReplayDeltaResponse::_internal_transaction_size() const {
  return transaction_.size();
}
inline int TMReplayDeltaResponse::transaction_size() const {
  return _internal_transaction_size();
}
inline void TMReplayDeltaResponse::clear_transaction() {
  transaction_.Clear();
}
inline std::string* TMReplayDeltaResponse::add_transaction() {
  // @@protoc_insertion_point(field_add_mutable:protocol.TMReplayDeltaResponse.transaction)
  return _internal_add_transaction();
}
inline const std::string& TMReplayDeltaResponse::_internal_transaction(int index) const {
  return transaction_.Get(index);
}
inline const std::string& TMReplayDeltaResponse::transaction(int index) const {
  // @@protoc_insertion_point(field_get:protocol.TMReplayDeltaResponse.transaction)
  return _internal_transaction(index);
}
inline std::string* TMReplayDeltaResponse::mutable_transaction(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.TMReplayDeltaResponse.transaction)
  return transaction_.Mutable(index);
}
inline void TMReplayDeltaResponse::set_transaction(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:protocol.TMReplayDeltaResponse.transaction)
  transaction_.Mutable(index)->assign(value);
}
inline void TMReplayDeltaResponse::set_transaction(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:protocol.TMReplayDeltaResponse.transaction)
  transaction_.Mutable(index)->assign(std::move(value));
}
inline void TMReplayDeltaResponse::set_transaction(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  transaction_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:protocol.TMReplayDeltaResponse.transaction)
}
inline void TMReplayDeltaResponse::set_transaction(int index, const void* value, size_t size) {
  transaction_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:protocol.TMReplayDeltaResponse.transaction)
}
inline std::string* TMReplayDeltaResponse::_internal_add_transaction() {
  return transaction_.Add();
}
inline void TMReplayDeltaResponse::add_transaction(const std::string& value) {
  transaction_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:protocol.TMReplayDeltaResponse.transaction)
}
inline void TMReplayDeltaResponse::add_transaction(std::string&& value) {
  transaction_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:protocol.TMReplayDeltaResponse.transaction)
}
inline void TMReplayDeltaResponse::add_transaction(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  transaction_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:protocol.TMReplayDeltaResponse.transaction)
}
inline void TMReplayDeltaResponse::add_transaction(const void* value, size_t size) {
  transaction_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:protocol.TMReplayDeltaResponse.transaction)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TMReplayDeltaResponse::transaction() const {
  // @@protoc_insertion_point(field_list:protocol.TMReplayDeltaResponse.transaction)
  return transaction_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TMReplayDeltaResponse::mutable_transaction() {
  // @@protoc_insertion_point(field_mutable_list:protocol.TMReplayDeltaResponse.transaction)
  return &transaction_;
}

// optional .protocol.TMReplyError error = 4;
inline bool TMReplayDeltaResponse::_internal_has_error() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TMReplayDeltaResponse::has_error() const {
  return _internal_has_error();
}
inline void TMReplayDeltaResponse::clear_error() {
  error_ = 1;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::protocol::TMReplyError TMReplayDeltaResponse::_internal_error() const {
  return static_cast< ::protocol::TMReplyError >(error_);
}
inline ::protocol::TMReplyError TMReplayDeltaResponse::error() const {
  // @@protoc_insertion_point(field_get:protocol.TMReplayDeltaResponse.error)
  return _internal_error();
}
inline void TMReplayDeltaResponse::_internal_set_error(::protocol::TMReplyError value) {
  assert(::protocol::TMReplyError_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  error_ = value;
}
inline void TMReplayDeltaResponse::set_error(::protocol::TMReplyError value) {
  _internal_set_error(value);
  // @@protoc_insertion_point(field_set:protocol.TMReplayDeltaResponse.error)
}

// -------------------------------------------------------------------

// TMHaveTransactions

// repeated bytes hashes = 1;
inline int TMHaveTransactions::_internal_hashes_size() const {
  return hashes_.size();
}
inline int TMHaveTransactions::hashes_size() const {
  return _internal_hashes_size();
}
inline void TMHaveTransactions::clear_hashes() {
  hashes_.Clear();
}
inline std::string* TMHaveTransactions::add_hashes() {
  // @@protoc_insertion_point(field_add_mutable:protocol.TMHaveTransactions.hashes)
  return _internal_add_hashes();
}
inline const std::string& TMHaveTransactions::_internal_hashes(int index) const {
  return hashes_.Get(index);
}
inline const std::string& TMHaveTransactions::hashes(int index) const {
  // @@protoc_insertion_point(field_get:protocol.TMHaveTransactions.hashes)
  return _internal_hashes(index);
}
inline std::string* TMHaveTransactions::mutable_hashes(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.TMHaveTransactions.hashes)
  return hashes_.Mutable(index);
}
inline void TMHaveTransactions::set_hashes(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:protocol.TMHaveTransactions.hashes)
  hashes_.Mutable(index)->assign(value);
}
inline void TMHaveTransactions::set_hashes(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:protocol.TMHaveTransactions.hashes)
  hashes_.Mutable(index)->assign(std::move(value));
}
inline void TMHaveTransactions::set_hashes(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  hashes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:protocol.TMHaveTransactions.hashes)
}
inline void TMHaveTransactions::set_hashes(int index, const void* value, size_t size) {
  hashes_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:protocol.TMHaveTransactions.hashes)
}
inline std::string* TMHaveTransactions::_internal_add_hashes() {
  return hashes_.Add();
}
inline void TMHaveTransactions::add_hashes(const std::string& value) {
  hashes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:protocol.TMHaveTransactions.hashes)
}
inline void TMHaveTransactions::add_hashes(std::string&& value) {
  hashes_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:protocol.TMHaveTransactions.hashes)
}
inline void TMHaveTransactions::add_hashes(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  hashes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:protocol.TMHaveTransactions.hashes)
}
inline void TMHaveTransactions::add_hashes(const void* value, size_t size) {
  hashes_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:protocol.TMHaveTransactions.hashes)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TMHaveTransactions::hashes() const {
  // @@protoc_insertion_point(field_list:protocol.TMHaveTransactions.hashes)
  return hashes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TMHaveTransactions::mutable_hashes() {
  // @@protoc_insertion_point(field_mutable_list:protocol.TMHaveTransactions.hashes)
  return &hashes_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace protocol

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::protocol::TMGetObjectByHash_ObjectType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::TMGetObjectByHash_ObjectType>() {
  return ::protocol::TMGetObjectByHash_ObjectType_descriptor();
}
template <> struct is_proto_enum< ::protocol::TMPing_pingType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::TMPing_pingType>() {
  return ::protocol::TMPing_pingType_descriptor();
}
template <> struct is_proto_enum< ::protocol::MessageType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::MessageType>() {
  return ::protocol::MessageType_descriptor();
}
template <> struct is_proto_enum< ::protocol::TransactionStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::TransactionStatus>() {
  return ::protocol::TransactionStatus_descriptor();
}
template <> struct is_proto_enum< ::protocol::NodeStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::NodeStatus>() {
  return ::protocol::NodeStatus_descriptor();
}
template <> struct is_proto_enum< ::protocol::NodeEvent> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::NodeEvent>() {
  return ::protocol::NodeEvent_descriptor();
}
template <> struct is_proto_enum< ::protocol::TxSetStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::TxSetStatus>() {
  return ::protocol::TxSetStatus_descriptor();
}
template <> struct is_proto_enum< ::protocol::TMLedgerInfoType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::TMLedgerInfoType>() {
  return ::protocol::TMLedgerInfoType_descriptor();
}
template <> struct is_proto_enum< ::protocol::TMLedgerType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::TMLedgerType>() {
  return ::protocol::TMLedgerType_descriptor();
}
template <> struct is_proto_enum< ::protocol::TMQueryType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::TMQueryType>() {
  return ::protocol::TMQueryType_descriptor();
}
template <> struct is_proto_enum< ::protocol::TMReplyError> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::TMReplyError>() {
  return ::protocol::TMReplyError_descriptor();
}
template <> struct is_proto_enum< ::protocol::TMLedgerMapType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::TMLedgerMapType>() {
  return ::protocol::TMLedgerMapType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_ripple_2eproto
